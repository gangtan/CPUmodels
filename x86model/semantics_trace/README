Overview:
---------------

This is a tool for testing the X86 semantics and parser. It consists of two parts:
a tracer (gntrace) and simulators (test.byte, test2.byte testSFI.byte). 

The tracer runs a binary and uses Intel's Pin instrumentation tool to record
the values of various regisers and memory locations as the program runs and
then outputs them in "mem.txt" and "regs.txt". The tracer stops the program
after 1000 instructions or after it reaches the label "fin" in the binary.

The memory values/addresses stored in "mem.txt" are addresses containing
instructions that were decoded. These addresses/values also include some values
off the top of the stack at the moment "main" is entered. It is very space
inefficient, since an instruction's memory value is dumped every time it runs!
See below for a trick to clean this up afterwards.

The simulator then reads in the memory dump and copies the initial set of
register values. It then steps through instruction by instruction, comparing
the register values it gets with the ones in the file. 

Requirements:
--------------

You need Intel's Pin analysis tool. It's pretty cool. Available from:
http://www.pintool.org/

The simulator part requires ocamlbuild. I've only tested it on Ocaml 3.10+.


Usage:
--------------

First, you need to export $PIN_PATH in your bash environment, and it should point to
the top level of the pin tool.

To build, first go to the simulator/ directory and do "make extraction". This
extracts the Coq code to Ocaml and sets everything up. 

Then run "make" in the semantics_trace/ directory. This runs the make files in tracer/ and
simulator/ and then copies the resulting binaries to the toplevel. 

To generate a trace of a file called "a.out" do:
> $PIN_PATH/pin -t gntrace.so -e "<SYMBOL NAME TO STOP TRACING AT>" -- ./a.out

If everything works, this will output "mem.txt" and "regs.txt". The former will
probably be incredibly large with lots of redundant information. You can (and
should) shrink mem.txt by doing the following:

> sort mem.txt | uniq > tmpmem
> mv tmpmem mem.txt

Now, to load the simulator run

> ./test.byte "mem.txt" "regs.txt"

Or alternatively, if you wish to test the X86Semantics2 or X86SemanticsSFI model:
> ./test2.byte 	 "mem.txt" "regs.txt"
> ./testSFI.byte "mem.txt" "regs.txt"

These will output the simulator's register values after each instruction (in a
format similar to regs.txt). If at some point the register values do not match
the corresponding values in regs.txt or the "Failed" state is reached in the
simulator, it stops and tries to print out some information about the last
instruction that was run. Note that this diagnostic print-out is not the best,
since I haven't actually implemented the stuff to pretty-print all of the types
and values we've defined. 

