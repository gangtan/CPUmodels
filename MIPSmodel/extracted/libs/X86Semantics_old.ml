open Big_int



type __ = Obj.t
let __ = let rec f _ = Obj.repr f in Obj.repr f

(** val xorb : bool -> bool -> bool **)

let xorb b1 b2 =
  if b1 then if b2 then false else true else b2

(** val negb : bool -> bool **)

let negb = function
| true -> false
| false -> true

type ('a, 'b) sum =
| Inl of 'a
| Inr of 'b

(** val fst : ('a1 * 'a2) -> 'a1 **)

let fst = function
| (x, y) -> x

(** val snd : ('a1 * 'a2) -> 'a2 **)

let snd = function
| (x, y) -> y

(** val length : 'a1 list -> Big.big_int **)

let rec length = function
| [] -> Big.zero
| y :: l' -> Big.succ (length l')

(** val app : 'a1 list -> 'a1 list -> 'a1 list **)

let rec app l m =
  match l with
  | [] -> m
  | a :: l1 -> a :: (app l1 m)

type comparison =
| Eq
| Lt
| Gt

type compareSpecT =
| CompEqT
| CompLtT
| CompGtT

(** val compareSpec2Type : comparison -> compareSpecT **)

let compareSpec2Type = function
| Eq -> CompEqT
| Lt -> CompLtT
| Gt -> CompGtT

type 'a compSpecT = compareSpecT

(** val compSpec2Type : 'a1 -> 'a1 -> comparison -> 'a1 compSpecT **)

let compSpec2Type x y c =
  compareSpec2Type c

type 'a sig0 =
  'a
  (* singleton inductive, whose constructor was exist *)

type ('a, 'p) sigT =
| ExistT of 'a * 'p

type 'a exc = 'a option

(** val value : 'a1 -> 'a1 option **)

let value x =
  Some x

(** val error : 'a1 option **)

let error =
  None

(** val plus : Big.big_int -> Big.big_int -> Big.big_int **)

let rec plus = Big.add

(** val mult : Big.big_int -> Big.big_int -> Big.big_int **)

let rec mult = Big.mult

(** val minus : Big.big_int -> Big.big_int -> Big.big_int **)

let rec minus = fun n m -> Big.max Big.zero (Big.sub n m)

(** val nat_iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)

let rec nat_iter n f x =
  Big.nat_case
    (fun _ ->
    x)
    (fun n' ->
    f (nat_iter n' f x))
    n

(** val bool_dec : bool -> bool -> bool **)

let bool_dec b1 b2 =
  if b1 then if b2 then true else false else if b2 then false else true

(** val eqb : bool -> bool -> bool **)

let eqb b1 b2 =
  if b1 then b2 else if b2 then false else true

type reflect =
| ReflectT
| ReflectF

(** val iff_reflect : bool -> reflect **)

let iff_reflect = function
| true -> ReflectT
| false -> ReflectF

module type TotalOrder' = 
 sig 
  type t 
 end

module MakeOrderTac = 
 functor (O:TotalOrder') ->
 struct 
  
 end

module MaxLogicalProperties = 
 functor (O:TotalOrder') ->
 functor (M:sig 
  val max : O.t -> O.t -> O.t
 end) ->
 struct 
  module Private_Tac = MakeOrderTac(O)
 end

module Pos = 
 struct 
  type t = Big.big_int
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let rec succ x =
    Big.positive_case
      (fun p -> Big.double
      (succ p))
      (fun p -> Big.doubleplusone
      p)
      (fun _ -> Big.double
      Big.one)
      x
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec add x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q -> Big.double
        (add_carry p q))
        (fun q -> Big.doubleplusone
        (add p q))
        (fun _ -> Big.double
        (succ p))
        y)
      (fun p ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (add p q))
        (fun q -> Big.double
        (add p q))
        (fun _ -> Big.doubleplusone
        p)
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.double
        (succ q))
        (fun q -> Big.doubleplusone
        q)
        (fun _ -> Big.double
        Big.one)
        y)
      x
  
  (** val add_carry : Big.big_int -> Big.big_int -> Big.big_int **)
  
  and add_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (add_carry p q))
        (fun q -> Big.double
        (add_carry p q))
        (fun _ -> Big.doubleplusone
        (succ p))
        y)
      (fun p ->
      Big.positive_case
        (fun q -> Big.double
        (add_carry p q))
        (fun q -> Big.doubleplusone
        (add p q))
        (fun _ -> Big.double
        (succ p))
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (succ q))
        (fun q -> Big.double
        (succ q))
        (fun _ -> Big.doubleplusone
        Big.one)
        y)
      x
  
  (** val pred_double : Big.big_int -> Big.big_int **)
  
  let rec pred_double x =
    Big.positive_case
      (fun p -> Big.doubleplusone (Big.double
      p))
      (fun p -> Big.doubleplusone
      (pred_double p))
      (fun _ ->
      Big.one)
      x
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred x =
    Big.positive_case
      (fun p -> Big.double
      p)
      (fun p ->
      pred_double p)
      (fun _ ->
      Big.one)
      x
  
  (** val pred_N : Big.big_int -> Big.big_int **)
  
  let pred_N x =
    Big.positive_case
      (fun p -> (Big.double
      p))
      (fun p ->
      (pred_double p))
      (fun _ ->
      Big.zero)
      x
  
  type mask =
  | IsNul
  | IsPos of Big.big_int
  | IsNeg
  
  (** val mask_rect : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rect f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val mask_rec : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rec f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val succ_double_mask : mask -> mask **)
  
  let succ_double_mask = function
  | IsNul -> IsPos Big.one
  | IsPos p -> IsPos (Big.doubleplusone p)
  | IsNeg -> IsNeg
  
  (** val double_mask : mask -> mask **)
  
  let double_mask = function
  | IsPos p -> IsPos (Big.double p)
  | x0 -> x0
  
  (** val double_pred_mask : Big.big_int -> mask **)
  
  let double_pred_mask x =
    Big.positive_case
      (fun p -> IsPos (Big.double (Big.double
      p)))
      (fun p -> IsPos (Big.double
      (pred_double p)))
      (fun _ ->
      IsNul)
      x
  
  (** val pred_mask : mask -> mask **)
  
  let pred_mask = function
  | IsPos q ->
    (Big.positive_case
       (fun p0 -> IsPos
       (pred q))
       (fun p0 -> IsPos
       (pred q))
       (fun _ ->
       IsNul)
       q)
  | _ -> IsNeg
  
  (** val sub_mask : Big.big_int -> Big.big_int -> mask **)
  
  let rec sub_mask x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask p q))
        (fun q ->
        succ_double_mask (sub_mask p q))
        (fun _ -> IsPos (Big.double
        p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun _ ->
      Big.positive_case
        (fun p ->
        IsNeg)
        (fun p ->
        IsNeg)
        (fun _ ->
        IsNul)
        y)
      x
  
  (** val sub_mask_carry : Big.big_int -> Big.big_int -> mask **)
  
  and sub_mask_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask_carry p q))
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun _ ->
        double_pred_mask p)
        y)
      (fun _ ->
      IsNeg)
      x
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub x y =
    match sub_mask x y with
    | IsPos z -> z
    | _ -> Big.one
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec mul x y =
    Big.positive_case
      (fun p ->
      add y (Big.double (mul p y)))
      (fun p -> Big.double
      (mul p y))
      (fun _ ->
      y)
      x
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let rec iter n f x =
    Big.positive_case
      (fun n' ->
      f (iter n' f (iter n' f x)))
      (fun n' ->
      iter n' f (iter n' f x))
      (fun _ ->
      f x)
      n
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow x y =
    iter y (mul x) Big.one
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let rec square p =
    Big.positive_case
      (fun p0 -> Big.doubleplusone (Big.double
      (add (square p0) p0)))
      (fun p0 -> Big.double (Big.double
      (square p0)))
      (fun _ ->
      Big.one)
      p
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 p =
    Big.positive_case
      (fun p0 ->
      p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val div2_up : Big.big_int -> Big.big_int **)
  
  let div2_up p =
    Big.positive_case
      (fun p0 ->
      succ p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val size_nat : Big.big_int -> Big.big_int **)
  
  let rec size_nat p =
    Big.positive_case
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun _ -> Big.succ
      Big.zero)
      p
  
  (** val size : Big.big_int -> Big.big_int **)
  
  let rec size p =
    Big.positive_case
      (fun p0 ->
      succ (size p0))
      (fun p0 ->
      succ (size p0))
      (fun _ ->
      Big.one)
      p
  
  (** val compare_cont :
      Big.big_int -> Big.big_int -> comparison -> comparison **)
  
  let rec compare_cont x y r2 =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        compare_cont p q r2)
        (fun q ->
        compare_cont p q Gt)
        (fun _ ->
        Gt)
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        compare_cont p q Lt)
        (fun q ->
        compare_cont p q r2)
        (fun _ ->
        Gt)
        y)
      (fun _ ->
      Big.positive_case
        (fun q ->
        Lt)
        (fun q ->
        Lt)
        (fun _ ->
        r2)
        y)
      x
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare x y =
    compare_cont x y Eq
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min p p' =
    match compare p p' with
    | Gt -> p'
    | _ -> p
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max p p' =
    match compare p p' with
    | Gt -> p
    | _ -> p'
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        eqb p0 q0)
        (fun p1 ->
        false)
        (fun _ ->
        false)
        q)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        false)
        (fun q0 ->
        eqb p0 q0)
        (fun _ ->
        false)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        q)
      p
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val sqrtrem_step :
      (Big.big_int -> Big.big_int) -> (Big.big_int -> Big.big_int) ->
      (Big.big_int * mask) -> Big.big_int * mask **)
  
  let sqrtrem_step f g = function
  | (s, y) ->
    (match y with
     | IsPos r2 ->
       let s' = Big.doubleplusone (Big.double s) in
       let r' = g (f r2) in
       if leb s' r'
       then ((Big.doubleplusone s), (sub_mask r' s'))
       else ((Big.double s), (IsPos r'))
     | _ ->
       ((Big.double s),
         (sub_mask (g (f Big.one)) (Big.double (Big.double Big.one)))))
  
  (** val sqrtrem : Big.big_int -> Big.big_int * mask **)
  
  let rec sqrtrem p =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x ->
          Big.doubleplusone x) (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.doubleplusone x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos (Big.double
        Big.one))))
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos
        Big.one)))
        p0)
      (fun _ -> (Big.one,
      IsNul))
      p
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt p =
    fst (sqrtrem p)
  
  (** val gcdn : Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec gcdn n a b =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> a
          | Lt -> gcdn n0 (sub b' a') a
          | Gt -> gcdn n0 (sub a' b') b)
          (fun b0 ->
          gcdn n0 a b0)
          (fun _ ->
          Big.one)
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          gcdn n0 a0 b)
          (fun b0 -> Big.double
          (gcdn n0 a0 b0))
          (fun _ ->
          Big.one)
          b)
        (fun _ ->
        Big.one)
        a)
      n
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val ggcdn :
      Big.big_int -> Big.big_int -> Big.big_int ->
      Big.big_int * (Big.big_int * Big.big_int) **)
  
  let rec ggcdn n a b =
    Big.nat_case
      (fun _ -> (Big.one, (a,
      b)))
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> (a, (Big.one, Big.one))
          | Lt ->
            let (g, p) = ggcdn n0 (sub b' a') a in
            let (ba, aa) = p in (g, (aa, (add aa (Big.double ba))))
          | Gt ->
            let (g, p) = ggcdn n0 (sub a' b') b in
            let (ab, bb) = p in (g, ((add bb (Big.double ab)), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a b0 in
          let (aa, bb) = p in (g, (aa, (Big.double bb))))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          let (g, p0) = ggcdn n0 a0 b in
          let (aa, bb) = p0 in (g, ((Big.double aa), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a0 b0 in ((Big.double g), p))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun _ -> (Big.one, (Big.one,
        b)))
        a)
      n
  
  (** val ggcd :
      Big.big_int -> Big.big_int -> Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val coq_Nsucc_double : Big.big_int -> Big.big_int **)
  
  let coq_Nsucc_double x =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p -> (Big.doubleplusone
      p))
      x
  
  (** val coq_Ndouble : Big.big_int -> Big.big_int **)
  
  let coq_Ndouble n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p -> (Big.double
      p))
      n
  
  (** val coq_lor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_lor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun _ ->
        p)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun q0 -> Big.double
        (coq_lor p0 q0))
        (fun _ -> Big.doubleplusone
        p0)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        q)
        (fun q0 -> Big.doubleplusone
        q0)
        (fun _ ->
        q)
        q)
      p
  
  (** val coq_land : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_land p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double (coq_land p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun _ ->
        Big.one)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun _ ->
        Big.zero)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.one)
        (fun q0 ->
        Big.zero)
        (fun _ ->
        Big.one)
        q)
      p
  
  (** val ldiff : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec ldiff p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun q0 ->
        coq_Nsucc_double (ldiff p0 q0))
        (fun _ -> (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun _ ->
        p)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.zero)
        (fun q0 ->
        Big.one)
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val coq_lxor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_lxor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (coq_lxor p0 q0))
        (fun q0 ->
        coq_Nsucc_double (coq_lxor p0 q0))
        (fun _ -> (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double (coq_lxor p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_lxor p0 q0))
        (fun _ -> (Big.doubleplusone
        p0))
        q)
      (fun _ ->
      Big.positive_case
        (fun q0 -> (Big.double
        q0))
        (fun q0 -> (Big.doubleplusone
        q0))
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val shiftl_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl_nat p n =
    nat_iter n (fun x -> Big.double x) p
  
  (** val shiftr_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr_nat p n =
    nat_iter n div2 p
  
  (** val shiftl : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter n0 (fun x -> Big.double x) p)
      n
  
  (** val shiftr : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter n0 div2 p)
      n
  
  (** val testbit_nat : Big.big_int -> Big.big_int -> bool **)
  
  let rec testbit_nat p n =
    Big.positive_case
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n' ->
        testbit_nat p0 n')
        n)
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        false)
        (fun n' ->
        testbit_nat p0 n')
        n)
      (fun _ ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n0 ->
        false)
        n)
      p
  
  (** val testbit : Big.big_int -> Big.big_int -> bool **)
  
  let rec testbit p n =
    Big.positive_case
      (fun p0 ->
      Big.n_case
        (fun _ ->
        true)
        (fun n0 ->
        testbit p0 (pred_N n0))
        n)
      (fun p0 ->
      Big.n_case
        (fun _ ->
        false)
        (fun n0 ->
        testbit p0 (pred_N n0))
        n)
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p0 ->
        false)
        n)
      p
  
  (** val iter_op : ('a1 -> 'a1 -> 'a1) -> Big.big_int -> 'a1 -> 'a1 **)
  
  let rec iter_op op p a =
    Big.positive_case
      (fun p0 ->
      op a (iter_op op p0 (op a a)))
      (fun p0 ->
      iter_op op p0 (op a a))
      (fun _ ->
      a)
      p
  
  (** val to_nat : Big.big_int -> Big.big_int **)
  
  let to_nat x =
    iter_op plus x (Big.succ Big.zero)
  
  (** val of_nat : Big.big_int -> Big.big_int **)
  
  let rec of_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      Big.nat_case
        (fun _ ->
        Big.one)
        (fun n0 ->
        succ (of_nat x))
        x)
      n
  
  (** val of_succ_nat : Big.big_int -> Big.big_int **)
  
  let rec of_succ_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      succ (of_succ_nat x))
      n
 end

module Coq_Pos = 
 struct 
  type t = Big.big_int
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let rec succ = Big.succ
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec add = Big.add
  
  (** val add_carry : Big.big_int -> Big.big_int -> Big.big_int **)
  
  and add_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (add_carry p q))
        (fun q -> Big.double
        (add_carry p q))
        (fun _ -> Big.doubleplusone
        (succ p))
        y)
      (fun p ->
      Big.positive_case
        (fun q -> Big.double
        (add_carry p q))
        (fun q -> Big.doubleplusone
        (add p q))
        (fun _ -> Big.double
        (succ p))
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (succ q))
        (fun q -> Big.double
        (succ q))
        (fun _ -> Big.doubleplusone
        Big.one)
        y)
      x
  
  (** val pred_double : Big.big_int -> Big.big_int **)
  
  let rec pred_double x =
    Big.positive_case
      (fun p -> Big.doubleplusone (Big.double
      p))
      (fun p -> Big.doubleplusone
      (pred_double p))
      (fun _ ->
      Big.one)
      x
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred = fun n -> Big.max Big.one (Big.pred n)
  
  (** val pred_N : Big.big_int -> Big.big_int **)
  
  let pred_N x =
    Big.positive_case
      (fun p -> (Big.double
      p))
      (fun p ->
      (pred_double p))
      (fun _ ->
      Big.zero)
      x
  
  type mask = Pos.mask =
  | IsNul
  | IsPos of Big.big_int
  | IsNeg
  
  (** val mask_rect : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rect f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val mask_rec : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rec f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val succ_double_mask : mask -> mask **)
  
  let succ_double_mask = function
  | IsNul -> IsPos Big.one
  | IsPos p -> IsPos (Big.doubleplusone p)
  | IsNeg -> IsNeg
  
  (** val double_mask : mask -> mask **)
  
  let double_mask = function
  | IsPos p -> IsPos (Big.double p)
  | x0 -> x0
  
  (** val double_pred_mask : Big.big_int -> mask **)
  
  let double_pred_mask x =
    Big.positive_case
      (fun p -> IsPos (Big.double (Big.double
      p)))
      (fun p -> IsPos (Big.double
      (pred_double p)))
      (fun _ ->
      IsNul)
      x
  
  (** val pred_mask : mask -> mask **)
  
  let pred_mask = function
  | IsPos q ->
    (Big.positive_case
       (fun p0 -> IsPos
       (pred q))
       (fun p0 -> IsPos
       (pred q))
       (fun _ ->
       IsNul)
       q)
  | _ -> IsNeg
  
  (** val sub_mask : Big.big_int -> Big.big_int -> mask **)
  
  let rec sub_mask x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask p q))
        (fun q ->
        succ_double_mask (sub_mask p q))
        (fun _ -> IsPos (Big.double
        p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun _ ->
      Big.positive_case
        (fun p ->
        IsNeg)
        (fun p ->
        IsNeg)
        (fun _ ->
        IsNul)
        y)
      x
  
  (** val sub_mask_carry : Big.big_int -> Big.big_int -> mask **)
  
  and sub_mask_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask_carry p q))
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun _ ->
        double_pred_mask p)
        y)
      (fun _ ->
      IsNeg)
      x
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub = fun n m -> Big.max Big.one (Big.sub n m)
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec mul = Big.mult
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let rec iter n f x =
    Big.positive_case
      (fun n' ->
      f (iter n' f (iter n' f x)))
      (fun n' ->
      iter n' f (iter n' f x))
      (fun _ ->
      f x)
      n
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow x y =
    iter y (mul x) Big.one
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let rec square p =
    Big.positive_case
      (fun p0 -> Big.doubleplusone (Big.double
      (add (square p0) p0)))
      (fun p0 -> Big.double (Big.double
      (square p0)))
      (fun _ ->
      Big.one)
      p
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 p =
    Big.positive_case
      (fun p0 ->
      p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val div2_up : Big.big_int -> Big.big_int **)
  
  let div2_up p =
    Big.positive_case
      (fun p0 ->
      succ p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val size_nat : Big.big_int -> Big.big_int **)
  
  let rec size_nat p =
    Big.positive_case
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun _ -> Big.succ
      Big.zero)
      p
  
  (** val size : Big.big_int -> Big.big_int **)
  
  let rec size p =
    Big.positive_case
      (fun p0 ->
      succ (size p0))
      (fun p0 ->
      succ (size p0))
      (fun _ ->
      Big.one)
      p
  
  (** val compare_cont :
      Big.big_int -> Big.big_int -> comparison -> comparison **)
  
  let rec compare_cont = fun x y c -> Big.compare_case c Lt Gt x y
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare = fun x y -> Big.compare_case Eq Lt Gt x y
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min = Big.min
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max = Big.max
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        eqb p0 q0)
        (fun p1 ->
        false)
        (fun _ ->
        false)
        q)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        false)
        (fun q0 ->
        eqb p0 q0)
        (fun _ ->
        false)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        q)
      p
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val sqrtrem_step :
      (Big.big_int -> Big.big_int) -> (Big.big_int -> Big.big_int) ->
      (Big.big_int * mask) -> Big.big_int * mask **)
  
  let sqrtrem_step f g = function
  | (s, y) ->
    (match y with
     | IsPos r2 ->
       let s' = Big.doubleplusone (Big.double s) in
       let r' = g (f r2) in
       if leb s' r'
       then ((Big.doubleplusone s), (sub_mask r' s'))
       else ((Big.double s), (IsPos r'))
     | _ ->
       ((Big.double s),
         (sub_mask (g (f Big.one)) (Big.double (Big.double Big.one)))))
  
  (** val sqrtrem : Big.big_int -> Big.big_int * mask **)
  
  let rec sqrtrem p =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x ->
          Big.doubleplusone x) (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.doubleplusone x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos (Big.double
        Big.one))))
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos
        Big.one)))
        p0)
      (fun _ -> (Big.one,
      IsNul))
      p
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt p =
    fst (sqrtrem p)
  
  (** val gcdn : Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec gcdn n a b =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> a
          | Lt -> gcdn n0 (sub b' a') a
          | Gt -> gcdn n0 (sub a' b') b)
          (fun b0 ->
          gcdn n0 a b0)
          (fun _ ->
          Big.one)
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          gcdn n0 a0 b)
          (fun b0 -> Big.double
          (gcdn n0 a0 b0))
          (fun _ ->
          Big.one)
          b)
        (fun _ ->
        Big.one)
        a)
      n
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val ggcdn :
      Big.big_int -> Big.big_int -> Big.big_int ->
      Big.big_int * (Big.big_int * Big.big_int) **)
  
  let rec ggcdn n a b =
    Big.nat_case
      (fun _ -> (Big.one, (a,
      b)))
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> (a, (Big.one, Big.one))
          | Lt ->
            let (g, p) = ggcdn n0 (sub b' a') a in
            let (ba, aa) = p in (g, (aa, (add aa (Big.double ba))))
          | Gt ->
            let (g, p) = ggcdn n0 (sub a' b') b in
            let (ab, bb) = p in (g, ((add bb (Big.double ab)), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a b0 in
          let (aa, bb) = p in (g, (aa, (Big.double bb))))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          let (g,
               p0) =
            ggcdn
              n0
              a0
              b
          in
          let (aa,
               bb) =
            p0
          in
          (g,
          ((Big.double
          aa),
          bb)))
          (fun b0 ->
          let (g,
               p) =
            ggcdn
              n0
              a0
              b0
          in
          ((Big.double
          g),
          p))
          (fun _ ->
          (Big.one,
          (a,
          Big.one)))
          b)
        (fun _ ->
        (Big.one,
        (Big.one,
        b)))
        a)
      n
  
  (** val ggcd :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    ggcdn
      (plus
        (size_nat
          a)
        (size_nat
          b))
      a
      b
  
  (** val coq_Nsucc_double :
      Big.big_int
      ->
      Big.big_int **)
  
  let coq_Nsucc_double x =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p ->
      (Big.doubleplusone
      p))
      x
  
  (** val coq_Ndouble :
      Big.big_int
      ->
      Big.big_int **)
  
  let coq_Ndouble n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Big.double
      p))
      n
  
  (** val coq_lor :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let rec coq_lor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        Big.doubleplusone
        (coq_lor
          p0
          q0))
        (fun q0 ->
        Big.doubleplusone
        (coq_lor
          p0
          q0))
        (fun _ ->
        p)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        Big.doubleplusone
        (coq_lor
          p0
          q0))
        (fun q0 ->
        Big.double
        (coq_lor
          p0
          q0))
        (fun _ ->
        Big.doubleplusone
        p0)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        q)
        (fun q0 ->
        Big.doubleplusone
        q0)
        (fun _ ->
        q)
        q)
      p
  
  (** val coq_land :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let rec coq_land p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double
          (coq_land
            p0
            q0))
        (fun q0 ->
        coq_Ndouble
          (coq_land
            p0
            q0))
        (fun _ ->
        Big.one)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble
          (coq_land
            p0
            q0))
        (fun q0 ->
        coq_Ndouble
          (coq_land
            p0
            q0))
        (fun _ ->
        Big.zero)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.one)
        (fun q0 ->
        Big.zero)
        (fun _ ->
        Big.one)
        q)
      p
  
  (** val ldiff :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let rec ldiff p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble
          (ldiff
            p0
            q0))
        (fun q0 ->
        coq_Nsucc_double
          (ldiff
            p0
            q0))
        (fun _ ->
        (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble
          (ldiff
            p0
            q0))
        (fun q0 ->
        coq_Ndouble
          (ldiff
            p0
            q0))
        (fun _ ->
        p)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.zero)
        (fun q0 ->
        Big.one)
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val coq_lxor :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let rec coq_lxor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble
          (coq_lxor
            p0
            q0))
        (fun q0 ->
        coq_Nsucc_double
          (coq_lxor
            p0
            q0))
        (fun _ ->
        (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double
          (coq_lxor
            p0
            q0))
        (fun q0 ->
        coq_Ndouble
          (coq_lxor
            p0
            q0))
        (fun _ ->
        (Big.doubleplusone
        p0))
        q)
      (fun _ ->
      Big.positive_case
        (fun q0 ->
        (Big.double
        q0))
        (fun q0 ->
        (Big.doubleplusone
        q0))
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val shiftl_nat :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftl_nat p n =
    nat_iter
      n
      (fun x ->
      Big.double
      x)
      p
  
  (** val shiftr_nat :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftr_nat p n =
    nat_iter
      n
      div2
      p
  
  (** val shiftl :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftl p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter
        n0
        (fun x ->
        Big.double
        x)
        p)
      n
  
  (** val shiftr :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftr p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter
        n0
        div2
        p)
      n
  
  (** val testbit_nat :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let rec testbit_nat p n =
    Big.positive_case
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n' ->
        testbit_nat
          p0
          n')
        n)
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        false)
        (fun n' ->
        testbit_nat
          p0
          n')
        n)
      (fun _ ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n0 ->
        false)
        n)
      p
  
  (** val testbit :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let rec testbit p n =
    Big.positive_case
      (fun p0 ->
      Big.n_case
        (fun _ ->
        true)
        (fun n0 ->
        testbit
          p0
          (pred_N
            n0))
        n)
      (fun p0 ->
      Big.n_case
        (fun _ ->
        false)
        (fun n0 ->
        testbit
          p0
          (pred_N
            n0))
        n)
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p0 ->
        false)
        n)
      p
  
  (** val iter_op :
      ('a1
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1
      ->
      'a1 **)
  
  let rec iter_op op p a =
    Big.positive_case
      (fun p0 ->
      op
        a
        (iter_op
          op
          p0
          (op
            a
            a)))
      (fun p0 ->
      iter_op
        op
        p0
        (op
          a
          a))
      (fun _ ->
      a)
      p
  
  (** val to_nat :
      Big.big_int
      ->
      Big.big_int **)
  
  let to_nat x =
    iter_op
      plus
      x
      (Big.succ
      Big.zero)
  
  (** val of_nat :
      Big.big_int
      ->
      Big.big_int **)
  
  let rec of_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      Big.nat_case
        (fun _ ->
        Big.one)
        (fun n0 ->
        succ
          (of_nat
            x))
        x)
      n
  
  (** val of_succ_nat :
      Big.big_int
      ->
      Big.big_int **)
  
  let rec of_succ_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      succ
        (of_succ_nat
          x))
      n
  
  (** val eq_dec :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let rec eq_dec p y0 =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        eq_dec
          p0
          p1)
        (fun p1 ->
        false)
        (fun _ ->
        false)
        y0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        false)
        (fun p1 ->
        eq_dec
          p0
          p1)
        (fun _ ->
        false)
        y0)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        y0)
      p
  
  (** val peano_rect :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let rec peano_rect a f p =
    let f2 =
      peano_rect
        (f
          Big.one
          a)
        (fun p0 x ->
        f
          (succ
            (Big.double
            p0))
          (f
            (Big.double
            p0)
            x))
    in
    (Big.positive_case
       (fun q ->
       f
         (Big.double
         q)
         (f2
           q))
       (fun q ->
       f2
         q)
       (fun _ ->
       a)
       p)
  
  (** val peano_rec :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let peano_rec =
    peano_rect
  
  type coq_PeanoView =
  | PeanoOne
  | PeanoSucc of Big.big_int
     * coq_PeanoView
  
  (** val coq_PeanoView_rect :
      'a1
      ->
      (Big.big_int
      ->
      coq_PeanoView
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      coq_PeanoView
      ->
      'a1 **)
  
  let rec coq_PeanoView_rect f f0 p = function
  | PeanoOne ->
    f
  | PeanoSucc (p1,
               p2) ->
    f0
      p1
      p2
      (coq_PeanoView_rect
        f
        f0
        p1
        p2)
  
  (** val coq_PeanoView_rec :
      'a1
      ->
      (Big.big_int
      ->
      coq_PeanoView
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      coq_PeanoView
      ->
      'a1 **)
  
  let rec coq_PeanoView_rec f f0 p = function
  | PeanoOne ->
    f
  | PeanoSucc (p1,
               p2) ->
    f0
      p1
      p2
      (coq_PeanoView_rec
        f
        f0
        p1
        p2)
  
  (** val peanoView_xO :
      Big.big_int
      ->
      coq_PeanoView
      ->
      coq_PeanoView **)
  
  let rec peanoView_xO p = function
  | PeanoOne ->
    PeanoSucc
      (Big.one,
      PeanoOne)
  | PeanoSucc (p0,
               q0) ->
    PeanoSucc
      ((succ
         (Big.double
         p0)),
      (PeanoSucc
      ((Big.double
      p0),
      (peanoView_xO
        p0
        q0))))
  
  (** val peanoView_xI :
      Big.big_int
      ->
      coq_PeanoView
      ->
      coq_PeanoView **)
  
  let rec peanoView_xI p = function
  | PeanoOne ->
    PeanoSucc
      ((succ
         Big.one),
      (PeanoSucc
      (Big.one,
      PeanoOne)))
  | PeanoSucc (p0,
               q0) ->
    PeanoSucc
      ((succ
         (Big.doubleplusone
         p0)),
      (PeanoSucc
      ((Big.doubleplusone
      p0),
      (peanoView_xI
        p0
        q0))))
  
  (** val peanoView :
      Big.big_int
      ->
      coq_PeanoView **)
  
  let rec peanoView p =
    Big.positive_case
      (fun p0 ->
      peanoView_xI
        p0
        (peanoView
          p0))
      (fun p0 ->
      peanoView_xO
        p0
        (peanoView
          p0))
      (fun _ ->
      PeanoOne)
      p
  
  (** val coq_PeanoView_iter :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      coq_PeanoView
      ->
      'a1 **)
  
  let rec coq_PeanoView_iter a f p = function
  | PeanoOne ->
    a
  | PeanoSucc (p0,
               q0) ->
    f
      p0
      (coq_PeanoView_iter
        a
        f
        p0
        q0)
  
  (** val eqb_spec :
      Big.big_int
      ->
      Big.big_int
      ->
      reflect **)
  
  let eqb_spec x y =
    iff_reflect
      (eqb
        x
        y)
  
  (** val switch_Eq :
      comparison
      ->
      comparison
      ->
      comparison **)
  
  let switch_Eq c = function
  | Eq ->
    c
  | x ->
    x
  
  (** val mask2cmp :
      mask
      ->
      comparison **)
  
  let mask2cmp = function
  | IsNul ->
    Eq
  | IsPos p0 ->
    Gt
  | IsNeg ->
    Lt
  
  (** val leb_spec0 :
      Big.big_int
      ->
      Big.big_int
      ->
      reflect **)
  
  let leb_spec0 x y =
    iff_reflect
      (leb
        x
        y)
  
  (** val ltb_spec0 :
      Big.big_int
      ->
      Big.big_int
      ->
      reflect **)
  
  let ltb_spec0 x y =
    iff_reflect
      (ltb
        x
        y)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Rev = 
   struct 
    module ORev = 
     struct 
      type t
        =
        Big.big_int
     end
    
    module MRev = 
     struct 
      (** val max :
          Big.big_int
          ->
          Big.big_int
          ->
          Big.big_int **)
      
      let max x y =
        min
          y
          x
     end
    
    module MPRev = MaxLogicalProperties(ORev)(MRev)
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        'a1 **)
    
    let max_case_strong n m compat hl hr =
      let c =
        compSpec2Type
          n
          m
          (compare
            n
            m)
      in
      (match c with
       | CompGtT ->
         compat
           n
           (max
             n
             m)
           __
           (hl
             __)
       | _ ->
         compat
           m
           (max
             n
             m)
           __
           (hr
             __))
    
    (** val max_case :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        'a1
        ->
        'a1
        ->
        'a1 **)
    
    let max_case n m x x0 x1 =
      max_case_strong
        n
        m
        x
        (fun _ ->
        x0)
        (fun _ ->
        x1)
    
    (** val max_dec :
        Big.big_int
        ->
        Big.big_int
        ->
        bool **)
    
    let max_dec n m =
      max_case
        n
        m
        (fun x y _ h0 ->
        h0)
        true
        false
    
    (** val min_case_strong :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        'a1 **)
    
    let min_case_strong n m compat hl hr =
      let c =
        compSpec2Type
          n
          m
          (compare
            n
            m)
      in
      (match c with
       | CompGtT ->
         compat
           m
           (min
             n
             m)
           __
           (hr
             __)
       | _ ->
         compat
           n
           (min
             n
             m)
           __
           (hl
             __))
    
    (** val min_case :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        'a1
        ->
        'a1
        ->
        'a1 **)
    
    let min_case n m x x0 x1 =
      min_case_strong
        n
        m
        x
        (fun _ ->
        x0)
        (fun _ ->
        x1)
    
    (** val min_dec :
        Big.big_int
        ->
        Big.big_int
        ->
        bool **)
    
    let min_dec n m =
      min_case
        n
        m
        (fun x y _ h0 ->
        h0)
        true
        false
   end
  
  (** val max_case_strong :
      Big.big_int
      ->
      Big.big_int
      ->
      (__
      ->
      'a1)
      ->
      (__
      ->
      'a1)
      ->
      'a1 **)
  
  let max_case_strong n m x x0 =
    Private_Dec.max_case_strong
      n
      m
      (fun x1 y _ x2 ->
      x2)
      x
      x0
  
  (** val max_case :
      Big.big_int
      ->
      Big.big_int
      ->
      'a1
      ->
      'a1
      ->
      'a1 **)
  
  let max_case n m x x0 =
    max_case_strong
      n
      m
      (fun _ ->
      x)
      (fun _ ->
      x0)
  
  (** val max_dec :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      Big.big_int
      ->
      Big.big_int
      ->
      (__
      ->
      'a1)
      ->
      (__
      ->
      'a1)
      ->
      'a1 **)
  
  let min_case_strong n m x x0 =
    Private_Dec.min_case_strong
      n
      m
      (fun x1 y _ x2 ->
      x2)
      x
      x0
  
  (** val min_case :
      Big.big_int
      ->
      Big.big_int
      ->
      'a1
      ->
      'a1
      ->
      'a1 **)
  
  let min_case n m x x0 =
    min_case_strong
      n
      m
      (fun _ ->
      x)
      (fun _ ->
      x0)
  
  (** val min_dec :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

module N = 
 struct 
  type t
    =
    Big.big_int
  
  (** val zero :
      Big.big_int **)
  
  let zero =
    Big.zero
  
  (** val one :
      Big.big_int **)
  
  let one =
    Big.one
  
  (** val two :
      Big.big_int **)
  
  let two =
    (Big.double
      Big.one)
  
  (** val succ_double :
      Big.big_int
      ->
      Big.big_int **)
  
  let succ_double x =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p ->
      (Big.doubleplusone
      p))
      x
  
  (** val double :
      Big.big_int
      ->
      Big.big_int **)
  
  let double n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Big.double
      p))
      n
  
  (** val succ :
      Big.big_int
      ->
      Big.big_int **)
  
  let succ = Big.succ
  
  (** val pred :
      Big.big_int
      ->
      Big.big_int **)
  
  let pred = fun n -> Big.max Big.zero (Big.pred n)
  
  (** val succ_pos :
      Big.big_int
      ->
      Big.big_int **)
  
  let succ_pos n =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p ->
      Coq_Pos.succ
        p)
      n
  
  (** val add :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let add = Big.add
  
  (** val sub :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let sub = fun n m -> Big.max Big.zero (Big.sub n m)
  
  (** val mul :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let mul = Big.mult
  
  (** val compare :
      Big.big_int
      ->
      Big.big_int
      ->
      comparison **)
  
  let compare = Big.compare_case Eq Lt Gt
  
  (** val eqb :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let rec eqb n m =
    Big.n_case
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p ->
        false)
        m)
      (fun p ->
      Big.n_case
        (fun _ ->
        false)
        (fun q ->
        Coq_Pos.eqb
          p
          q)
        m)
      n
  
  (** val leb :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let leb x y =
    match compare
            x
            y with
    | Gt ->
      false
    | _ ->
      true
  
  (** val ltb :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let ltb x y =
    match compare
            x
            y with
    | Lt ->
      true
    | _ ->
      false
  
  (** val min :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let min = Big.min
  
  (** val max :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let max = Big.max
  
  (** val div2 :
      Big.big_int
      ->
      Big.big_int **)
  
  let div2 n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p0 ->
      Big.positive_case
        (fun p ->
        p)
        (fun p ->
        p)
        (fun _ ->
        Big.zero)
        p0)
      n
  
  (** val even :
      Big.big_int
      ->
      bool **)
  
  let even n =
    Big.n_case
      (fun _ ->
      true)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        true)
        (fun _ ->
        false)
        p)
      n
  
  (** val odd :
      Big.big_int
      ->
      bool **)
  
  let odd n =
    negb
      (even
        n)
  
  (** val pow :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let pow n p =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p0 ->
      Big.n_case
        (fun _ ->
        Big.zero)
        (fun q ->
        (Coq_Pos.pow
          q
          p0))
        n)
      p
  
  (** val square :
      Big.big_int
      ->
      Big.big_int **)
  
  let square n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.square
        p))
      n
  
  (** val log2 :
      Big.big_int
      ->
      Big.big_int **)
  
  let log2 n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p0 ->
      Big.positive_case
        (fun p ->
        (Coq_Pos.size
          p))
        (fun p ->
        (Coq_Pos.size
          p))
        (fun _ ->
        Big.zero)
        p0)
      n
  
  (** val size :
      Big.big_int
      ->
      Big.big_int **)
  
  let size n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.size
        p))
      n
  
  (** val size_nat :
      Big.big_int
      ->
      Big.big_int **)
  
  let size_nat n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.size_nat
        p)
      n
  
  (** val pos_div_eucl :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int * Big.big_int **)
  
  let rec pos_div_eucl a b =
    Big.positive_case
      (fun a' ->
      let (q,
           r2) =
        pos_div_eucl
          a'
          b
      in
      let r' =
        succ_double
          r2
      in
      if leb
           b
           r'
      then ((succ_double
              q),
             (sub
               r'
               b))
      else ((double
              q),
             r'))
      (fun a' ->
      let (q,
           r2) =
        pos_div_eucl
          a'
          b
      in
      let r' =
        double
          r2
      in
      if leb
           b
           r'
      then ((succ_double
              q),
             (sub
               r'
               b))
      else ((double
              q),
             r'))
      (fun _ ->
      Big.n_case
        (fun _ ->
        (Big.zero,
        Big.one))
        (fun p ->
        Big.positive_case
          (fun p0 ->
          (Big.zero,
          Big.one))
          (fun p0 ->
          (Big.zero,
          Big.one))
          (fun _ ->
          (Big.one,
          Big.zero))
          p)
        b)
      a
  
  (** val div_eucl :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int * Big.big_int **)
  
  let div_eucl a b =
    Big.n_case
      (fun _ ->
      (Big.zero,
      Big.zero))
      (fun na ->
      Big.n_case
        (fun _ ->
        (Big.zero,
        a))
        (fun p ->
        pos_div_eucl
          na
          b)
        b)
      a
  
  (** val div :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let div = fun a b -> if Big.eq b Big.zero then Big.zero else Big.div a b
  
  (** val modulo :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let modulo = fun a b -> if Big.eq b Big.zero then Big.zero else Big.modulo a b
  
  (** val gcd :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let gcd a b =
    Big.n_case
      (fun _ ->
      b)
      (fun p ->
      Big.n_case
        (fun _ ->
        a)
        (fun q ->
        (Coq_Pos.gcd
          p
          q))
        b)
      a
  
  (** val ggcd :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    Big.n_case
      (fun _ ->
      (b,
      (Big.zero,
      Big.one)))
      (fun p ->
      Big.n_case
        (fun _ ->
        (a,
        (Big.one,
        Big.zero)))
        (fun q ->
        let (g,
             p0) =
          Coq_Pos.ggcd
            p
            q
        in
        let (aa,
             bb) =
          p0
        in
        (g,
        (aa,
        bb)))
        b)
      a
  
  (** val sqrtrem :
      Big.big_int
      ->
      Big.big_int * Big.big_int **)
  
  let sqrtrem n =
    Big.n_case
      (fun _ ->
      (Big.zero,
      Big.zero))
      (fun p ->
      let (s,
           m) =
        Coq_Pos.sqrtrem
          p
      in
      (match m with
       | Coq_Pos.IsPos r2 ->
         (s,
           r2)
       | _ ->
         (s,
           Big.zero)))
      n
  
  (** val sqrt :
      Big.big_int
      ->
      Big.big_int **)
  
  let sqrt n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.sqrt
        p))
      n
  
  (** val coq_lor :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let coq_lor n m =
    Big.n_case
      (fun _ ->
      m)
      (fun p ->
      Big.n_case
        (fun _ ->
        n)
        (fun q ->
        (Coq_Pos.coq_lor
          p
          q))
        m)
      n
  
  (** val coq_land :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let coq_land n m =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.n_case
        (fun _ ->
        Big.zero)
        (fun q ->
        Coq_Pos.coq_land
          p
          q)
        m)
      n
  
  (** val ldiff :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let rec ldiff n m =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.n_case
        (fun _ ->
        n)
        (fun q ->
        Coq_Pos.ldiff
          p
          q)
        m)
      n
  
  (** val coq_lxor :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let coq_lxor n m =
    Big.n_case
      (fun _ ->
      m)
      (fun p ->
      Big.n_case
        (fun _ ->
        n)
        (fun q ->
        Coq_Pos.coq_lxor
          p
          q)
        m)
      n
  
  (** val shiftl_nat :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftl_nat a n =
    nat_iter
      n
      double
      a
  
  (** val shiftr_nat :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftr_nat a n =
    nat_iter
      n
      div2
      a
  
  (** val shiftl :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftl a n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun a0 ->
      (Coq_Pos.shiftl
        a0
        n))
      a
  
  (** val shiftr :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let shiftr a n =
    Big.n_case
      (fun _ ->
      a)
      (fun p ->
      Coq_Pos.iter
        p
        div2
        a)
      n
  
  (** val testbit_nat :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let testbit_nat a =
    Big.n_case
      (fun _ x ->
      false)
      (fun p ->
      Coq_Pos.testbit_nat
        p)
      a
  
  (** val testbit :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let testbit a n =
    Big.n_case
      (fun _ ->
      false)
      (fun p ->
      Coq_Pos.testbit
        p
        n)
      a
  
  (** val to_nat :
      Big.big_int
      ->
      Big.big_int **)
  
  let to_nat a =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.to_nat
        p)
      a
  
  (** val of_nat :
      Big.big_int
      ->
      Big.big_int **)
  
  let of_nat n =
    Big.nat_case
      (fun _ ->
      Big.zero)
      (fun n' ->
      (Coq_Pos.of_succ_nat
        n'))
      n
  
  (** val iter :
      Big.big_int
      ->
      ('a1
      ->
      'a1)
      ->
      'a1
      ->
      'a1 **)
  
  let iter n f x =
    Big.n_case
      (fun _ ->
      x)
      (fun p ->
      Coq_Pos.iter
        p
        f
        x)
      n
  
  (** val eq_dec :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let eq_dec n m =
    Big.n_case
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p ->
        false)
        m)
      (fun x ->
      Big.n_case
        (fun _ ->
        false)
        (fun p0 ->
        Coq_Pos.eq_dec
          x
          p0)
        m)
      n
  
  (** val discr :
      Big.big_int
      ->
      Big.big_int
      option **)
  
  let discr n =
    Big.n_case
      (fun _ ->
      None)
      (fun p ->
      Some
      p)
      n
  
  (** val binary_rect :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let binary_rect f0 f2 fS2 n =
    let f2' =
      fun p ->
      f2
        p
    in
    let fS2' =
      fun p ->
      fS2
        p
    in
    (Big.n_case
       (fun _ ->
       f0)
       (fun p ->
       let rec f p0 =
         Big.positive_case
           (fun p1 ->
           fS2'
             p1
             (f
               p1))
           (fun p1 ->
           f2'
             p1
             (f
               p1))
           (fun _ ->
           fS2
             Big.zero
             f0)
           p0
       in f
            p)
       n)
  
  (** val binary_rec :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let binary_rec =
    binary_rect
  
  (** val peano_rect :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let peano_rect f0 f n =
    let f' =
      fun p ->
      f
        p
    in
    (Big.n_case
       (fun _ ->
       f0)
       (fun p ->
       Coq_Pos.peano_rect
         (f
           Big.zero
           f0)
         f'
         p)
       n)
  
  (** val peano_rec :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let peano_rec =
    peano_rect
  
  (** val leb_spec0 :
      Big.big_int
      ->
      Big.big_int
      ->
      reflect **)
  
  let leb_spec0 x y =
    iff_reflect
      (leb
        x
        y)
  
  (** val ltb_spec0 :
      Big.big_int
      ->
      Big.big_int
      ->
      reflect **)
  
  let ltb_spec0 x y =
    iff_reflect
      (ltb
        x
        y)
  
  module Private_BootStrap = 
   struct 
    
   end
  
  (** val recursion :
      'a1
      ->
      (Big.big_int
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      'a1 **)
  
  let recursion x =
    peano_rect
      x
  
  module Private_OrderTac = 
   struct 
    module Elts = 
     struct 
      type t
        =
        Big.big_int
     end
    
    module Tac = MakeOrderTac(Elts)
   end
  
  module Private_NZPow = 
   struct 
    
   end
  
  module Private_NZSqrt = 
   struct 
    
   end
  
  (** val sqrt_up :
      Big.big_int
      ->
      Big.big_int **)
  
  let sqrt_up a =
    match compare
            Big.zero
            a with
    | Lt ->
      succ
        (sqrt
          (pred
            a))
    | _ ->
      Big.zero
  
  (** val log2_up :
      Big.big_int
      ->
      Big.big_int **)
  
  let log2_up a =
    match compare
            Big.one
            a with
    | Lt ->
      succ
        (log2
          (pred
            a))
    | _ ->
      Big.zero
  
  module Private_NZDiv = 
   struct 
    
   end
  
  (** val lcm :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let lcm a b =
    mul
      a
      (div
        b
        (gcd
          a
          b))
  
  (** val eqb_spec :
      Big.big_int
      ->
      Big.big_int
      ->
      reflect **)
  
  let eqb_spec x y =
    iff_reflect
      (eqb
        x
        y)
  
  (** val b2n :
      bool
      ->
      Big.big_int **)
  
  let b2n = function
  | true ->
    Big.one
  | false ->
    Big.zero
  
  (** val setbit :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let setbit a n =
    coq_lor
      a
      (shiftl
        Big.one
        n)
  
  (** val clearbit :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let clearbit a n =
    ldiff
      a
      (shiftl
        Big.one
        n)
  
  (** val ones :
      Big.big_int
      ->
      Big.big_int **)
  
  let ones n =
    pred
      (shiftl
        Big.one
        n)
  
  (** val lnot :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let lnot a n =
    coq_lxor
      a
      (ones
        n)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Rev = 
   struct 
    module ORev = 
     struct 
      type t
        =
        Big.big_int
     end
    
    module MRev = 
     struct 
      (** val max :
          Big.big_int
          ->
          Big.big_int
          ->
          Big.big_int **)
      
      let max x y =
        min
          y
          x
     end
    
    module MPRev = MaxLogicalProperties(ORev)(MRev)
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        'a1 **)
    
    let max_case_strong n m compat hl hr =
      let c =
        compSpec2Type
          n
          m
          (compare
            n
            m)
      in
      (match c with
       | CompGtT ->
         compat
           n
           (max
             n
             m)
           __
           (hl
             __)
       | _ ->
         compat
           m
           (max
             n
             m)
           __
           (hr
             __))
    
    (** val max_case :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        'a1
        ->
        'a1
        ->
        'a1 **)
    
    let max_case n m x x0 x1 =
      max_case_strong
        n
        m
        x
        (fun _ ->
        x0)
        (fun _ ->
        x1)
    
    (** val max_dec :
        Big.big_int
        ->
        Big.big_int
        ->
        bool **)
    
    let max_dec n m =
      max_case
        n
        m
        (fun x y _ h0 ->
        h0)
        true
        false
    
    (** val min_case_strong :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        (__
        ->
        'a1)
        ->
        'a1 **)
    
    let min_case_strong n m compat hl hr =
      let c =
        compSpec2Type
          n
          m
          (compare
            n
            m)
      in
      (match c with
       | CompGtT ->
         compat
           m
           (min
             n
             m)
           __
           (hr
             __)
       | _ ->
         compat
           n
           (min
             n
             m)
           __
           (hl
             __))
    
    (** val min_case :
        Big.big_int
        ->
        Big.big_int
        ->
        (Big.big_int
        ->
        Big.big_int
        ->
        __
        ->
        'a1
        ->
        'a1)
        ->
        'a1
        ->
        'a1
        ->
        'a1 **)
    
    let min_case n m x x0 x1 =
      min_case_strong
        n
        m
        x
        (fun _ ->
        x0)
        (fun _ ->
        x1)
    
    (** val min_dec :
        Big.big_int
        ->
        Big.big_int
        ->
        bool **)
    
    let min_dec n m =
      min_case
        n
        m
        (fun x y _ h0 ->
        h0)
        true
        false
   end
  
  (** val max_case_strong :
      Big.big_int
      ->
      Big.big_int
      ->
      (__
      ->
      'a1)
      ->
      (__
      ->
      'a1)
      ->
      'a1 **)
  
  let max_case_strong n m x x0 =
    Private_Dec.max_case_strong
      n
      m
      (fun x1 y _ x2 ->
      x2)
      x
      x0
  
  (** val max_case :
      Big.big_int
      ->
      Big.big_int
      ->
      'a1
      ->
      'a1
      ->
      'a1 **)
  
  let max_case n m x x0 =
    max_case_strong
      n
      m
      (fun _ ->
      x)
      (fun _ ->
      x0)
  
  (** val max_dec :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      Big.big_int
      ->
      Big.big_int
      ->
      (__
      ->
      'a1)
      ->
      (__
      ->
      'a1)
      ->
      'a1 **)
  
  let min_case_strong n m x x0 =
    Private_Dec.min_case_strong
      n
      m
      (fun x1 y _ x2 ->
      x2)
      x
      x0
  
  (** val min_case :
      Big.big_int
      ->
      Big.big_int
      ->
      'a1
      ->
      'a1
      ->
      'a1 **)
  
  let min_case n m x x0 =
    min_case_strong
      n
      m
      (fun _ ->
      x)
      (fun _ ->
      x0)
  
  (** val min_dec :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

(** val nth :
    Big.big_int
    ->
    'a1
    list
    ->
    'a1
    ->
    'a1 **)

let rec nth n l default =
  Big.nat_case
    (fun _ ->
    match l with
    | [] ->
      default
    | x :: l' ->
      x)
    (fun m ->
    match l with
    | [] ->
      default
    | x :: t0 ->
      nth
        m
        t0
        default)
    n

(** val nth_error :
    'a1
    list
    ->
    Big.big_int
    ->
    'a1
    exc **)

let rec nth_error l n =
  Big.nat_case
    (fun _ ->
    match l with
    | [] ->
      error
    | x :: l0 ->
      value
        x)
    (fun n0 ->
    match l with
    | [] ->
      error
    | a :: l0 ->
      nth_error
        l0
        n0)
    n

(** val rev :
    'a1
    list
    ->
    'a1
    list **)

let rec rev = function
| [] ->
  []
| x :: l' ->
  app
    (rev
      l')
    (x :: [])

module Coq__1 = struct 
 (** val map :
     ('a1
     ->
     'a2)
     ->
     'a1
     list
     ->
     'a2
     list **)
 
 let rec map f = function
 | [] ->
   []
 | a :: t0 ->
   (f
     a) :: (map
             f
             t0)
end
let map = Coq__1.map


(** val fold_right :
    ('a2
    ->
    'a1
    ->
    'a1)
    ->
    'a1
    ->
    'a2
    list
    ->
    'a1 **)

let rec fold_right f a0 = function
| [] ->
  a0
| b :: t0 ->
  f
    b
    (fold_right
      f
      a0
      t0)

module Z = 
 struct 
  type t
    =
    Big.big_int
  
  (** val zero :
      Big.big_int **)
  
  let zero =
    Big.zero
  
  (** val one :
      Big.big_int **)
  
  let one =
    Big.one
  
  (** val two :
      Big.big_int **)
  
  let two =
    (Big.double Big.one)
  
  (** val double : Big.big_int -> Big.big_int **)
  
  let double x =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p -> (Big.double
      p))
      (fun p -> Big.opp (Big.double
      p))
      x
  
  (** val succ_double : Big.big_int -> Big.big_int **)
  
  let succ_double x =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p -> (Big.doubleplusone
      p))
      (fun p -> Big.opp
      (Coq_Pos.pred_double p))
      x
  
  (** val pred_double : Big.big_int -> Big.big_int **)
  
  let pred_double x =
    Big.z_case
      (fun _ -> Big.opp
      Big.one)
      (fun p ->
      (Coq_Pos.pred_double p))
      (fun p -> Big.opp (Big.doubleplusone
      p))
      x
  
  (** val pos_sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec pos_sub x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        double (pos_sub p q))
        (fun q ->
        succ_double (pos_sub p q))
        (fun _ -> (Big.double
        p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        pred_double (pos_sub p q))
        (fun q ->
        double (pos_sub p q))
        (fun _ ->
        (Coq_Pos.pred_double p))
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.opp (Big.double
        q))
        (fun q -> Big.opp
        (Coq_Pos.pred_double q))
        (fun _ ->
        Big.zero)
        y)
      x
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let add = Big.add
  
  (** val opp : Big.big_int -> Big.big_int **)
  
  let opp = Big.opp
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let succ = Big.succ
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred = Big.pred
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub = Big.sub
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let mul = Big.mult
  
  (** val pow_pos : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow_pos z n =
    Coq_Pos.iter n (mul z) Big.one
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow x y =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p ->
      pow_pos x p)
      (fun p ->
      Big.zero)
      y
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let square x =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.square p))
      (fun p ->
      (Coq_Pos.square p))
      x
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare = Big.compare_case Eq Lt Gt
  
  (** val sgn : Big.big_int -> Big.big_int **)
  
  let sgn z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.one)
      (fun p -> Big.opp
      Big.one)
      z
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val geb : Big.big_int -> Big.big_int -> bool **)
  
  let geb x y =
    match compare x y with
    | Lt -> false
    | _ -> true
  
  (** val gtb : Big.big_int -> Big.big_int -> bool **)
  
  let gtb x y =
    match compare x y with
    | Gt -> true
    | _ -> false
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb x y =
    Big.z_case
      (fun _ ->
      Big.z_case
        (fun _ ->
        true)
        (fun p ->
        false)
        (fun p ->
        false)
        y)
      (fun p ->
      Big.z_case
        (fun _ ->
        false)
        (fun q ->
        Coq_Pos.eqb p q)
        (fun p0 ->
        false)
        y)
      (fun p ->
      Big.z_case
        (fun _ ->
        false)
        (fun p0 ->
        false)
        (fun q ->
        Coq_Pos.eqb p q)
        y)
      x
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max = Big.max
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min = Big.min
  
  (** val abs : Big.big_int -> Big.big_int **)
  
  let abs = Big.abs
  
  (** val abs_nat : Big.big_int -> Big.big_int **)
  
  let abs_nat z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.to_nat p)
      (fun p ->
      Coq_Pos.to_nat p)
      z
  
  (** val abs_N : Big.big_int -> Big.big_int **)
  
  let abs_N = Big.abs
  
  (** val to_nat : Big.big_int -> Big.big_int **)
  
  let to_nat z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.to_nat p)
      (fun p ->
      Big.zero)
      z
  
  (** val to_N : Big.big_int -> Big.big_int **)
  
  let to_N z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      p)
      (fun p ->
      Big.zero)
      z
  
  (** val of_nat : Big.big_int -> Big.big_int **)
  
  let of_nat n =
    Big.nat_case
      (fun _ ->
      Big.zero)
      (fun n0 ->
      (Coq_Pos.of_succ_nat n0))
      n
  
  (** val of_N : Big.big_int -> Big.big_int **)
  
  let of_N = fun p -> p
  
  (** val to_pos : Big.big_int -> Big.big_int **)
  
  let to_pos z =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p ->
      p)
      (fun p ->
      Big.one)
      z
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let iter n f x =
    Big.z_case
      (fun _ ->
      x)
      (fun p ->
      Coq_Pos.iter p f x)
      (fun p ->
      x)
      n
  
  (** val pos_div_eucl :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let rec pos_div_eucl a b =
    Big.positive_case
      (fun a' ->
      let (q, r2) = pos_div_eucl a' b in
      let r' = add (mul (Big.double Big.one) r2) Big.one in
      if ltb r' b
      then ((mul (Big.double Big.one) q), r')
      else ((add (mul (Big.double Big.one) q) Big.one), (sub r' b)))
      (fun a' ->
      let (q, r2) = pos_div_eucl a' b in
      let r' = mul (Big.double Big.one) r2 in
      if ltb r' b
      then ((mul (Big.double Big.one) q), r')
      else ((add (mul (Big.double Big.one) q) Big.one), (sub r' b)))
      (fun _ ->
      if leb (Big.double Big.one) b
      then (Big.zero, Big.one)
      else (Big.one, Big.zero))
      a
  
  (** val div_eucl :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let div_eucl a b =
    Big.z_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun a' ->
      Big.z_case
        (fun _ -> (Big.zero,
        Big.zero))
        (fun p ->
        pos_div_eucl a' b)
        (fun b' ->
        let (q, r2) = pos_div_eucl a' b' in
        (Big.z_case
           (fun _ -> ((opp q),
           Big.zero))
           (fun p -> ((opp (add q Big.one)),
           (add b r2)))
           (fun p -> ((opp (add q Big.one)),
           (add b r2)))
           r2))
        b)
      (fun a' ->
      Big.z_case
        (fun _ -> (Big.zero,
        Big.zero))
        (fun p ->
        let (q, r2) = pos_div_eucl a' b in
        (Big.z_case
           (fun _ -> ((opp q),
           Big.zero))
           (fun p0 -> ((opp (add q Big.one)),
           (sub b r2)))
           (fun p0 -> ((opp (add q Big.one)),
           (sub b r2)))
           r2))
        (fun b' ->
        let (q, r2) = pos_div_eucl a' b' in (q, (opp r2)))
        b)
      a
  
  (** val div : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let div a b =
    let (q, x) = div_eucl a b in q
  
  (** val modulo : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let modulo a b =
    let (x, r2) = div_eucl a b in r2
  
  (** val quotrem :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let quotrem a b =
    Big.z_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun a0 ->
      Big.z_case
        (fun _ -> (Big.zero,
        a))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in ((of_N q), (of_N r2)))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in ((opp (of_N q)), (of_N r2)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ -> (Big.zero,
        a))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in
        ((opp (of_N q)), (opp (of_N r2))))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in ((of_N q), (opp (of_N r2))))
        b)
      a
  
  (** val quot : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let quot a b =
    fst (quotrem a b)
  
  (** val rem : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rem a b =
    snd (quotrem a b)
  
  (** val even : Big.big_int -> bool **)
  
  let even z =
    Big.z_case
      (fun _ ->
      true)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        true)
        (fun _ ->
        false)
        p)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        true)
        (fun _ ->
        false)
        p)
      z
  
  (** val odd : Big.big_int -> bool **)
  
  let odd z =
    Big.z_case
      (fun _ ->
      false)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        true)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        p)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        true)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        p)
      z
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun _ ->
        Big.zero)
        p)
      (fun p -> Big.opp
      (Coq_Pos.div2_up p))
      z
  
  (** val quot2 : Big.big_int -> Big.big_int **)
  
  let quot2 z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun _ ->
        Big.zero)
        p)
      (fun p ->
      Big.positive_case
        (fun p0 -> Big.opp
        (Coq_Pos.div2 p))
        (fun p0 -> Big.opp
        (Coq_Pos.div2 p))
        (fun _ ->
        Big.zero)
        p)
      z
  
  (** val log2 : Big.big_int -> Big.big_int **)
  
  let log2 z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p0 ->
      Big.positive_case
        (fun p ->
        (Coq_Pos.size p))
        (fun p ->
        (Coq_Pos.size p))
        (fun _ ->
        Big.zero)
        p0)
      (fun p ->
      Big.zero)
      z
  
  (** val sqrtrem : Big.big_int -> Big.big_int * Big.big_int **)
  
  let sqrtrem n =
    Big.z_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun p ->
      let (s, m) = Coq_Pos.sqrtrem p in
      (match m with
       | Coq_Pos.IsPos r2 -> (s, r2)
       | _ -> (s, Big.zero)))
      (fun p -> (Big.zero,
      Big.zero))
      n
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt n =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.sqrt p))
      (fun p ->
      Big.zero)
      n
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    Big.z_case
      (fun _ ->
      abs b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        abs a)
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        abs a)
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        b)
      a
  
  (** val ggcd :
      Big.big_int -> Big.big_int -> Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    Big.z_case
      (fun _ -> ((abs b), (Big.zero,
      (sgn b))))
      (fun a0 ->
      Big.z_case
        (fun _ -> ((abs a), ((sgn a),
        Big.zero)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in let (aa, bb) = p in (g, (aa, bb)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in
        let (aa, bb) = p in (g, (aa, (Big.opp bb))))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ -> ((abs a), ((sgn a),
        Big.zero)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in
        let (aa, bb) = p in (g, ((Big.opp aa), bb)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in
        let (aa, bb) = p in (g, ((Big.opp aa), (Big.opp bb))))
        b)
      a
  
  (** val testbit : Big.big_int -> Big.big_int -> bool **)
  
  let testbit a n =
    Big.z_case
      (fun _ ->
      odd a)
      (fun p ->
      Big.z_case
        (fun _ ->
        false)
        (fun a0 ->
        Coq_Pos.testbit a0 p)
        (fun a0 ->
        negb (N.testbit (Coq_Pos.pred_N a0) p))
        a)
      (fun p ->
      false)
      n
  
  (** val shiftl : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl a n =
    Big.z_case
      (fun _ ->
      a)
      (fun p ->
      Coq_Pos.iter p (mul (Big.double Big.one)) a)
      (fun p ->
      Coq_Pos.iter p div2 a)
      n
  
  (** val shiftr : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr a n =
    shiftl a (opp n)
  
  (** val coq_lor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_lor a b =
    Big.z_case
      (fun _ ->
      b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 ->
        (Coq_Pos.coq_lor a0 b0))
        (fun b0 -> Big.opp
        (N.succ_pos (N.ldiff (Coq_Pos.pred_N b0) a0)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 -> Big.opp
        (N.succ_pos (N.ldiff (Coq_Pos.pred_N a0) b0)))
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_land (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
        b)
      a
  
  (** val coq_land : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_land a b =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        Big.zero)
        (fun b0 ->
        of_N (Coq_Pos.coq_land a0 b0))
        (fun b0 ->
        of_N (N.ldiff a0 (Coq_Pos.pred_N b0)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        Big.zero)
        (fun b0 ->
        of_N (N.ldiff b0 (Coq_Pos.pred_N a0)))
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
        b)
      a
  
  (** val ldiff : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let ldiff a b =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 ->
        of_N (Coq_Pos.ldiff a0 b0))
        (fun b0 ->
        of_N (N.coq_land a0 (Coq_Pos.pred_N b0)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) b0)))
        (fun b0 ->
        of_N (N.ldiff (Coq_Pos.pred_N b0) (Coq_Pos.pred_N a0)))
        b)
      a
  
  (** val coq_lxor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_lxor a b =
    Big.z_case
      (fun _ ->
      b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 ->
        of_N (Coq_Pos.coq_lxor a0 b0))
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lxor a0 (Coq_Pos.pred_N b0))))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lxor (Coq_Pos.pred_N a0) b0)))
        (fun b0 ->
        of_N (N.coq_lxor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0)))
        b)
      a
  
  (** val eq_dec : Big.big_int -> Big.big_int -> bool **)
  
  let eq_dec x y =
    Big.z_case
      (fun _ ->
      Big.z_case
        (fun _ ->
        true)
        (fun p ->
        false)
        (fun p ->
        false)
        y)
      (fun x0 ->
      Big.z_case
        (fun _ ->
        false)
        (fun p0 ->
        Coq_Pos.eq_dec x0 p0)
        (fun p0 ->
        false)
        y)
      (fun x0 ->
      Big.z_case
        (fun _ ->
        false)
        (fun p0 ->
        false)
        (fun p0 ->
        Coq_Pos.eq_dec x0 p0)
        y)
      x
  
  module Private_BootStrap = 
   struct 
    
   end
  
  (** val leb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_OrderTac = 
   struct 
    module Elts = 
     struct 
      type t = Big.big_int
     end
    
    module Tac = MakeOrderTac(Elts)
   end
  
  (** val sqrt_up : Big.big_int -> Big.big_int **)
  
  let sqrt_up a =
    match compare Big.zero a with
    | Lt -> succ (sqrt (pred a))
    | _ -> Big.zero
  
  (** val log2_up : Big.big_int -> Big.big_int **)
  
  let log2_up a =
    match compare Big.one a with
    | Lt -> succ (log2 (pred a))
    | _ -> Big.zero
  
  module Private_NZDiv = 
   struct 
    
   end
  
  module Private_Div = 
   struct 
    module Quot2Div = 
     struct 
      (** val div : Big.big_int -> Big.big_int -> Big.big_int **)
      
      let div =
        quot
      
      (** val modulo : Big.big_int -> Big.big_int -> Big.big_int **)
      
      let modulo =
        rem
     end
    
    module NZQuot = 
     struct 
      
     end
   end
  
  (** val lcm : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let lcm a b =
    abs (mul a (div b (gcd a b)))
  
  (** val eqb_spec : Big.big_int -> Big.big_int -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val b2z : bool -> Big.big_int **)
  
  let b2z = function
  | true -> Big.one
  | false -> Big.zero
  
  (** val setbit : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let setbit a n =
    coq_lor a (shiftl Big.one n)
  
  (** val clearbit : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let clearbit a n =
    ldiff a (shiftl Big.one n)
  
  (** val lnot : Big.big_int -> Big.big_int **)
  
  let lnot a =
    pred (opp a)
  
  (** val ones : Big.big_int -> Big.big_int **)
  
  let ones n =
    pred (shiftl Big.one n)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Rev = 
   struct 
    module ORev = 
     struct 
      type t = Big.big_int
     end
    
    module MRev = 
     struct 
      (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
      
      let max x y =
        min y x
     end
    
    module MPRev = MaxLogicalProperties(ORev)(MRev)
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let max_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat n (max n m) __ (hl __)
       | _ -> compat m (max n m) __ (hr __))
    
    (** val max_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let max_case n m x x0 x1 =
      max_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : Big.big_int -> Big.big_int -> bool **)
    
    let max_dec n m =
      max_case n m (fun x y _ h0 -> h0) true false
    
    (** val min_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let min_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat m (min n m) __ (hr __)
       | _ -> compat n (min n m) __ (hl __))
    
    (** val min_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let min_case n m x x0 x1 =
      min_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : Big.big_int -> Big.big_int -> bool **)
    
    let min_dec n m =
      min_case n m (fun x y _ h0 -> h0) true false
   end
  
  (** val max_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n m x x0 =
    Private_Dec.max_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n m x x0 =
    max_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : Big.big_int -> Big.big_int -> bool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n m x x0 =
    Private_Dec.min_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n m x x0 =
    min_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : Big.big_int -> Big.big_int -> bool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

(** val z_lt_dec : Big.big_int -> Big.big_int -> bool **)

let z_lt_dec x y =
  match Z.compare x y with
  | Lt -> true
  | _ -> false

(** val z_le_dec : Big.big_int -> Big.big_int -> bool **)

let z_le_dec x y =
  match Z.compare x y with
  | Gt -> false
  | _ -> true

(** val z_lt_ge_dec : Big.big_int -> Big.big_int -> bool **)

let z_lt_ge_dec x y =
  z_lt_dec x y

(** val z_le_gt_dec : Big.big_int -> Big.big_int -> bool **)

let z_le_gt_dec x y =
  z_le_dec x y

(** val zeq_bool : Big.big_int -> Big.big_int -> bool **)

let zeq_bool x y =
  match Z.compare x y with
  | Eq -> true
  | _ -> false

(** val append : char list -> char list -> char list **)

let rec append s1 s2 =
  match s1 with
  | [] -> s2
  | c::s1' -> c::(append s1' s2)

(** val length0 : char list -> Big.big_int **)

let rec length0 = function
| [] -> Big.zero
| c::s' -> Big.succ (length0 s')

(** val shift_nat : Big.big_int -> Big.big_int -> Big.big_int **)

let shift_nat n z =
  nat_iter n (fun x -> Big.double x) z

(** val shift_pos : Big.big_int -> Big.big_int -> Big.big_int **)

let shift_pos n z =
  Coq_Pos.iter n (fun x -> Big.double x) z

(** val two_power_nat : Big.big_int -> Big.big_int **)

let two_power_nat n =
  (shift_nat n Big.one)

(** val two_power_pos : Big.big_int -> Big.big_int **)

let two_power_pos x =
  (shift_pos x Big.one)

(** val two_p : Big.big_int -> Big.big_int **)

let two_p x =
  Big.z_case
    (fun _ ->
    Big.one)
    (fun y ->
    two_power_pos y)
    (fun y ->
    Big.zero)
    x

(** val peq : Big.big_int -> Big.big_int -> bool **)

let peq x y =
  match Coq_Pos.compare_cont x y Eq with
  | Eq -> true
  | _ -> false

(** val zeq : Big.big_int -> Big.big_int -> bool **)

let zeq =
  Z.eq_dec

(** val zlt : Big.big_int -> Big.big_int -> bool **)

let zlt =
  z_lt_ge_dec

(** val zle : Big.big_int -> Big.big_int -> bool **)

let zle =
  z_le_gt_dec

(** val option_map : ('a1 -> 'a2) -> 'a1 option -> 'a2 option **)

let option_map f = function
| Some y -> Some (f y)
| None -> None

(** val proj_sumbool : bool -> bool **)

let proj_sumbool = function
| true -> true
| false -> false

module Word = 
 struct 
  (** val wordsize : Big.big_int -> Big.big_int **)
  
  let wordsize wordsize_minus_one =
    Big.succ wordsize_minus_one
  
  (** val modulus : Big.big_int -> Big.big_int **)
  
  let modulus wordsize_minus_one =
    two_power_nat (wordsize wordsize_minus_one)
  
  (** val half_modulus : Big.big_int -> Big.big_int **)
  
  let half_modulus wordsize_minus_one =
    Z.div (modulus wordsize_minus_one) (Big.double Big.one)
  
  type comparison =
  | Ceq
  | Cne
  | Clt
  | Cle
  | Cgt
  | Cge
  
  (** val comparison_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> comparison -> 'a1 **)
  
  let comparison_rect f f0 f1 f2 f3 f4 = function
  | Ceq -> f
  | Cne -> f0
  | Clt -> f1
  | Cle -> f2
  | Cgt -> f3
  | Cge -> f4
  
  (** val comparison_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> comparison -> 'a1 **)
  
  let comparison_rec f f0 f1 f2 f3 f4 = function
  | Ceq -> f
  | Cne -> f0
  | Clt -> f1
  | Cle -> f2
  | Cgt -> f3
  | Cge -> f4
  
  (** val negate_comparison : comparison -> comparison **)
  
  let negate_comparison = function
  | Ceq -> Cne
  | Cne -> Ceq
  | Clt -> Cge
  | Cle -> Cgt
  | Cgt -> Cle
  | Cge -> Clt
  
  (** val swap_comparison : comparison -> comparison **)
  
  let swap_comparison = function
  | Clt -> Cgt
  | Cle -> Cge
  | Cgt -> Clt
  | Cge -> Cle
  | x -> x
  
  type int =
    Big.big_int
    (* singleton inductive, whose constructor was mkint *)
  
  (** val int_rect :
      Big.big_int -> (Big.big_int -> __ -> 'a1) -> int -> 'a1 **)
  
  let int_rect wordsize_minus_one f i =
    f i __
  
  (** val int_rec :
      Big.big_int -> (Big.big_int -> __ -> 'a1) -> int -> 'a1 **)
  
  let int_rec wordsize_minus_one f i =
    f i __
  
  (** val intval : Big.big_int -> int -> Big.big_int **)
  
  let intval wordsize_minus_one i =
    i
  
  (** val max_unsigned : Big.big_int -> Big.big_int **)
  
  let max_unsigned wordsize_minus_one =
    Z.sub (modulus wordsize_minus_one) Big.one
  
  (** val max_signed : Big.big_int -> Big.big_int **)
  
  let max_signed wordsize_minus_one =
    Z.sub (half_modulus wordsize_minus_one) Big.one
  
  (** val min_signed : Big.big_int -> Big.big_int **)
  
  let min_signed wordsize_minus_one =
    Z.opp (half_modulus wordsize_minus_one)
  
  (** val unsigned : Big.big_int -> int -> Big.big_int **)
  
  let unsigned wordsize_minus_one n =
    intval wordsize_minus_one n
  
  (** val signed : Big.big_int -> int -> Big.big_int **)
  
  let signed wordsize_minus_one n =
    if zlt (unsigned wordsize_minus_one n) (half_modulus wordsize_minus_one)
    then unsigned wordsize_minus_one n
    else Z.sub (unsigned wordsize_minus_one n) (modulus wordsize_minus_one)
  
  (** val repr : Big.big_int -> Big.big_int -> int **)
  
  let repr wordsize_minus_one x =
    Z.modulo x (modulus wordsize_minus_one)
  
  (** val zero : Big.big_int -> int **)
  
  let zero wordsize_minus_one =
    repr wordsize_minus_one Big.zero
  
  (** val one : Big.big_int -> int **)
  
  let one wordsize_minus_one =
    repr wordsize_minus_one Big.one
  
  (** val mone : Big.big_int -> int **)
  
  let mone wordsize_minus_one =
    repr wordsize_minus_one (Big.opp Big.one)
  
  (** val eq_dec : Big.big_int -> int -> int -> bool **)
  
  let eq_dec wordsize_minus_one x y =
    zeq x y
  
  (** val eq : Big.big_int -> int -> int -> bool **)
  
  let eq wordsize_minus_one x y =
    if zeq (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y)
    then true
    else false
  
  (** val lt : Big.big_int -> int -> int -> bool **)
  
  let lt wordsize_minus_one x y =
    if zlt (signed wordsize_minus_one x) (signed wordsize_minus_one y)
    then true
    else false
  
  (** val ltu : Big.big_int -> int -> int -> bool **)
  
  let ltu wordsize_minus_one x y =
    if zlt (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y)
    then true
    else false
  
  (** val lequ : Big.big_int -> int -> int -> bool **)
  
  let lequ wordsize_minus_one x y =
    (||) (ltu wordsize_minus_one x y) (eq wordsize_minus_one x y)
  
  (** val neg : Big.big_int -> int -> int **)
  
  let neg wordsize_minus_one x =
    repr wordsize_minus_one (Z.opp (unsigned wordsize_minus_one x))
  
  (** val zero_ext : Big.big_int -> Big.big_int -> int -> int **)
  
  let zero_ext wordsize_minus_one n x =
    repr wordsize_minus_one
      (Z.modulo (unsigned wordsize_minus_one x) (two_p n))
  
  (** val sign_ext : Big.big_int -> Big.big_int -> int -> int **)
  
  let sign_ext wordsize_minus_one n x =
    repr wordsize_minus_one
      (let p = two_p n in
       let y = Z.modulo (unsigned wordsize_minus_one x) p in
       if zlt y (two_p (Z.sub n Big.one)) then y else Z.sub y p)
  
  (** val add : Big.big_int -> int -> int -> int **)
  
  let add wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.add (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val sub : Big.big_int -> int -> int -> int **)
  
  let sub wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.sub (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val mul : Big.big_int -> int -> int -> int **)
  
  let mul wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.mul (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val coq_Zdiv_round : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_Zdiv_round x y =
    if zlt x Big.zero
    then if zlt y Big.zero
         then Z.div (Z.opp x) (Z.opp y)
         else Z.opp (Z.div (Z.opp x) y)
    else if zlt y Big.zero then Z.opp (Z.div x (Z.opp y)) else Z.div x y
  
  (** val coq_Zmod_round : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_Zmod_round x y =
    Z.sub x (Z.mul (coq_Zdiv_round x y) y)
  
  (** val divs : Big.big_int -> int -> int -> int **)
  
  let divs wordsize_minus_one x y =
    repr wordsize_minus_one
      (coq_Zdiv_round (signed wordsize_minus_one x)
        (signed wordsize_minus_one y))
  
  (** val mods : Big.big_int -> int -> int -> int **)
  
  let mods wordsize_minus_one x y =
    repr wordsize_minus_one
      (coq_Zmod_round (signed wordsize_minus_one x)
        (signed wordsize_minus_one y))
  
  (** val divu : Big.big_int -> int -> int -> int **)
  
  let divu wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.div (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val modu : Big.big_int -> int -> int -> int **)
  
  let modu wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.modulo (unsigned wordsize_minus_one x)
        (unsigned wordsize_minus_one y))
  
  (** val bool_to_int : Big.big_int -> bool -> int **)
  
  let bool_to_int wordsize_minus_one = function
  | true -> one wordsize_minus_one
  | false -> zero wordsize_minus_one
  
  (** val unsigned_overflow :
      Big.big_int -> Big.big_int -> Big.big_int -> bool **)
  
  let unsigned_overflow wordsize_minus_one o1 o2 =
    let res = Z.add o1 o2 in
    if zlt res (modulus wordsize_minus_one) then false else true
  
  (** val unsigned_overflow_with_carry :
      Big.big_int -> Big.big_int -> Big.big_int -> bool -> bool **)
  
  let unsigned_overflow_with_carry wordsize_minus_one o1 o2 carry =
    let c =
      bool_to_int
        wordsize_minus_one
        carry
    in
    let res =
      Z.add
        (Z.add
          o1
          o2)
        (unsigned
          wordsize_minus_one
          c)
    in
    if zle
         res
         (max_unsigned
           wordsize_minus_one)
    then false
    else true
  
  (** val signed_overflow :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let signed_overflow wordsize_minus_one o1 o2 =
    let res =
      Z.add
        o1
        o2
    in
    if (&&)
         (proj_sumbool
           (zle
             res
             (max_signed
               wordsize_minus_one)))
         (proj_sumbool
           (zle
             (min_signed
               wordsize_minus_one)
             res))
    then false
    else true
  
  (** val signed_overflow_with_carry :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      bool
      ->
      bool **)
  
  let signed_overflow_with_carry wordsize_minus_one o1 o2 carry =
    let c =
      bool_to_int
        wordsize_minus_one
        carry
    in
    let res =
      Z.add
        (Z.add
          o1
          o2)
        (signed
          wordsize_minus_one
          c)
    in
    if (&&)
         (proj_sumbool
           (zle
             res
             (max_signed
               wordsize_minus_one)))
         (proj_sumbool
           (zle
             (min_signed
               wordsize_minus_one)
             res))
    then false
    else true
  
  (** val signed_overflow_with_borrow :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      bool
      ->
      bool **)
  
  let signed_overflow_with_borrow wordsize_minus_one o1 o2 borrow =
    let b =
      bool_to_int
        wordsize_minus_one
        borrow
    in
    let res =
      Z.sub
        (Z.add
          o1
          o2)
        (signed
          wordsize_minus_one
          b)
    in
    if (&&)
         (proj_sumbool
           (zle
             res
             (max_signed
               wordsize_minus_one)))
         (proj_sumbool
           (zle
             (min_signed
               wordsize_minus_one)
             res))
    then false
    else true
  
  (** val is_zero :
      Big.big_int
      ->
      int
      ->
      bool **)
  
  let is_zero wordsize_minus_one i =
    eq
      wordsize_minus_one
      i
      (zero
        wordsize_minus_one)
  
  (** val is_signed :
      Big.big_int
      ->
      int
      ->
      bool **)
  
  let is_signed wordsize_minus_one i =
    lt
      wordsize_minus_one
      i
      (zero
        wordsize_minus_one)
  
  (** val coq_Z_shift_add :
      bool
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let coq_Z_shift_add b x =
    if b
    then Z.add
           (Z.mul
             (Big.double
             Big.one)
             x)
           Big.one
    else Z.mul
           (Big.double
           Big.one)
           x
  
  (** val coq_Z_bin_decomp :
      Big.big_int
      ->
      bool * Big.big_int **)
  
  let coq_Z_bin_decomp x =
    Big.z_case
      (fun _ ->
      (false,
      Big.zero))
      (fun p ->
      Big.positive_case
        (fun q ->
        (true,
        q))
        (fun q ->
        (false,
        q))
        (fun _ ->
        (true,
        Big.zero))
        p)
      (fun p ->
      Big.positive_case
        (fun q ->
        (true,
        (Z.sub
          (Big.opp
          q)
          Big.one)))
        (fun q ->
        (false,
        (Big.opp
        q)))
        (fun _ ->
        (true,
        (Big.opp
        Big.one)))
        p)
      x
  
  (** val bits_of_Z :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let rec bits_of_Z n x =
    Big.nat_case
      (fun _ i ->
      false)
      (fun m ->
      let (b,
           y) =
        coq_Z_bin_decomp
          x
      in
      let f =
        bits_of_Z
          m
          y
      in
      (fun i ->
      if zeq
           i
           Big.zero
      then b
      else f
             (Z.sub
               i
               Big.one)))
      n
  
  (** val coq_Z_of_bits :
      Big.big_int
      ->
      (Big.big_int
      ->
      bool)
      ->
      Big.big_int **)
  
  let rec coq_Z_of_bits n f =
    Big.nat_case
      (fun _ ->
      Big.zero)
      (fun m ->
      coq_Z_shift_add
        (f
          Big.zero)
        (coq_Z_of_bits
          m
          (fun i ->
          f
            (Z.add
              i
              Big.one))))
      n
  
  (** val bitwise_binop :
      Big.big_int
      ->
      (bool
      ->
      bool
      ->
      bool)
      ->
      int
      ->
      int
      ->
      int **)
  
  let bitwise_binop wordsize_minus_one f x y =
    let fx =
      bits_of_Z
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          x)
    in
    let fy =
      bits_of_Z
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          y)
    in
    repr
      wordsize_minus_one
      (coq_Z_of_bits
        (wordsize
          wordsize_minus_one)
        (fun i ->
        f
          (fx
            i)
          (fy
            i)))
  
  (** val coq_and :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let coq_and wordsize_minus_one x y =
    bitwise_binop
      wordsize_minus_one
      (&&)
      x
      y
  
  (** val coq_or :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let coq_or wordsize_minus_one x y =
    bitwise_binop
      wordsize_minus_one
      (||)
      x
      y
  
  (** val xor :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let xor wordsize_minus_one x y =
    bitwise_binop
      wordsize_minus_one
      xorb
      x
      y
  
  (** val not :
      Big.big_int
      ->
      int
      ->
      int **)
  
  let not wordsize_minus_one x =
    xor
      wordsize_minus_one
      x
      (mone
        wordsize_minus_one)
  
  (** val shl :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let shl wordsize_minus_one x y =
    let fx =
      bits_of_Z
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          x)
    in
    let vy =
      unsigned
        wordsize_minus_one
        y
    in
    repr
      wordsize_minus_one
      (coq_Z_of_bits
        (wordsize
          wordsize_minus_one)
        (fun i ->
        fx
          (Z.sub
            i
            vy)))
  
  (** val shru :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let shru wordsize_minus_one x y =
    let fx =
      bits_of_Z
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          x)
    in
    let vy =
      unsigned
        wordsize_minus_one
        y
    in
    repr
      wordsize_minus_one
      (coq_Z_of_bits
        (wordsize
          wordsize_minus_one)
        (fun i ->
        fx
          (Z.add
            i
            vy)))
  
  (** val shr :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let shr wordsize_minus_one x y =
    repr
      wordsize_minus_one
      (Z.div
        (signed
          wordsize_minus_one
          x)
        (two_p
          (unsigned
            wordsize_minus_one
            y)))
  
  (** val shrx :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let shrx wordsize_minus_one x y =
    divs
      wordsize_minus_one
      x
      (shl
        wordsize_minus_one
        (one
          wordsize_minus_one)
        y)
  
  (** val shr_carry :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let shr_carry wordsize_minus_one x y =
    sub
      wordsize_minus_one
      (shrx
        wordsize_minus_one
        x
        y)
      (shr
        wordsize_minus_one
        x
        y)
  
  (** val rol :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let rol wordsize_minus_one x y =
    let fx =
      bits_of_Z
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          x)
    in
    let vy =
      unsigned
        wordsize_minus_one
        y
    in
    repr
      wordsize_minus_one
      (coq_Z_of_bits
        (wordsize
          wordsize_minus_one)
        (fun i ->
        fx
          (Z.modulo
            (Z.sub
              i
              vy)
            (Z.of_nat
              (wordsize
                wordsize_minus_one)))))
  
  (** val ror :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int **)
  
  let ror wordsize_minus_one x y =
    let fx =
      bits_of_Z
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          x)
    in
    let vy =
      unsigned
        wordsize_minus_one
        y
    in
    repr
      wordsize_minus_one
      (coq_Z_of_bits
        (wordsize
          wordsize_minus_one)
        (fun i ->
        fx
          (Z.modulo
            (Z.add
              i
              vy)
            (Z.of_nat
              (wordsize
                wordsize_minus_one)))))
  
  (** val rolm :
      Big.big_int
      ->
      int
      ->
      int
      ->
      int
      ->
      int **)
  
  let rolm wordsize_minus_one x a m =
    coq_and
      wordsize_minus_one
      (rol
        wordsize_minus_one
        x
        a)
      m
  
  (** val coq_Z_one_bits :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      list **)
  
  let rec coq_Z_one_bits n x i =
    Big.nat_case
      (fun _ ->
      [])
      (fun m ->
      let (b,
           y) =
        coq_Z_bin_decomp
          x
      in
      if b
      then i :: (coq_Z_one_bits
                  m
                  y
                  (Z.add
                    i
                    Big.one))
      else coq_Z_one_bits
             m
             y
             (Z.add
               i
               Big.one))
      n
  
  (** val one_bits :
      Big.big_int
      ->
      int
      ->
      int
      list **)
  
  let one_bits wordsize_minus_one x =
    map
      (repr
        wordsize_minus_one)
      (coq_Z_one_bits
        (wordsize
          wordsize_minus_one)
        (unsigned
          wordsize_minus_one
          x)
        Big.zero)
  
  (** val is_power2 :
      Big.big_int
      ->
      int
      ->
      int
      option **)
  
  let is_power2 wordsize_minus_one x =
    match coq_Z_one_bits
            (wordsize
              wordsize_minus_one)
            (unsigned
              wordsize_minus_one
              x)
            Big.zero with
    | [] ->
      None
    | i :: l ->
      (match l with
       | [] ->
         Some
           (repr
             wordsize_minus_one
             i)
       | z :: l0 ->
         None)
  
  type rlw_state =
  | RLW_S0
  | RLW_S1
  | RLW_S2
  | RLW_S3
  | RLW_S4
  | RLW_S5
  | RLW_S6
  | RLW_Sbad
  
  (** val rlw_state_rect :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      rlw_state
      ->
      'a1 **)
  
  let rlw_state_rect f f0 f1 f2 f3 f4 f5 f6 = function
  | RLW_S0 ->
    f
  | RLW_S1 ->
    f0
  | RLW_S2 ->
    f1
  | RLW_S3 ->
    f2
  | RLW_S4 ->
    f3
  | RLW_S5 ->
    f4
  | RLW_S6 ->
    f5
  | RLW_Sbad ->
    f6
  
  (** val rlw_state_rec :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      rlw_state
      ->
      'a1 **)
  
  let rlw_state_rec f f0 f1 f2 f3 f4 f5 f6 = function
  | RLW_S0 ->
    f
  | RLW_S1 ->
    f0
  | RLW_S2 ->
    f1
  | RLW_S3 ->
    f2
  | RLW_S4 ->
    f3
  | RLW_S5 ->
    f4
  | RLW_S6 ->
    f5
  | RLW_Sbad ->
    f6
  
  (** val rlw_transition :
      rlw_state
      ->
      bool
      ->
      rlw_state **)
  
  let rlw_transition s b =
    match s with
    | RLW_S0 ->
      if b
      then RLW_S4
      else RLW_S1
    | RLW_S1 ->
      if b
      then RLW_S2
      else RLW_S1
    | RLW_S2 ->
      if b
      then RLW_S2
      else RLW_S3
    | RLW_S3 ->
      if b
      then RLW_Sbad
      else RLW_S3
    | RLW_S4 ->
      if b
      then RLW_S4
      else RLW_S5
    | RLW_S5 ->
      if b
      then RLW_S6
      else RLW_S5
    | RLW_S6 ->
      if b
      then RLW_S6
      else RLW_Sbad
    | RLW_Sbad ->
      RLW_Sbad
  
  (** val rlw_accepting :
      rlw_state
      ->
      bool **)
  
  let rlw_accepting = function
  | RLW_S0 ->
    false
  | RLW_S1 ->
    false
  | RLW_Sbad ->
    false
  | _ ->
    true
  
  (** val is_rlw_mask_rec :
      Big.big_int
      ->
      rlw_state
      ->
      Big.big_int
      ->
      bool **)
  
  let rec is_rlw_mask_rec n s x =
    Big.nat_case
      (fun _ ->
      rlw_accepting
        s)
      (fun m ->
      let (b,
           y) =
        coq_Z_bin_decomp
          x
      in
      is_rlw_mask_rec
        m
        (rlw_transition
          s
          b)
        y)
      n
  
  (** val is_rlw_mask :
      Big.big_int
      ->
      int
      ->
      bool **)
  
  let is_rlw_mask wordsize_minus_one x =
    is_rlw_mask_rec
      (wordsize
        wordsize_minus_one)
      RLW_S0
      (unsigned
        wordsize_minus_one
        x)
  
  (** val cmp :
      Big.big_int
      ->
      comparison
      ->
      int
      ->
      int
      ->
      bool **)
  
  let cmp wordsize_minus_one c x y =
    match c with
    | Ceq ->
      eq
        wordsize_minus_one
        x
        y
    | Cne ->
      negb
        (eq
          wordsize_minus_one
          x
          y)
    | Clt ->
      lt
        wordsize_minus_one
        x
        y
    | Cle ->
      negb
        (lt
          wordsize_minus_one
          y
          x)
    | Cgt ->
      lt
        wordsize_minus_one
        y
        x
    | Cge ->
      negb
        (lt
          wordsize_minus_one
          x
          y)
  
  (** val cmpu :
      Big.big_int
      ->
      comparison
      ->
      int
      ->
      int
      ->
      bool **)
  
  let cmpu wordsize_minus_one c x y =
    match c with
    | Ceq ->
      eq
        wordsize_minus_one
        x
        y
    | Cne ->
      negb
        (eq
          wordsize_minus_one
          x
          y)
    | Clt ->
      ltu
        wordsize_minus_one
        x
        y
    | Cle ->
      negb
        (ltu
          wordsize_minus_one
          y
          x)
    | Cgt ->
      ltu
        wordsize_minus_one
        y
        x
    | Cge ->
      negb
        (ltu
          wordsize_minus_one
          x
          y)
  
  (** val notbool :
      Big.big_int
      ->
      int
      ->
      int **)
  
  let notbool wordsize_minus_one x =
    if eq
         wordsize_minus_one
         x
         (zero
           wordsize_minus_one)
    then one
           wordsize_minus_one
    else zero
           wordsize_minus_one
  
  (** val check_equal_on_range :
      Big.big_int
      ->
      (int
      ->
      int)
      ->
      (int
      ->
      int)
      ->
      Big.big_int
      ->
      bool **)
  
  let rec check_equal_on_range wordsize_minus_one f g n =
    Big.nat_case
      (fun _ ->
      true)
      (fun n0 ->
      if eq
           wordsize_minus_one
           (f
             (repr
               wordsize_minus_one
               (Z.of_nat
                 n0)))
           (g
             (repr
               wordsize_minus_one
               (Z.of_nat
                 n0)))
      then check_equal_on_range
             wordsize_minus_one
             f
             g
             n0
      else false)
      n
  
  (** val powerserie :
      Big.big_int
      list
      ->
      Big.big_int **)
  
  let rec powerserie = function
  | [] ->
    Big.zero
  | x :: xs ->
    Z.add
      (two_p
        x)
      (powerserie
        xs)
  
  (** val int_of_one_bits :
      Big.big_int
      ->
      int
      list
      ->
      int **)
  
  let rec int_of_one_bits wordsize_minus_one = function
  | [] ->
    zero
      wordsize_minus_one
  | a :: b ->
    add
      wordsize_minus_one
      (shl
        wordsize_minus_one
        (one
          wordsize_minus_one)
        a)
      (int_of_one_bits
        wordsize_minus_one
        b)
  
  (** val string_to_bool_list :
      char list
      ->
      bool
      list **)
  
  let rec string_to_bool_list = function
  | [] ->
    []
  | a::s0 ->
    (if (=)
          a
          '0'
     then false
     else true) :: (string_to_bool_list
                     s0)
  
  (** val string_to_Z_bool :
      char list
      ->
      Big.big_int
      ->
      bool **)
  
  let rec string_to_Z_bool s =
    let lb =
      string_to_bool_list
        s
    in
    let rec to_Z_bool l i =
      match l with
      | [] ->
        false
      | b :: l' ->
        if zeq
             i
             Big.zero
        then b
        else to_Z_bool
               l'
               (Z.sub
                 i
                 Big.one)
    in to_Z_bool
         (rev
           lb)
  
  (** val string_to_int :
      Big.big_int
      ->
      char list
      ->
      int **)
  
  let string_to_int n s =
    let zb =
      string_to_Z_bool
        s
    in
    repr
      n
      (coq_Z_of_bits
        n
        zb)
 end

type int1
  =
  Word.int

type int2
  =
  Word.int

type int3
  =
  Word.int

type int8
  =
  Word.int

type int16
  =
  Word.int

type int32
  =
  Word.int

type int80
  =
  Word.int

(** val zero_extend8_32 :
    int8
    ->
    int32 **)

let zero_extend8_32 w =
  Word.repr
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero)))))))))))))))))))))))))))))))
    (Word.unsigned
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      Big.zero)))))))
      w)

(** val sign_extend8_32 :
    int8
    ->
    int32 **)

let sign_extend8_32 w =
  Word.repr
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero)))))))))))))))))))))))))))))))
    (Word.signed
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      Big.zero)))))))
      w)

(** val sign_extend16_32 :
    int16
    ->
    int32 **)

let sign_extend16_32 w =
  Word.repr
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero)))))))))))))))))))))))))))))))
    (Word.signed
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      Big.zero)))))))))))))))
      w)

type port_number
  =
  int8

type interrupt_type
  =
  int8

type selector
  =
  int16

type register =
| EAX
| ECX
| EDX
| EBX
| ESP
| EBP
| ESI
| EDI

(** val register_eq_dec :
    register
    ->
    register
    ->
    bool **)

let register_eq_dec x y =
  match x with
  | EAX ->
    (match y with
     | EAX ->
       true
     | _ ->
       false)
  | ECX ->
    (match y with
     | ECX ->
       true
     | _ ->
       false)
  | EDX ->
    (match y with
     | EDX ->
       true
     | _ ->
       false)
  | EBX ->
    (match y with
     | EBX ->
       true
     | _ ->
       false)
  | ESP ->
    (match y with
     | ESP ->
       true
     | _ ->
       false)
  | EBP ->
    (match y with
     | EBP ->
       true
     | _ ->
       false)
  | ESI ->
    (match y with
     | ESI ->
       true
     | _ ->
       false)
  | EDI ->
    (match y with
     | EDI ->
       true
     | _ ->
       false)

(** val z_to_register :
    Big.big_int
    ->
    register **)

let z_to_register n =
  Big.z_case
    (fun _ ->
    EAX)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        EDI)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          EDI)
          (fun p2 ->
          EDI)
          (fun _ ->
          EBP)
          p1)
        (fun _ ->
        EBX)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          EDI)
          (fun p2 ->
          EDI)
          (fun _ ->
          ESI)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          EDI)
          (fun p2 ->
          EDI)
          (fun _ ->
          ESP)
          p1)
        (fun _ ->
        EDX)
        p0)
      (fun _ ->
      ECX)
      p)
    (fun p ->
    EDI)
    n

type scale =
| Scale1
| Scale2
| Scale4
| Scale8

(** val z_to_scale :
    Big.big_int
    ->
    scale **)

let z_to_scale n =
  Big.z_case
    (fun _ ->
    Scale1)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Scale8)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Scale8)
        (fun p1 ->
        Scale8)
        (fun _ ->
        Scale4)
        p0)
      (fun _ ->
      Scale2)
      p)
    (fun p ->
    Scale8)
    n

type segment_register =
| ES
| CS
| SS
| DS
| FS
| GS

(** val segment_register_eq_dec :
    segment_register
    ->
    segment_register
    ->
    bool **)

let segment_register_eq_dec x y =
  match x with
  | ES ->
    (match y with
     | ES ->
       true
     | _ ->
       false)
  | CS ->
    (match y with
     | CS ->
       true
     | _ ->
       false)
  | SS ->
    (match y with
     | SS ->
       true
     | _ ->
       false)
  | DS ->
    (match y with
     | DS ->
       true
     | _ ->
       false)
  | FS ->
    (match y with
     | FS ->
       true
     | _ ->
       false)
  | GS ->
    (match y with
     | GS ->
       true
     | _ ->
       false)

type control_register =
| CR0
| CR2
| CR3
| CR4

(** val control_register_eq_dec :
    control_register
    ->
    control_register
    ->
    bool **)

let control_register_eq_dec x y =
  match x with
  | CR0 ->
    (match y with
     | CR0 ->
       true
     | _ ->
       false)
  | CR2 ->
    (match y with
     | CR2 ->
       true
     | _ ->
       false)
  | CR3 ->
    (match y with
     | CR3 ->
       true
     | _ ->
       false)
  | CR4 ->
    (match y with
     | CR4 ->
       true
     | _ ->
       false)

type debug_register =
| DR0
| DR1
| DR2
| DR3
| DR6
| DR7

(** val debug_register_eq_dec :
    debug_register
    ->
    debug_register
    ->
    bool **)

let debug_register_eq_dec x y =
  match x with
  | DR0 ->
    (match y with
     | DR0 ->
       true
     | _ ->
       false)
  | DR1 ->
    (match y with
     | DR1 ->
       true
     | _ ->
       false)
  | DR2 ->
    (match y with
     | DR2 ->
       true
     | _ ->
       false)
  | DR3 ->
    (match y with
     | DR3 ->
       true
     | _ ->
       false)
  | DR6 ->
    (match y with
     | DR6 ->
       true
     | _ ->
       false)
  | DR7 ->
    (match y with
     | DR7 ->
       true
     | _ ->
       false)

type address = { addrDisp : int32;
                 addrBase : register
                            option;
                 addrIndex : (scale * register)
                             option }

(** val addrDisp :
    address
    ->
    int32 **)

let addrDisp x = x.addrDisp

(** val addrBase :
    address
    ->
    register
    option **)

let addrBase x = x.addrBase

(** val addrIndex :
    address
    ->
    (scale * register)
    option **)

let addrIndex x = x.addrIndex

type operand =
| Imm_op of int32
| Reg_op of register
| Address_op of address
| Offset_op of int32

type reg_or_immed =
| Reg_ri of register
| Imm_ri of int8

type condition_type =
| O_ct
| NO_ct
| B_ct
| NB_ct
| E_ct
| NE_ct
| BE_ct
| NBE_ct
| S_ct
| NS_ct
| P_ct
| NP_ct
| L_ct
| NL_ct
| LE_ct
| NLE_ct

(** val z_to_condition_type :
    Big.big_int
    ->
    condition_type **)

let z_to_condition_type n =
  Big.z_case
    (fun _ ->
    O_ct)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NLE_ct)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            NP_ct)
            p2)
          (fun _ ->
          NBE_ct)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            NL_ct)
            p2)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            NS_ct)
            p2)
          (fun _ ->
          NE_ct)
          p1)
        (fun _ ->
        NB_ct)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            LE_ct)
            p2)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            P_ct)
            p2)
          (fun _ ->
          BE_ct)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            L_ct)
            p2)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            S_ct)
            p2)
          (fun _ ->
          E_ct)
          p1)
        (fun _ ->
        B_ct)
        p0)
      (fun _ ->
      NO_ct)
      p)
    (fun p ->
    NLE_ct)
    n

type fp_operand =
| FPS_op of int3
| FPM16_op of address
| FPM32_op of address
| FPM64_op of address
| FPM80_op of address

type fp_condition_type =
| B_fct
| E_fct
| BE_fct
| U_fct
| NB_fct
| NE_fct
| NBE_fct
| NU_fct

(** val z_to_fp_condition_type :
    Big.big_int
    ->
    fp_condition_type **)

let z_to_fp_condition_type n =
  Big.z_case
    (fun _ ->
    B_fct)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        NU_fct)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NU_fct)
          (fun p2 ->
          NU_fct)
          (fun _ ->
          NE_fct)
          p1)
        (fun _ ->
        U_fct)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NU_fct)
          (fun p2 ->
          NU_fct)
          (fun _ ->
          NBE_fct)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NU_fct)
          (fun p2 ->
          NU_fct)
          (fun _ ->
          NB_fct)
          p1)
        (fun _ ->
        BE_fct)
        p0)
      (fun _ ->
      E_fct)
      p)
    (fun p ->
    NU_fct)
    n

type mmx_register =
| MM0
| MM1
| MM2
| MM3
| MM4
| MM5
| MM6
| MM7

(** val z_to_mmx_register :
    Big.big_int
    ->
    mmx_register **)

let z_to_mmx_register n =
  Big.z_case
    (fun _ ->
    MM0)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        MM7)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          MM7)
          (fun p2 ->
          MM7)
          (fun _ ->
          MM5)
          p1)
        (fun _ ->
        MM3)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          MM7)
          (fun p2 ->
          MM7)
          (fun _ ->
          MM6)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          MM7)
          (fun p2 ->
          MM7)
          (fun _ ->
          MM4)
          p1)
        (fun _ ->
        MM2)
        p0)
      (fun _ ->
      MM1)
      p)
    (fun p ->
    MM7)
    n

type mmx_granularity =
| MMX_8
| MMX_16
| MMX_32
| MMX_64

type mmx_operand =
| GP_Reg_op of register
| MMX_Addr_op of address
| MMX_Reg_op of mmx_register
| MMX_Imm_op of int32

type sse_register =
| XMM0
| XMM1
| XMM2
| XMM3
| XMM4
| XMM5
| XMM6
| XMM7

(** val z_to_sse_register :
    Big.big_int
    ->
    sse_register **)

let z_to_sse_register n =
  Big.z_case
    (fun _ ->
    XMM0)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        XMM7)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          XMM7)
          (fun p2 ->
          XMM7)
          (fun _ ->
          XMM5)
          p1)
        (fun _ ->
        XMM3)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          XMM7)
          (fun p2 ->
          XMM7)
          (fun _ ->
          XMM6)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          XMM7)
          (fun p2 ->
          XMM7)
          (fun _ ->
          XMM4)
          p1)
        (fun _ ->
        XMM2)
        p0)
      (fun _ ->
      XMM1)
      p)
    (fun p ->
    XMM7)
    n

type sse_operand =
| SSE_XMM_Reg_op of sse_register
| SSE_MM_Reg_op of mmx_register
| SSE_Addr_op of address
| SSE_GP_Reg_op of register
| SSE_Imm_op of int32

type instr =
| AAA
| AAD
| AAM
| AAS
| ADC of bool
   * operand
   * operand
| ADD of bool
   * operand
   * operand
| AND of bool
   * operand
   * operand
| ARPL of operand
   * operand
| BOUND of operand
   * operand
| BSF of operand
   * operand
| BSR of operand
   * operand
| BSWAP of register
| BT of operand
   * operand
| BTC of operand
   * operand
| BTR of operand
   * operand
| BTS of operand
   * operand
| CALL of bool
   * bool
   * operand
   * selector
     option
| CDQ
| CLC
| CLD
| CLI
| CLTS
| CMC
| CMOVcc of condition_type
   * operand
   * operand
| CMP of bool
   * operand
   * operand
| CMPS of bool
| CMPXCHG of bool
   * operand
   * operand
| CPUID
| CWDE
| DAA
| DAS
| DEC of bool
   * operand
| DIV of bool
   * operand
| F2XM1
| FABS
| FADD of bool
   * fp_operand
| FADDP of fp_operand
| FBLD of fp_operand
| FBSTP of fp_operand
| FCHS
| FCMOVcc of fp_condition_type
   * fp_operand
| FCOM of fp_operand
| FCOMP of fp_operand
| FCOMPP
| FCOMIP of fp_operand
| FCOS
| FDECSTP
| FDIV of bool
   * fp_operand
| FDIVP of fp_operand
| FDIVR of bool
   * fp_operand
| FDIVRP of fp_operand
| FFREE of fp_operand
| FIADD of fp_operand
| FICOM of fp_operand
| FICOMP of fp_operand
| FIDIV of fp_operand
| FIDIVR of fp_operand
| FILD of fp_operand
| FIMUL of fp_operand
| FINCSTP
| FIST of fp_operand
| FISTP of fp_operand
| FISUB of fp_operand
| FISUBR of fp_operand
| FLD of fp_operand
| FLD1
| FLDCW of fp_operand
| FLDENV of fp_operand
| FLDL2E
| FLDL2T
| FLDLG2
| FLDLN2
| FLDPI
| FLDZ
| FMUL of bool
   * fp_operand
| FMULP of fp_operand
| FNCLEX
| FNINIT
| FNOP
| FNSAVE of fp_operand
| FNSTCW of fp_operand
| FNSTSW of fp_operand
            option
| FPATAN
| FPREM
| FPREM1
| FPTAN
| FRNDINT
| FRSTOR of fp_operand
| FSCALE
| FSIN
| FSINCOS
| FSQRT
| FST of fp_operand
| FSTENV of fp_operand
| FSTP of fp_operand
| FSUB of bool
   * fp_operand
| FSUBP of fp_operand
| FSUBR of bool
   * fp_operand
| FSUBRP of fp_operand
| FTST
| FUCOM of fp_operand
| FUCOMP of fp_operand
| FUCOMPP
| FUCOMI of fp_operand
| FUCOMIP of fp_operand
| FXAM
| FXCH of fp_operand
| FXTRACT
| FYL2X
| FYL2XP1
| FWAIT
| EMMS
| MOVD of mmx_operand
   * mmx_operand
| MOVQ of mmx_operand
   * mmx_operand
| PACKSSDW of mmx_operand
   * mmx_operand
| PACKSSWB of mmx_operand
   * mmx_operand
| PACKUSWB of mmx_operand
   * mmx_operand
| PADD of mmx_granularity
   * mmx_operand
   * mmx_operand
| PADDS of mmx_granularity
   * mmx_operand
   * mmx_operand
| PADDUS of mmx_granularity
   * mmx_operand
   * mmx_operand
| PAND of mmx_operand
   * mmx_operand
| PANDN of mmx_operand
   * mmx_operand
| PCMPEQ of mmx_granularity
   * mmx_operand
   * mmx_operand
| PCMPGT of mmx_granularity
   * mmx_operand
   * mmx_operand
| PMADDWD of mmx_operand
   * mmx_operand
| PMULHUW of mmx_operand
   * mmx_operand
| PMULHW of mmx_operand
   * mmx_operand
| PMULLW of mmx_operand
   * mmx_operand
| POR of mmx_operand
   * mmx_operand
| PSLL of mmx_granularity
   * mmx_operand
   * mmx_operand
| PSRA of mmx_granularity
   * mmx_operand
   * mmx_operand
| PSRL of mmx_granularity
   * mmx_operand
   * mmx_operand
| PSUB of mmx_granularity
   * mmx_operand
   * mmx_operand
| PSUBS of mmx_granularity
   * mmx_operand
   * mmx_operand
| PSUBUS of mmx_granularity
   * mmx_operand
   * mmx_operand
| PUNPCKH of mmx_granularity
   * mmx_operand
   * mmx_operand
| PUNPCKL of mmx_granularity
   * mmx_operand
   * mmx_operand
| PXOR of mmx_operand
   * mmx_operand
| ADDPS of sse_operand
   * sse_operand
| ADDSS of sse_operand
   * sse_operand
| ANDNPS of sse_operand
   * sse_operand
| ANDPS of sse_operand
   * sse_operand
| CMPPS of sse_operand
   * sse_operand
   * sse_operand
| CMPSS of sse_operand
   * sse_operand
   * sse_operand
| COMISS of sse_operand
   * sse_operand
| CVTPI2PS of sse_operand
   * sse_operand
| CVTPS2PI of sse_operand
   * sse_operand
| CVTSI2SS of sse_operand
   * sse_operand
| CVTSS2SI of sse_operand
   * sse_operand
| CVTTPS2PI of sse_operand
   * sse_operand
| CVTTSS2SI of sse_operand
   * sse_operand
| DIVPS of sse_operand
   * sse_operand
| DIVSS of sse_operand
   * sse_operand
| LDMXCSR of sse_operand
| MAXPS of sse_operand
   * sse_operand
| MAXSS of sse_operand
   * sse_operand
| MINPS of sse_operand
   * sse_operand
| MINSS of sse_operand
   * sse_operand
| MOVAPS of sse_operand
   * sse_operand
| MOVHLPS of sse_operand
   * sse_operand
| MOVHPS of sse_operand
   * sse_operand
| MOVLHPS of sse_operand
   * sse_operand
| MOVLPS of sse_operand
   * sse_operand
| MOVMSKPS of sse_operand
   * sse_operand
| MOVSS of sse_operand
   * sse_operand
| MOVUPS of sse_operand
   * sse_operand
| MULPS of sse_operand
   * sse_operand
| MULSS of sse_operand
   * sse_operand
| ORPS of sse_operand
   * sse_operand
| RCPPS of sse_operand
   * sse_operand
| RCPSS of sse_operand
   * sse_operand
| RSQRTPS of sse_operand
   * sse_operand
| RSQRTSS of sse_operand
   * sse_operand
| SHUFPS of sse_operand
   * sse_operand
   * sse_operand
| SQRTPS of sse_operand
   * sse_operand
| SQRTSS of sse_operand
   * sse_operand
| STMXCSR of sse_operand
| SUBPS of sse_operand
   * sse_operand
| SUBSS of sse_operand
   * sse_operand
| UCOMISS of sse_operand
   * sse_operand
| UNPCKHPS of sse_operand
   * sse_operand
| UNPCKLPS of sse_operand
   * sse_operand
| XORPS of sse_operand
   * sse_operand
| PAVGB of sse_operand
   * sse_operand
| PEXTRW of sse_operand
   * sse_operand
   * sse_operand
| PINSRW of sse_operand
   * sse_operand
   * sse_operand
| PMAXSW of sse_operand
   * sse_operand
| PMAXUB of sse_operand
   * sse_operand
| PMINSW of sse_operand
   * sse_operand
| PMINUB of sse_operand
   * sse_operand
| PMOVMSKB of sse_operand
   * sse_operand
| PSADBW of sse_operand
   * sse_operand
| PSHUFW of sse_operand
   * sse_operand
   * sse_operand
| MASKMOVQ of sse_operand
   * sse_operand
| MOVNTPS of sse_operand
   * sse_operand
| MOVNTQ of sse_operand
   * sse_operand
| PREFETCHT0 of sse_operand
| PREFETCHT1 of sse_operand
| PREFETCHT2 of sse_operand
| PREFETCHNTA of sse_operand
| SFENCE
| HLT
| IDIV of bool
   * operand
| IMUL of bool
   * operand
   * operand
     option
   * int32
     option
| IN of bool
   * port_number
     option
| INC of bool
   * operand
| INS of bool
| INTn of interrupt_type
| INT
| INTO
| INVD
| INVLPG of operand
| IRET
| Jcc of condition_type
   * int32
| JCXZ of int8
| JMP of bool
   * bool
   * operand
   * selector
     option
| LAHF
| LAR of operand
   * operand
| LDS of operand
   * operand
| LEA of operand
   * operand
| LEAVE
| LES of operand
   * operand
| LFS of operand
   * operand
| LGDT of operand
| LGS of operand
   * operand
| LIDT of operand
| LLDT of operand
| LMSW of operand
| LODS of bool
| LOOP of int8
| LOOPZ of int8
| LOOPNZ of int8
| LSL of operand
   * operand
| LSS of operand
   * operand
| LTR of operand
| MOV of bool
   * operand
   * operand
| MOVCR of bool
   * control_register
   * register
| MOVDR of bool
   * debug_register
   * register
| MOVSR of bool
   * segment_register
   * operand
| MOVBE of operand
   * operand
| MOVS of bool
| MOVSX of bool
   * operand
   * operand
| MOVZX of bool
   * operand
   * operand
| MUL of bool
   * operand
| NEG of bool
   * operand
| NOP of operand
| NOT of bool
   * operand
| OR of bool
   * operand
   * operand
| OUT of bool
   * port_number
     option
| OUTS of bool
| POP of operand
| POPSR of segment_register
| POPA
| POPF
| PUSH of bool
   * operand
| PUSHSR of segment_register
| PUSHA
| PUSHF
| RCL of bool
   * operand
   * reg_or_immed
| RCR of bool
   * operand
   * reg_or_immed
| RDMSR
| RDPMC
| RDTSC
| RDTSCP
| RET of bool
   * int16
     option
| ROL of bool
   * operand
   * reg_or_immed
| ROR of bool
   * operand
   * reg_or_immed
| RSM
| SAHF
| SAR of bool
   * operand
   * reg_or_immed
| SBB of bool
   * operand
   * operand
| SCAS of bool
| SETcc of condition_type
   * operand
| SGDT of operand
| SHL of bool
   * operand
   * reg_or_immed
| SHLD of operand
   * register
   * reg_or_immed
| SHR of bool
   * operand
   * reg_or_immed
| SHRD of operand
   * register
   * reg_or_immed
| SIDT of operand
| SLDT of operand
| SMSW of operand
| STC
| STD
| STI
| STOS of bool
| STR of operand
| SUB of bool
   * operand
   * operand
| TEST of bool
   * operand
   * operand
| UD2
| VERR of operand
| VERW of operand
| WBINVD
| WRMSR
| XADD of bool
   * operand
   * operand
| XCHG of bool
   * operand
   * operand
| XLAT
| XOR of bool
   * operand
   * operand

type lock_or_rep =
| Lock
| Rep
| Repn

type prefix = { lock_rep : lock_or_rep
                           option;
                seg_override : segment_register
                               option;
                op_override : bool;
                addr_override : bool }

(** val lock_rep :
    prefix
    ->
    lock_or_rep
    option **)

let lock_rep x = x.lock_rep

(** val seg_override : prefix -> segment_register option **)

let seg_override x = x.seg_override

(** val op_override : prefix -> bool **)

let op_override x = x.op_override

(** val addr_override : prefix -> bool **)

let addr_override x = x.addr_override

module X86_PARSER_ARG = 
 struct 
  type char_p = bool
  
  (** val char_dec : char_p -> char_p -> bool **)
  
  let char_dec =
    bool_dec
  
  type coq_type =
  | Int_t
  | Register_t
  | Byte_t
  | Half_t
  | Word_t
  | Double_Word_t
  | Ten_Byte_t
  | Scale_t
  | Condition_t
  | Address_t
  | Operand_t
  | Fpu_Register_t
  | Fp_Debug_Register_t
  | Fp_Operand_t
  | MMX_Granularity_t
  | MMX_Register_t
  | MMX_Operand_t
  | SSE_Register_t
  | SSE_Operand_t
  | Instruction_t
  | Control_Register_t
  | Debug_Register_t
  | Segment_Register_t
  | Lock_or_Rep_t
  | Bool_t
  | Prefix_t
  | Option_t of coq_type
  | UPair_t of coq_type * coq_type
  
  (** val type_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> (coq_type -> 'a1 -> 'a1) ->
      (coq_type -> 'a1 -> coq_type -> 'a1 -> 'a1) -> coq_type -> 'a1 **)
  
  let rec type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 = function
  | Int_t -> f
  | Register_t -> f0
  | Byte_t -> f1
  | Half_t -> f2
  | Word_t -> f3
  | Double_Word_t -> f4
  | Ten_Byte_t -> f5
  | Scale_t -> f6
  | Condition_t -> f7
  | Address_t -> f8
  | Operand_t -> f9
  | Fpu_Register_t -> f10
  | Fp_Debug_Register_t -> f11
  | Fp_Operand_t -> f12
  | MMX_Granularity_t -> f13
  | MMX_Register_t -> f14
  | MMX_Operand_t -> f15
  | SSE_Register_t -> f16
  | SSE_Operand_t -> f17
  | Instruction_t -> f18
  | Control_Register_t -> f19
  | Debug_Register_t -> f20
  | Segment_Register_t -> f21
  | Lock_or_Rep_t -> f22
  | Bool_t -> f23
  | Prefix_t -> f24
  | Option_t t1 ->
    f25 t1
      (type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1)
  | UPair_t (t1, t2) ->
    f26 t1
      (type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1) t2
      (type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t2)
  
  (** val type_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> (coq_type -> 'a1 -> 'a1) ->
      (coq_type -> 'a1 -> coq_type -> 'a1 -> 'a1) -> coq_type -> 'a1 **)
  
  let rec type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 = function
  | Int_t -> f
  | Register_t -> f0
  | Byte_t -> f1
  | Half_t -> f2
  | Word_t -> f3
  | Double_Word_t -> f4
  | Ten_Byte_t -> f5
  | Scale_t -> f6
  | Condition_t -> f7
  | Address_t -> f8
  | Operand_t -> f9
  | Fpu_Register_t -> f10
  | Fp_Debug_Register_t -> f11
  | Fp_Operand_t -> f12
  | MMX_Granularity_t -> f13
  | MMX_Register_t -> f14
  | MMX_Operand_t -> f15
  | SSE_Register_t -> f16
  | SSE_Operand_t -> f17
  | Instruction_t -> f18
  | Control_Register_t -> f19
  | Debug_Register_t -> f20
  | Segment_Register_t -> f21
  | Lock_or_Rep_t -> f22
  | Bool_t -> f23
  | Prefix_t -> f24
  | Option_t t1 ->
    f25 t1
      (type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1)
  | UPair_t (t1, t2) ->
    f26 t1
      (type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1) t2
      (type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t2)
  
  type tipe = coq_type
  
  (** val tipe_eq : tipe -> tipe -> bool **)
  
  let rec tipe_eq t0 t1 =
    match t0 with
    | Int_t ->
      (match t1 with
       | Int_t -> true
       | _ -> false)
    | Register_t ->
      (match t1 with
       | Register_t -> true
       | _ -> false)
    | Byte_t ->
      (match t1 with
       | Byte_t -> true
       | _ -> false)
    | Half_t ->
      (match t1 with
       | Half_t -> true
       | _ -> false)
    | Word_t ->
      (match t1 with
       | Word_t -> true
       | _ -> false)
    | Double_Word_t ->
      (match t1 with
       | Double_Word_t -> true
       | _ -> false)
    | Ten_Byte_t ->
      (match t1 with
       | Ten_Byte_t -> true
       | _ -> false)
    | Scale_t ->
      (match t1 with
       | Scale_t -> true
       | _ -> false)
    | Condition_t ->
      (match t1 with
       | Condition_t -> true
       | _ -> false)
    | Address_t ->
      (match t1 with
       | Address_t -> true
       | _ -> false)
    | Operand_t ->
      (match t1 with
       | Operand_t -> true
       | _ -> false)
    | Fpu_Register_t ->
      (match t1 with
       | Fpu_Register_t -> true
       | _ -> false)
    | Fp_Debug_Register_t ->
      (match t1 with
       | Fp_Debug_Register_t -> true
       | _ -> false)
    | Fp_Operand_t ->
      (match t1 with
       | Fp_Operand_t -> true
       | _ -> false)
    | MMX_Granularity_t ->
      (match t1 with
       | MMX_Granularity_t -> true
       | _ -> false)
    | MMX_Register_t ->
      (match t1 with
       | MMX_Register_t -> true
       | _ -> false)
    | MMX_Operand_t ->
      (match t1 with
       | MMX_Operand_t -> true
       | _ -> false)
    | SSE_Register_t ->
      (match t1 with
       | SSE_Register_t -> true
       | _ -> false)
    | SSE_Operand_t ->
      (match t1 with
       | SSE_Operand_t -> true
       | _ -> false)
    | Instruction_t ->
      (match t1 with
       | Instruction_t -> true
       | _ -> false)
    | Control_Register_t ->
      (match t1 with
       | Control_Register_t -> true
       | _ -> false)
    | Debug_Register_t ->
      (match t1 with
       | Debug_Register_t -> true
       | _ -> false)
    | Segment_Register_t ->
      (match t1 with
       | Segment_Register_t -> true
       | _ -> false)
    | Lock_or_Rep_t ->
      (match t1 with
       | Lock_or_Rep_t -> true
       | _ -> false)
    | Bool_t ->
      (match t1 with
       | Bool_t -> true
       | _ -> false)
    | Prefix_t ->
      (match t1 with
       | Prefix_t -> true
       | _ -> false)
    | Option_t t2 ->
      (match t1 with
       | Option_t t3 -> tipe_eq t2 t3
       | _ -> false)
    | UPair_t (t2, t3) ->
      (match t1 with
       | UPair_t (t4, t5) -> if tipe_eq t2 t4 then tipe_eq t3 t5 else false
       | _ -> false)
  
  type tipe_m = __
  
  type user_type = coq_type
  
  (** val user_type_dec : user_type -> user_type -> bool **)
  
  let user_type_dec =
    tipe_eq
  
  type user_type_denote = tipe_m
  
  (** val byte_explode : int8 -> bool list **)
  
  let byte_explode b =
    let bs =
      Word.bits_of_Z (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero))))))))
        (Word.unsigned (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))) b)
    in
    (bs (Big.doubleplusone (Big.doubleplusone Big.one))) :: ((bs (Big.double
                                                               (Big.doubleplusone
                                                               Big.one))) :: (
    (bs (Big.doubleplusone (Big.double Big.one))) :: ((bs (Big.double
                                                        (Big.double
                                                        Big.one))) :: (
    (bs (Big.doubleplusone Big.one)) :: ((bs (Big.double Big.one)) :: (
    (bs Big.one) :: ((bs Big.zero) :: [])))))))
  
  (** val nat_explode : Big.big_int -> bool list **)
  
  let nat_explode n =
    byte_explode
      (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ Big.zero))))))) (Z.of_nat n))
  
  type token_id = Big.big_int
  
  (** val num_tokens : token_id **)
  
  let num_tokens =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  
  (** val token_id_to_chars : token_id -> char_p list **)
  
  let token_id_to_chars =
    nat_explode
 end

type type0 =
| Unit_t
| Char_t
| Void_t
| Pair_t of type0 * type0
| Sum_t of type0 * type0
| List_t of type0
| User_t of X86_PARSER_ARG.user_type

type interp = __

type xform =
| Xid
| Xzero
| Xcomp of xform * xform
| Xchar of X86_PARSER_ARG.char_p
| Xunit
| Xempty
| Xpair of xform * xform
| Xfst
| Xsnd
| Xinl
| Xinr
| Xmatch of xform * xform
| Xcons of xform * xform
| Xmap of xform

(** val xinterp : xform -> interp -> interp **)

let rec xinterp = function
| Xid -> (fun x0 -> x0)
| Xzero -> Obj.magic (fun _ -> assert false (* absurd case *))
| Xcomp (f1, f2) ->
  let f1' = xinterp f1 in let f2' = xinterp f2 in (fun x0 -> f2' (f1' x0))
| Xchar c -> (fun x0 -> Obj.magic c)
| Xunit -> (fun x0 -> Obj.magic ())
| Xempty -> (fun x0 -> Obj.magic [])
| Xpair (f1, f2) ->
  let f1' = xinterp f1 in
  let f2' = xinterp f2 in (fun x0 -> Obj.magic ((f1' x0), (f2' x0)))
| Xfst -> (fun x0 -> fst (Obj.magic x0))
| Xsnd -> (fun x0 -> snd (Obj.magic x0))
| Xinl -> (fun x0 -> Obj.magic (Inl x0))
| Xinr -> (fun x0 -> Obj.magic (Inr x0))
| Xmatch (f1, f2) ->
  let f1' = xinterp f1 in
  let f2' = xinterp f2 in
  (fun x0 ->
  match Obj.magic x0 with
  | Inl x1 -> f1' x1
  | Inr x2 -> f2' x2)
| Xcons (f1, f2) ->
  let f1' = xinterp f1 in
  let f2' = xinterp f2 in
  (fun x0 -> Obj.magic ((f1' x0) :: (Obj.magic f2' x0)))
| Xmap f ->
  let f' = xinterp f in (fun x0 -> Obj.magic (map f' (Obj.magic x0)))

type grammar =
| Eps
| Zero
| Char of X86_PARSER_ARG.char_p
| Any
| Cat of grammar * grammar
| Alt of grammar * grammar
| Star of grammar
| Map of (interp -> interp) * grammar
| Xform of xform * grammar

(** val xcoerce : xform -> xform **)

let xcoerce x =
  x

(** val xpair_fst : xform -> xform **)

let xpair_fst = function
| Xfst -> Xpair ((xcoerce Xfst), Xfst)
| Xsnd -> xcoerce Xid
| x -> Xpair ((xcoerce Xfst), x)

(** val xpair_r : xform -> xform -> xform **)

let xpair_r x2 x1 =
  match x2 with
  | Xzero -> Xzero
  | x -> Xpair (x1, x)

(** val xpair : xform -> xform -> xform **)

let xpair x1 x2 =
  match x1 with
  | Xzero -> Xzero
  | Xfst -> xpair_fst x2
  | x -> xpair_r x2 x

(** val xmatch_inl : xform -> xform **)

let xmatch_inl = function
| Xinl -> Xmatch (Xinl, (xcoerce Xinl))
| Xinr -> xcoerce Xid
| x -> Xmatch (Xinl, (xcoerce x))

(** val xmatch : xform -> xform -> xform **)

let xmatch x1 x2 =
  match x1 with
  | Xinl -> xmatch_inl x2
  | x -> Xmatch (x, x2)

(** val xcomp_pair : xform -> xform -> xform -> xform **)

let xcomp_pair x2 x11 x12 =
  match x2 with
  | Xid -> xcoerce (Xpair (x11, x12))
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xpair (x21, x22) ->
    Xpair ((Xcomp ((Xpair (x11, x12)), (xcoerce x21))), (Xcomp ((Xpair (x11,
      x12)), (xcoerce x22))))
  | Xfst -> xcoerce x11
  | Xsnd -> xcoerce x12
  | x -> Xcomp ((Xpair (x11, x12)), (xcoerce x))

(** val xcomp_inl : xform -> xform **)

let xcomp_inl = function
| Xid -> xcoerce Xinl
| Xchar c -> Xchar c
| Xunit -> Xunit
| Xempty -> Xempty
| Xinl -> Xcomp (Xinl, (xcoerce Xinl))
| Xmatch (x21, x22) -> xcoerce x21
| x -> Xcomp (Xinl, (xcoerce x))

(** val xcomp_inr : xform -> xform **)

let xcomp_inr = function
| Xid -> xcoerce Xinr
| Xchar c -> Xchar c
| Xunit -> Xunit
| Xempty -> Xempty
| Xinr -> Xcomp (Xinr, (xcoerce Xinr))
| Xmatch (x21, x22) -> xcoerce x22
| x -> Xcomp (Xinr, (xcoerce x))

(** val xcomp_map : xform -> xform -> xform **)

let xcomp_map x2 x11 =
  match x2 with
  | Xid -> xcoerce (Xmap x11)
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xmap x21 -> Xmap (Xcomp (x11, (xcoerce x21)))
  | x -> Xcomp ((Xmap x11), (xcoerce x))

(** val xcomp_empty : xform -> xform **)

let xcomp_empty = function
| Xid -> xcoerce Xempty
| Xchar c -> Xchar c
| Xunit -> Xunit
| Xempty -> Xempty
| Xmap f -> Xempty
| x -> Xcomp (Xempty, (xcoerce x))

(** val xcomp_cons : xform -> xform -> xform -> xform **)

let xcomp_cons x2 x11 x12 =
  match x2 with
  | Xid -> xcoerce (Xcons (x11, x12))
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xmap x ->
    Xcons ((Xcomp (x11, (xcoerce x))), (Xcomp (x12, (xcoerce (Xmap x)))))
  | x -> Xcomp ((Xcons (x11, x12)), (xcoerce x))

(** val xcomp_r : xform -> xform -> xform **)

let xcomp_r x2 x =
  match x2 with
  | Xid -> x
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xpair (x21, x22) -> Xpair ((Xcomp (x, x21)), (Xcomp (x, x22)))
  | x0 -> Xcomp (x, x0)

(** val xcomp : xform -> xform -> xform **)

let rec xcomp x1 x =
  match x1 with
  | Xid -> x
  | Xzero -> Xzero
  | Xcomp (x11, x12) -> xcomp x11 (xcomp x12 x)
  | Xempty -> xcomp_empty x
  | Xpair (x11, x12) -> xcomp_pair x x11 x12
  | Xinl -> xcomp_inl x
  | Xinr -> xcomp_inr x
  | Xmatch (x11, x12) -> Xmatch ((xcomp x11 x), (xcomp x12 x))
  | Xcons (x11, x12) -> xcomp_cons x x11 x12
  | Xmap x11 -> xcomp_map x x11
  | x0 -> xcomp_r x x0

(** val xcomp' : xform -> xform -> xform **)

let rec xcomp' x2 x =
  match x2 with
  | Xcomp (x21, x22) -> xcomp' x22 (xcomp' x21 x)
  | Xpair (x21, x22) -> Xpair ((xcomp' x21 x), (xcomp' x22 x))
  | x0 -> xcomp x x0

(** val xopt : xform -> xform **)

let rec xopt = function
| Xcomp (x1, x2) -> xcomp' (xopt x2) (xopt x1)
| Xpair (x1, x2) -> xpair (xopt x1) (xopt x2)
| Xmatch (x1, x2) -> xmatch (xopt x1) (xopt x2)
| Xcons (x1, x2) -> Xcons ((xopt x1), (xopt x2))
| Xmap x1 -> Xmap (xopt x1)
| x0 -> x0

type astgram =
| AEps
| AZero
| AChar of X86_PARSER_ARG.char_p
| AAny
| ACat of astgram * astgram
| AAlt of astgram * astgram
| AStar of astgram

(** val astgram_dec : astgram -> astgram -> bool **)

let rec astgram_dec a a0 =
  match a with
  | AEps ->
    (match a0 with
     | AEps -> true
     | _ -> false)
  | AZero ->
    (match a0 with
     | AZero -> true
     | _ -> false)
  | AChar c ->
    (match a0 with
     | AChar c0 -> X86_PARSER_ARG.char_dec c c0
     | _ -> false)
  | AAny ->
    (match a0 with
     | AAny -> true
     | _ -> false)
  | ACat (a1, a2) ->
    (match a0 with
     | ACat (a3, a4) ->
       if astgram_dec a1 a3 then astgram_dec a2 a4 else false
     | _ -> false)
  | AAlt (a1, a2) ->
    (match a0 with
     | AAlt (a3, a4) ->
       if astgram_dec a1 a3 then astgram_dec a2 a4 else false
     | _ -> false)
  | AStar a1 ->
    (match a0 with
     | AStar a2 -> astgram_dec a1 a2
     | _ -> false)

(** val astgram_type : astgram -> type0 **)

let rec astgram_type = function
| AEps -> Unit_t
| AZero -> Void_t
| ACat (pg1, pg2) -> Pair_t ((astgram_type pg1), (astgram_type pg2))
| AAlt (pg1, pg2) -> Sum_t ((astgram_type pg1), (astgram_type pg2))
| AStar pg0 -> List_t (astgram_type pg0)
| _ -> Char_t

type fixfn = interp -> interp

(** val ag_and_fn : astgram -> fixfn -> (astgram, fixfn) sigT **)

let ag_and_fn ag f =
  ExistT (ag, f)

(** val split_astgram : grammar -> (astgram, fixfn) sigT **)

let rec split_astgram = function
| Eps -> ag_and_fn AEps (fun x -> x)
| Zero ->
  ag_and_fn AZero (Obj.magic (fun _ -> assert false (* absurd case *)))
| Char c -> ag_and_fn (AChar c) (fun x -> x)
| Any -> ag_and_fn AAny (fun x -> x)
| Cat (g1, g2) ->
  let ExistT (ag1, f1) = split_astgram g1 in
  let ExistT (ag2, f2) = split_astgram g2 in
  ag_and_fn (ACat (ag1, ag2)) (fun p ->
    Obj.magic ((f1 (fst (Obj.magic p))), (f2 (snd (Obj.magic p)))))
| Alt (g1, g2) ->
  let ExistT (ag1, f1) = split_astgram g1 in
  let ExistT (ag2, f2) = split_astgram g2 in
  ag_and_fn (AAlt (ag1, ag2)) (fun s ->
    match Obj.magic s with
    | Inl x -> Obj.magic (Inl (f1 x))
    | Inr y -> Obj.magic (Inr (f2 y)))
| Star g0 ->
  let ExistT (ag, f) = split_astgram g0 in
  ag_and_fn (AStar ag) (fun xs -> Obj.magic (map f (Obj.magic xs)))
| Map (f1, g0) ->
  let ExistT (ag, f2) = split_astgram g0 in ag_and_fn ag (fun x -> f1 (f2 x))
| Xform (f, g0) ->
  let ExistT (ag, f2) = split_astgram g0 in
  ag_and_fn ag (fun x -> xinterp f (f2 x))

(** val agxf : astgram -> xform -> (astgram, xform) sigT **)

let agxf ag f =
  ExistT (ag, f)

(** val append_alt : astgram -> astgram -> (astgram, xform) sigT **)

let rec append_alt ag1 ag2 =
  match ag1 with
  | AZero -> agxf ag2 Xinr
  | x ->
    (match ag2 with
     | AZero -> agxf x Xinl
     | x0 -> agxf (AAlt (x, x0)) Xid)

(** val append_cat : astgram -> astgram -> (astgram, xform) sigT **)

let rec append_cat ag1 ag2 =
  match ag1 with
  | AEps -> agxf ag2 (Xpair (Xunit, Xid))
  | AZero -> agxf AZero Xzero
  | x ->
    (match ag2 with
     | AEps -> agxf x (Xpair (Xid, Xunit))
     | AZero -> agxf AZero Xzero
     | x0 -> agxf (ACat (x, x0)) Xid)

(** val opt_ag : astgram -> (astgram, xform) sigT **)

let opt_ag = function
| ACat (ag1, ag2) -> append_cat ag1 ag2
| AAlt (ag1, ag2) -> append_alt ag1 ag2
| AStar a ->
  (match a with
   | AZero -> agxf AEps Xempty
   | x -> let ag' = AStar x in agxf ag' Xid)
| x -> agxf x Xid

(** val opt_agxf : astgram -> xform -> (astgram, xform) sigT **)

let opt_agxf ag f =
  let ExistT (ag', f') = opt_ag ag in agxf ag' (xcomp f' f)

(** val null_and_split : astgram -> (astgram, xform) sigT **)

let rec null_and_split = function
| AEps -> agxf AEps Xid
| ACat (ag11, ag12) ->
  let ExistT (ag11', f1) = null_and_split ag11 in
  (match ag11' with
   | AZero -> agxf AZero Xzero
   | _ ->
     let ExistT (ag12', f2) = null_and_split ag12 in
     opt_agxf (ACat (ag11', ag12')) (Xpair ((Xcomp (Xfst, f1)), (Xcomp (Xsnd,
       f2)))))
| AAlt (ag11, ag12) ->
  let ExistT (ag11', f1) = null_and_split ag11 in
  let ExistT (ag12', f2) = null_and_split ag12 in
  opt_agxf (AAlt (ag11', ag12')) (Xmatch ((Xcomp (f1, Xinl)), (Xcomp (f2,
    Xinr))))
| AStar ag11 -> agxf AEps Xempty
| _ -> agxf AZero Xzero

(** val deriv_and_split :
    astgram -> X86_PARSER_ARG.char_p -> (astgram, xform) sigT **)

let rec deriv_and_split ag1 c =
  match ag1 with
  | AChar c' ->
    if X86_PARSER_ARG.char_dec c c'
    then agxf AEps (Xchar c)
    else agxf AZero Xzero
  | AAny -> agxf AEps (Xchar c)
  | ACat (ag11, ag12) ->
    let ExistT (ag11', f1) = deriv_and_split ag11 c in
    let ExistT (ag_left, f_left) = opt_ag (ACat (ag11', ag12)) in
    let ExistT (ag11null', fnull) = null_and_split ag11 in
    (match ag11null' with
     | AZero ->
       agxf ag_left (Xcomp (f_left, (Xpair ((Xcomp (Xfst, f1)), Xsnd))))
     | _ ->
       let ExistT (ag12', f2) = deriv_and_split ag12 c in
       let ExistT (ag_right, f_right) = opt_ag (ACat (ag11null', ag12')) in
       opt_agxf (AAlt (ag_left, ag_right)) (Xmatch ((Xcomp (f_left, (Xpair
         ((Xcomp (Xfst, f1)), Xsnd)))), (Xcomp (f_right, (Xpair ((Xcomp
         (Xfst, fnull)), (Xcomp (Xsnd, f2)))))))))
  | AAlt (ag11, ag12) ->
    let ExistT (ag11', f1) = deriv_and_split ag11 c in
    let ExistT (ag12', f2) = deriv_and_split ag12 c in
    opt_agxf (AAlt (ag11', ag12')) (Xmatch ((Xcomp (f1, Xinl)), (Xcomp (f2,
      Xinr))))
  | AStar ag0 ->
    let ExistT (ag0', f) = deriv_and_split ag0 c in
    opt_agxf (ACat (ag0', (AStar ag0))) (Xcons ((Xcomp (Xfst, f)), Xsnd))
  | _ -> agxf AZero Xzero

(** val cross_prod : 'a1 list -> 'a2 list -> ('a1 * 'a2) list **)

let cross_prod xs ys =
  fold_right (fun v a -> app (map (fun w -> (v, w)) ys) a) [] xs

(** val astgram_extract_nil : astgram -> interp list **)

let rec astgram_extract_nil = function
| AEps -> (Obj.magic ()) :: []
| ACat (ag1, ag2) ->
  Obj.magic (cross_prod (astgram_extract_nil ag1) (astgram_extract_nil ag2))
| AAlt (ag1, ag2) ->
  app (map (fun x -> Obj.magic (Inl x)) (astgram_extract_nil ag1))
    (map (fun x -> Obj.magic (Inr x)) (astgram_extract_nil ag2))
| AStar ag0 -> (Obj.magic []) :: []
| _ -> []

(** val derivs_and_split :
    astgram -> X86_PARSER_ARG.char_p list -> (astgram, xform) sigT **)

let rec derivs_and_split ag = function
| [] -> agxf ag Xid
| c :: cs' ->
  let ExistT (ag1, x1) = deriv_and_split ag c in
  let ExistT (ag2, x2) = derivs_and_split ag1 cs' in
  agxf ag2 (xopt (xcomp' x1 x2))

type states_t = astgram list

type entry_t = { next_state : Big.big_int; next_xform : (interp -> interp) }

(** val next_state : Big.big_int -> states_t -> entry_t -> Big.big_int **)

let next_state _ _ x = x.next_state

(** val next_xform :
    Big.big_int -> states_t -> entry_t -> interp -> interp **)

let next_xform _ _ x = x.next_xform

type row_t = entry_t list

type transition_t = { row_num : Big.big_int; row_entries : entry_t list;
                      row_nils : interp list }

(** val row_num : states_t -> transition_t -> Big.big_int **)

let row_num _ x = x.row_num

(** val row_entries : states_t -> transition_t -> entry_t list **)

let row_entries _ x = x.row_entries

(** val row_nils : states_t -> transition_t -> interp list **)

let row_nils _ x = x.row_nils

type transitions_t = transition_t list

type dFA = { dfa_num_states : Big.big_int; dfa_states : states_t;
             dfa_transition : transitions_t; dfa_accepts : bool list;
             dfa_rejects : bool list }

(** val dfa_states : dFA -> states_t **)

let dfa_states x = x.dfa_states

(** val dfa_transition : dFA -> transitions_t **)

let dfa_transition x = x.dfa_transition

(** val find_index' :
    astgram -> Big.big_int -> states_t -> Big.big_int option **)

let rec find_index' g n = function
| [] -> None
| h :: t0 ->
  if astgram_dec g h
  then Some n
  else find_index' g (plus (Big.succ Big.zero) n) t0

(** val find_index : astgram -> states_t -> Big.big_int option **)

let find_index g states =
  find_index' g Big.zero states

(** val find_or_add : astgram -> states_t -> states_t * Big.big_int **)

let find_or_add g states =
  match find_index g states with
  | Some i -> ([], i)
  | None -> ((g :: []), (length states))

(** val accepts_null : astgram -> bool **)

let rec accepts_null = function
| AEps -> true
| ACat (g1, g2) -> (&&) (accepts_null g1) (accepts_null g2)
| AAlt (g1, g2) -> (||) (accepts_null g1) (accepts_null g2)
| AStar a -> true
| _ -> false

(** val build_accept_table : states_t -> bool list **)

let build_accept_table s =
  map accepts_null s

(** val always_rejects : astgram -> bool **)

let rec always_rejects = function
| AZero -> true
| ACat (g1, g2) -> (||) (always_rejects g1) (always_rejects g2)
| AAlt (g1, g2) -> (&&) (always_rejects g1) (always_rejects g2)
| _ -> false

(** val build_reject_table : states_t -> bool list **)

let build_reject_table s =
  map always_rejects s

(** val gen_row' :
    astgram -> Big.big_int -> Big.big_int -> states_t ->
    X86_PARSER_ARG.token_id -> (states_t, (row_t, __) sigT) sigT **)

let rec gen_row' g gpos n s tid =
  Big.nat_case
    (fun _ -> ExistT ([], (ExistT ([],
    __))))
    (fun n' ->
    let ExistT (g', x) =
      derivs_and_split g (X86_PARSER_ARG.token_id_to_chars tid)
    in
    let ExistT (s2, row) =
      gen_row' g gpos n' (app s (fst (find_or_add g' s)))
        (plus (Big.succ Big.zero) tid)
    in
    let e = { next_state = (snd (find_or_add g' s)); next_xform =
      (xinterp (xcoerce x)) }
    in
    let ExistT (r2, _) = row in
    ExistT ((app (fst (find_or_add g' s)) s2), (ExistT ((e :: r2), __))))
    n

(** val gen_row :
    astgram -> Big.big_int -> states_t -> (states_t, (row_t, __) sigT) sigT **)

let gen_row g gpos s =
  let ExistT (s', s0) = gen_row' g gpos X86_PARSER_ARG.num_tokens s Big.zero
  in
  let ExistT (r2, _) = s0 in ExistT (s', (ExistT (r2, __)))

(** val coerce_entry :
    Big.big_int -> astgram list -> astgram list -> entry_t -> entry_t **)

let coerce_entry r2 s s1 e =
  { next_state = e.next_state; next_xform = e.next_xform }

(** val coerce_nils :
    astgram list -> astgram list -> Big.big_int -> interp -> interp **)

let coerce_nils s1 s2 i v =
  v

(** val coerce_transitions :
    astgram list -> states_t -> transitions_t -> transitions_t **)

let coerce_transitions s1 s ts =
  map (fun t0 -> { row_num = t0.row_num; row_entries =
    (map (coerce_entry t0.row_num s s1) t0.row_entries); row_nils =
    (map (coerce_nils s s1 t0.row_num) t0.row_nils) }) ts

(** val build_table :
    Big.big_int -> states_t -> transitions_t -> Big.big_int -> (states_t,
    transitions_t) sigT option **)

let rec build_table n s rows next_state0 =
  Big.nat_case
    (fun _ ->
    None)
    (fun n' ->
    match nth_error s next_state0 with
    | Some r2 ->
      let ExistT (s1, s0) = gen_row r2 next_state0 s in
      let ExistT (row, _) = s0 in
      let t0 = { row_num = next_state0; row_entries = row; row_nils =
        (astgram_extract_nil (nth next_state0 (app s s1) AZero)) }
      in
      build_table n' (app s s1)
        (app (coerce_transitions s1 s rows) (t0 :: []))
        (plus (Big.succ Big.zero) next_state0)
    | None -> Some (ExistT (s, rows)))
    n

(** val build_transition_table :
    Big.big_int -> astgram -> (states_t, transitions_t) sigT option **)

let build_transition_table n r2 =
  build_table n (r2 :: []) [] Big.zero

(** val build_dfa : Big.big_int -> astgram -> dFA option **)

let build_dfa n a =
  match build_transition_table n a with
  | Some s ->
    let ExistT (states, table) = s in
    Some { dfa_num_states = (length states); dfa_states = states;
    dfa_transition = table; dfa_accepts = (build_accept_table states);
    dfa_rejects = (build_reject_table states) }
  | None -> None

(** val coerce_dom : type0 -> type0 -> (interp -> 'a1) -> interp -> 'a1 **)

let coerce_dom a a' f x =
  f x

type instParserState = { dfa_ps : dFA; row_ps : Big.big_int; fixup_ps : fixfn }

(** val dfa_ps : type0 -> instParserState -> dFA **)

let dfa_ps _ x = x.dfa_ps

(** val row_ps : type0 -> instParserState -> Big.big_int **)

let row_ps _ x = x.row_ps

(** val fixup_ps : type0 -> instParserState -> fixfn **)

let fixup_ps _ x = x.fixup_ps

(** val opt_initial_parser_state :
    Big.big_int -> grammar -> instParserState option **)

let opt_initial_parser_state n g =
  let ExistT (ag, f) = split_astgram g in
  (match build_dfa n ag with
   | Some d ->
     Some { dfa_ps = d; row_ps = Big.zero; fixup_ps =
       (coerce_dom (astgram_type ag)
         (astgram_type (nth Big.zero d.dfa_states AZero)) f) }
   | None -> None)

(** val compose : ('a1 -> 'a2) -> ('a2 -> 'a3) -> 'a1 -> 'a3 **)

let compose f g z =
  g (f z)

(** val coerce : 'a1 -> 'a2 **)

let coerce x =
  Obj.magic x

(** val parse_token :
    instParserState -> X86_PARSER_ARG.token_id -> instParserState * interp
    list **)

let parse_token ps tk =
  let d = ps.dfa_ps in
  (match nth_error d.dfa_transition ps.row_ps with
   | Some row ->
     (match nth_error row.row_entries tk with
      | Some e ->
        let next_i = e.next_state in
        let g = compose e.next_xform (coerce ps.fixup_ps) in
        let vs0 =
          match nth_error d.dfa_transition next_i with
          | Some row' -> coerce row'.row_nils
          | None -> []
        in
        let vs' = map g vs0 in
        ({ dfa_ps = d; row_ps = next_i; fixup_ps = g }, vs')
      | None -> assert false (* absurd case *))
   | None -> assert false (* absurd case *))

module PTree = 
 struct 
  type elt = Big.big_int
  
  (** val elt_eq : Big.big_int -> Big.big_int -> bool **)
  
  let elt_eq =
    peq
  
  type 'a tree =
  | Leaf
  | Node of 'a tree * 'a option * 'a tree
  
  (** val tree_rect :
      'a2 -> ('a1 tree -> 'a2 -> 'a1 option -> 'a1 tree -> 'a2 -> 'a2) -> 'a1
      tree -> 'a2 **)
  
  let rec tree_rect f f0 = function
  | Leaf -> f
  | Node (t1, o, t2) -> f0 t1 (tree_rect f f0 t1) o t2 (tree_rect f f0 t2)
  
  (** val tree_rec :
      'a2 -> ('a1 tree -> 'a2 -> 'a1 option -> 'a1 tree -> 'a2 -> 'a2) -> 'a1
      tree -> 'a2 **)
  
  let rec tree_rec f f0 = function
  | Leaf -> f
  | Node (t1, o, t2) -> f0 t1 (tree_rec f f0 t1) o t2 (tree_rec f f0 t2)
  
  type 'a t = 'a tree
  
  (** val eq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let rec eq eqA a b =
    match a with
    | Leaf ->
      (match b with
       | Leaf -> true
       | Node (t0, o, t1) -> false)
    | Node (t0, o, t1) ->
      (match b with
       | Leaf -> false
       | Node (t2, o0, t3) ->
         if eq eqA t0 t2
         then if match o with
                 | Some x ->
                   (match o0 with
                    | Some a1 -> eqA x a1
                    | None -> false)
                 | None ->
                   (match o0 with
                    | Some a0 -> false
                    | None -> true)
              then eq eqA t1 t3
              else false
         else false)
  
  (** val empty : 'a1 t **)
  
  let empty =
    Leaf
  
  (** val get : Big.big_int -> 'a1 t -> 'a1 option **)
  
  let rec get i = function
  | Leaf -> None
  | Node (l, o, r2) ->
    (Big.positive_case
       (fun ii ->
       get ii r2)
       (fun ii ->
       get ii l)
       (fun _ ->
       o)
       i)
  
  (** val set : Big.big_int -> 'a1 -> 'a1 t -> 'a1 t **)
  
  let rec set i v = function
  | Leaf ->
    (Big.positive_case
       (fun ii -> Node (Leaf, None,
       (set ii v Leaf)))
       (fun ii -> Node ((set ii v Leaf), None,
       Leaf))
       (fun _ -> Node (Leaf, (Some v),
       Leaf))
       i)
  | Node (l, o, r2) ->
    (Big.positive_case
       (fun ii -> Node (l, o,
       (set ii v r2)))
       (fun ii -> Node ((set ii v l), o,
       r2))
       (fun _ -> Node (l, (Some v),
       r2))
       i)
  
  (** val remove : Big.big_int -> 'a1 t -> 'a1 t **)
  
  let rec remove i m =
    Big.positive_case
      (fun ii ->
      match m with
      | Leaf -> Leaf
      | Node (l, o, r2) ->
        (match l with
         | Leaf ->
           (match o with
            | Some a -> Node (l, o, (remove ii r2))
            | None ->
              (match remove ii r2 with
               | Leaf -> Leaf
               | Node (t0, o0, t1) -> Node (Leaf, None, (Node (t0, o0, t1)))))
         | Node (t0, o0, t1) -> Node (l, o, (remove ii r2))))
      (fun ii ->
      match m with
      | Leaf -> Leaf
      | Node (l, o, r2) ->
        (match o with
         | Some a -> Node ((remove ii l), o, r2)
         | None ->
           (match r2 with
            | Leaf ->
              (match remove ii l with
               | Leaf -> Leaf
               | Node (t0, o0, t1) -> Node ((Node (t0, o0, t1)), None, Leaf))
            | Node (t0, o0, t1) -> Node ((remove ii l), o, r2))))
      (fun _ ->
      match m with
      | Leaf -> Leaf
      | Node (l, o, r2) ->
        (match l with
         | Leaf ->
           (match r2 with
            | Leaf -> Leaf
            | Node (t0, o0, t1) -> Node (l, None, r2))
         | Node (t0, o0, t1) -> Node (l, None, r2)))
      i
  
  (** val bempty : 'a1 t -> bool **)
  
  let rec bempty = function
  | Leaf -> true
  | Node (l, o, r2) ->
    (match o with
     | Some a -> false
     | None -> (&&) (bempty l) (bempty r2))
  
  (** val beq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let rec beq beqA m1 m2 =
    match m1 with
    | Leaf -> bempty m2
    | Node (l1, o1, r2) ->
      (match m2 with
       | Leaf -> bempty m1
       | Node (l2, o2, r3) ->
         (&&)
           ((&&)
             (match o1 with
              | Some y1 ->
                (match o2 with
                 | Some y2 -> beqA y1 y2
                 | None -> false)
              | None ->
                (match o2 with
                 | Some a -> false
                 | None -> true)) (beq beqA l1 l2)) (beq beqA r2 r3))
  
  (** val append : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec append i j =
    Big.positive_case
      (fun ii -> Big.doubleplusone
      (append ii j))
      (fun ii -> Big.double
      (append ii j))
      (fun _ ->
      j)
      i
  
  (** val xmap :
      (Big.big_int -> 'a1 -> 'a2) -> 'a1 t -> Big.big_int -> 'a2 t **)
  
  let rec xmap f m i =
    match m with
    | Leaf -> Leaf
    | Node (l, o, r2) ->
      Node ((xmap f l (append i (Big.double Big.one))), (option_map (f i) o),
        (xmap f r2 (append i (Big.doubleplusone Big.one))))
  
  (** val map : (Big.big_int -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m =
    xmap f m Big.one
  
  (** val coq_Node' : 'a1 t -> 'a1 option -> 'a1 t -> 'a1 t **)
  
  let coq_Node' l x r2 =
    match l with
    | Leaf ->
      (match x with
       | Some a -> Node (l, x, r2)
       | None ->
         (match r2 with
          | Leaf -> Leaf
          | Node (t0, o, t1) -> Node (l, x, r2)))
    | Node (t0, o, t1) -> Node (l, x, r2)
  
  (** val xcombine_l :
      ('a1 option -> 'a1 option -> 'a1 option) -> 'a1 t -> 'a1 t **)
  
  let rec xcombine_l f = function
  | Leaf -> Leaf
  | Node (l, o, r2) ->
    coq_Node' (xcombine_l f l) (f o None) (xcombine_l f r2)
  
  (** val xcombine_r :
      ('a1 option -> 'a1 option -> 'a1 option) -> 'a1 t -> 'a1 t **)
  
  let rec xcombine_r f = function
  | Leaf -> Leaf
  | Node (l, o, r2) ->
    coq_Node' (xcombine_r f l) (f None o) (xcombine_r f r2)
  
  (** val combine :
      ('a1 option -> 'a1 option -> 'a1 option) -> 'a1 t -> 'a1 t -> 'a1 t **)
  
  let rec combine f m1 m2 =
    match m1 with
    | Leaf -> xcombine_r f m2
    | Node (l1, o1, r2) ->
      (match m2 with
       | Leaf -> xcombine_l f m1
       | Node (l2, o2, r3) ->
         coq_Node' (combine f l1 l2) (f o1 o2) (combine f r2 r3))
  
  (** val xelements : 'a1 t -> Big.big_int -> (Big.big_int * 'a1) list **)
  
  let rec xelements m i =
    match m with
    | Leaf -> []
    | Node (l, o, r2) ->
      (match o with
       | Some x ->
         app (xelements l (append i (Big.double Big.one))) ((i,
           x) :: (xelements r2 (append i (Big.doubleplusone Big.one))))
       | None ->
         app (xelements l (append i (Big.double Big.one)))
           (xelements r2 (append i (Big.doubleplusone Big.one))))
  
  (** val elements : 'a1 t -> (Big.big_int * 'a1) list **)
  
  let elements m =
    xelements m Big.one
  
  (** val xget : Big.big_int -> Big.big_int -> 'a1 t -> 'a1 option **)
  
  let rec xget i j m =
    Big.positive_case
      (fun ii ->
      Big.positive_case
        (fun jj ->
        xget ii jj m)
        (fun p ->
        None)
        (fun _ ->
        get i m)
        j)
      (fun ii ->
      Big.positive_case
        (fun p ->
        None)
        (fun jj ->
        xget ii jj m)
        (fun _ ->
        get i m)
        j)
      (fun _ ->
      Big.positive_case
        (fun p ->
        None)
        (fun p ->
        None)
        (fun _ ->
        get i m)
        j)
      i
  
  (** val xkeys : 'a1 t -> Big.big_int -> Big.big_int list **)
  
  let xkeys m i =
    Coq__1.map fst (xelements m i)
  
  (** val xfold :
      ('a2 -> Big.big_int -> 'a1 -> 'a2) -> Big.big_int -> 'a1 t -> 'a2 ->
      'a2 **)
  
  let rec xfold f i m v =
    match m with
    | Leaf -> v
    | Node (l, o, r2) ->
      (match o with
       | Some x ->
         let v1 = xfold f (append i (Big.double Big.one)) l v in
         let v2 = f v1 i x in
         xfold f (append i (Big.doubleplusone Big.one)) r2 v2
       | None ->
         let v1 = xfold f (append i (Big.double Big.one)) l v in
         xfold f (append i (Big.doubleplusone Big.one)) r2 v1)
  
  (** val fold :
      ('a2 -> Big.big_int -> 'a1 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 **)
  
  let fold f m v =
    xfold f Big.one m v
 end

module PMap = 
 struct 
  type elt = Big.big_int
  
  (** val elt_eq : Big.big_int -> Big.big_int -> bool **)
  
  let elt_eq =
    peq
  
  type 'a t = 'a * 'a PTree.t
  
  (** val eq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let eq x a b =
    let x0 = PTree.eq x in
    let (x1, x2) = a in
    let (a1, t0) = b in if x x1 a1 then x0 x2 t0 else false
  
  (** val init : 'a1 -> 'a1 * 'a1 PTree.t **)
  
  let init x =
    (x, PTree.empty)
  
  (** val get : Big.big_int -> 'a1 t -> 'a1 **)
  
  let get i m =
    match PTree.get i (snd m) with
    | Some x -> x
    | None -> fst m
  
  (** val set : Big.big_int -> 'a1 -> 'a1 t -> 'a1 * 'a1 PTree.t **)
  
  let set i x m =
    ((fst m), (PTree.set i x (snd m)))
  
  (** val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m =
    ((f (fst m)), (PTree.map (fun x -> f) (snd m)))
 end

module type INDEXED_TYPE = 
 sig 
  type t 
  
  val index : t -> Big.big_int
  
  val eq : t -> t -> bool
 end

module IMap = 
 functor (X:INDEXED_TYPE) ->
 struct 
  type elt = X.t
  
  (** val elt_eq :
      X.t
      ->
      X.t
      ->
      bool **)
  
  let elt_eq =
    X.eq
  
  type 'x t
    =
    'x
    PMap.t
  
  (** val eq :
      ('a1
      ->
      'a1
      ->
      bool)
      ->
      'a1
      t
      ->
      'a1
      t
      ->
      bool **)
  
  let eq x a b =
    PMap.eq
      x
      a
      b
  
  (** val init :
      'a1
      ->
      'a1 * 'a1
      PTree.t **)
  
  let init x =
    PMap.init
      x
  
  (** val get :
      X.t
      ->
      'a1
      t
      ->
      'a1 **)
  
  let get i m =
    PMap.get
      (X.index
        i)
      m
  
  (** val set :
      X.t
      ->
      'a1
      ->
      'a1
      t
      ->
      'a1 * 'a1
      PTree.t **)
  
  let set i v m =
    PMap.set
      (X.index
        i)
      v
      m
  
  (** val map :
      ('a1
      ->
      'a2)
      ->
      'a1
      t
      ->
      'a2
      t **)
  
  let map f m =
    PMap.map
      f
      m
 end

module ZIndexed = 
 struct 
  type t
    =
    Big.big_int
  
  (** val index :
      Big.big_int
      ->
      Big.big_int **)
  
  let index z =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p ->
      Big.double
      p)
      (fun p ->
      Big.doubleplusone
      p)
      z
  
  (** val eq :
      Big.big_int
      ->
      Big.big_int
      ->
      bool **)
  
  let eq =
    zeq
 end

module X86_PARSER = 
 struct 
  (** val option_t :
      X86_PARSER_ARG.coq_type
      ->
      type0 **)
  
  let option_t x =
    User_t
      (X86_PARSER_ARG.Option_t
      x)
  
  (** val int_t :
      type0 **)
  
  let int_t =
    User_t
      X86_PARSER_ARG.Int_t
  
  (** val register_t :
      type0 **)
  
  let register_t =
    User_t
      X86_PARSER_ARG.Register_t
  
  (** val byte_t :
      type0 **)
  
  let byte_t =
    User_t
      X86_PARSER_ARG.Byte_t
  
  (** val half_t :
      type0 **)
  
  let half_t =
    User_t
      X86_PARSER_ARG.Half_t
  
  (** val word_t :
      type0 **)
  
  let word_t =
    User_t
      X86_PARSER_ARG.Word_t
  
  (** val double_word_t :
      type0 **)
  
  let double_word_t =
    User_t
      X86_PARSER_ARG.Double_Word_t
  
  (** val ten_byte_t :
      type0 **)
  
  let ten_byte_t =
    User_t
      X86_PARSER_ARG.Ten_Byte_t
  
  (** val scale_t :
      type0 **)
  
  let scale_t =
    User_t
      X86_PARSER_ARG.Scale_t
  
  (** val condition_t :
      type0 **)
  
  let condition_t =
    User_t
      X86_PARSER_ARG.Condition_t
  
  (** val fpu_register_t :
      type0 **)
  
  let fpu_register_t =
    User_t
      X86_PARSER_ARG.Fpu_Register_t
  
  (** val fp_debug_register_t :
      type0 **)
  
  let fp_debug_register_t =
    User_t
      X86_PARSER_ARG.Fp_Debug_Register_t
  
  (** val mmx_granularity_t :
      type0 **)
  
  let mmx_granularity_t =
    User_t
      X86_PARSER_ARG.MMX_Granularity_t
  
  (** val mmx_operand_t :
      type0 **)
  
  let mmx_operand_t =
    User_t
      X86_PARSER_ARG.MMX_Operand_t
  
  (** val mmx_register_t :
      type0 **)
  
  let mmx_register_t =
    User_t
      X86_PARSER_ARG.MMX_Register_t
  
  (** val sse_operand_t :
      type0 **)
  
  let sse_operand_t =
    User_t
      X86_PARSER_ARG.SSE_Operand_t
  
  (** val sse_register_t :
      type0 **)
  
  let sse_register_t =
    User_t
      X86_PARSER_ARG.SSE_Register_t
  
  (** val address_t :
      type0 **)
  
  let address_t =
    User_t
      X86_PARSER_ARG.Address_t
  
  (** val operand_t :
      type0 **)
  
  let operand_t =
    User_t
      X86_PARSER_ARG.Operand_t
  
  (** val fp_operand_t :
      type0 **)
  
  let fp_operand_t =
    User_t
      X86_PARSER_ARG.Fp_Operand_t
  
  (** val instruction_t :
      type0 **)
  
  let instruction_t =
    User_t
      X86_PARSER_ARG.Instruction_t
  
  (** val control_register_t :
      type0 **)
  
  let control_register_t =
    User_t
      X86_PARSER_ARG.Control_Register_t
  
  (** val debug_register_t :
      type0 **)
  
  let debug_register_t =
    User_t
      X86_PARSER_ARG.Debug_Register_t
  
  (** val segment_register_t :
      type0 **)
  
  let segment_register_t =
    User_t
      X86_PARSER_ARG.Segment_Register_t
  
  (** val lock_or_rep_t :
      type0 **)
  
  let lock_or_rep_t =
    User_t
      X86_PARSER_ARG.Lock_or_Rep_t
  
  (** val bool_t :
      type0 **)
  
  let bool_t =
    User_t
      X86_PARSER_ARG.Bool_t
  
  (** val prefix_t :
      type0 **)
  
  let prefix_t =
    User_t
      X86_PARSER_ARG.Prefix_t
  
  (** val bit :
      bool
      ->
      grammar **)
  
  let bit x =
    Char
      x
  
  (** val never :
      type0
      ->
      grammar **)
  
  let never t0 =
    Zero
  
  (** val always :
      type0
      ->
      interp
      ->
      grammar **)
  
  let always t0 x =
    Map
      ((fun x0 ->
      x),
      Eps)
  
  (** val alt :
      type0
      ->
      grammar
      ->
      grammar
      ->
      grammar **)
  
  let alt t0 p1 p2 =
    Map
      ((fun x ->
      match Obj.magic
              x with
      | Inl a ->
        a
      | Inr b ->
        b),
      (Alt
      (p1,
      p2)))
  
  (** val alts0 :
      type0
      ->
      grammar
      list
      ->
      grammar **)
  
  let rec alts0 t0 = function
  | [] ->
    never
      t0
  | p :: rest ->
    (match rest with
     | [] ->
       p
     | g :: l ->
       alt
         t0
         p
         (alts0
           t0
           rest))
  
  (** val half :
      'a1
      list
      ->
      'a1
      list
      ->
      'a1
      list
      ->
      'a1
      list * 'a1
      list **)
  
  let rec half xs ys zs =
    match xs with
    | [] ->
      (ys,
        zs)
    | h :: t0 ->
      half
        t0
        zs
        (h :: ys)
  
  (** val alts' :
      Big.big_int
      ->
      type0
      ->
      grammar
      list
      ->
      grammar **)
  
  let rec alts' n t0 ps =
    Big.nat_case
      (fun _ ->
      alts0
        t0
        ps)
      (fun n0 ->
      match ps with
      | [] ->
        never
          t0
      | p :: l ->
        (match l with
         | [] ->
           p
         | g :: l0 ->
           let (ps1,
                ps2) =
             half
               ps
               []
               []
           in
           let g1 =
             alts'
               n0
               t0
               ps1
           in
           let g2 =
             alts'
               n0
               t0
               ps2
           in
           alt
             t0
             g1
             g2))
      n
  
  (** val alts :
      type0
      ->
      grammar
      list
      ->
      grammar **)
  
  let alts t0 ps =
    alts'
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      Big.zero))))))))))))))))))))
      t0
      ps
  
  (** val map :
      type0
      ->
      type0
      ->
      grammar
      ->
      (interp
      ->
      interp)
      ->
      grammar **)
  
  let map t1 t2 p f =
    Map
      (f,
      p)
  
  (** val seq :
      type0
      ->
      type0
      ->
      grammar
      ->
      grammar
      ->
      grammar **)
  
  let seq t1 t2 p1 p2 =
    Cat
      (p1,
      p2)
  
  (** val cons :
      type0
      ->
      (__ * __
      list)
      ->
      __
      list **)
  
  let cons t0 pair =
    (fst
      pair) :: (snd
                 pair)
  
  (** val seqs :
      type0
      ->
      grammar
      list
      ->
      grammar **)
  
  let seqs t0 ps =
    fold_right
      (fun p1 p2 ->
      map
        (Pair_t
        (t0,
        (List_t
        t0)))
        (List_t
        t0)
        (seq
          t0
          (List_t
          t0)
          p1
          p2)
        (Obj.magic
          (cons
            t0)))
      (always
        (List_t
        t0)
        (Obj.magic
          []))
      ps
  
  (** val string_to_bool_list :
      char list
      ->
      bool
      list **)
  
  let rec string_to_bool_list = function
  | [] ->
    []
  | a::s0 ->
    (if (=)
          a
          '0'
     then false
     else true) :: (string_to_bool_list
                     s0)
  
  (** val bits_n :
      Big.big_int
      ->
      type0 **)
  
  let rec bits_n n =
    Big.nat_case
      (fun _ ->
      Unit_t)
      (fun n0 ->
      Pair_t
      (Char_t,
      (bits_n
        n0)))
      n
  
  (** val field' :
      Big.big_int
      ->
      grammar **)
  
  let rec field' n =
    Big.nat_case
      (fun _ ->
      Eps)
      (fun n0 ->
      Cat
      (Any,
      (field'
        n0)))
      n
  
  (** val bits2Z :
      Big.big_int
      ->
      Big.big_int
      ->
      interp
      ->
      interp **)
  
  let rec bits2Z n a x =
    Big.nat_case
      (fun _ ->
      Obj.magic
        a)
      (fun n0 ->
      bits2Z
        n0
        (Z.add
          (Z.mul
            (Big.double
            Big.one)
            a)
          (if fst
                (Obj.magic
                  x)
           then Big.one
           else Big.zero))
        (snd
          (Obj.magic
            x)))
      n
  
  (** val bits2int :
      Big.big_int
      ->
      interp
      ->
      interp **)
  
  let bits2int n bs =
    bits2Z
      n
      Big.zero
      bs
  
  (** val bits :
      char list
      ->
      grammar **)
  
  let rec bits = function
  | [] ->
    Eps
  | c::s ->
    Cat
      ((Char
      (if (=)
            c
            '0'
       then false
       else true)),
      (bits
        s))
  
  (** val bitsleft :
      type0
      ->
      char list
      ->
      grammar
      ->
      grammar **)
  
  let bitsleft t0 s p =
    map
      (Pair_t
      ((bits_n
         (length0
           s)),
      t0))
      t0
      (seq
        (bits_n
          (length0
            s))
        t0
        (bits
          s)
        p)
      (Obj.magic
        snd)
  
  (** val anybit :
      grammar **)
  
  let anybit =
    Any
  
  (** val field :
      Big.big_int
      ->
      grammar **)
  
  let field n =
    map
      (bits_n
        n)
      int_t
      (field'
        n)
      (bits2int
        n)
  
  (** val reg :
      grammar **)
  
  let reg =
    map
      int_t
      register_t
      (field
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero))))
      (Obj.magic
        z_to_register)
  
  (** val fpu_reg :
      grammar **)
  
  let fpu_reg =
    map
      int_t
      fpu_register_t
      (field
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero))))
      (Obj.magic
        (Word.repr
          (Big.succ
          (Big.succ
          Big.zero))))
  
  (** val mmx_reg :
      grammar **)
  
  let mmx_reg =
    map
      int_t
      mmx_register_t
      (field
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero))))
      (Obj.magic
        z_to_mmx_register)
  
  (** val sse_reg :
      grammar **)
  
  let sse_reg =
    map
      int_t
      sse_register_t
      (field
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero))))
      (Obj.magic
        z_to_sse_register)
  
  (** val byte :
      grammar **)
  
  let byte =
    map
      int_t
      byte_t
      (field
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero)))))))))
      (Obj.magic
        (Word.repr
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))
  
  (** val halfword :
      grammar **)
  
  let halfword =
    map
      (Pair_t
      (byte_t,
      byte_t))
      half_t
      (seq
        byte_t
        byte_t
        byte
        byte)
      (fun p ->
      let b0 =
        Word.repr
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))
          (Word.unsigned
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))
            (fst
              (Obj.magic
                p)))
      in
      let b1 =
        Word.repr
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))
          (Word.unsigned
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))
            (snd
              (Obj.magic
                p)))
      in
      Obj.magic
        (Word.coq_or
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))
          (Word.shl
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))))))))
            b1
            (Word.repr
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              Big.zero)))))))))))))))
              (Big.double
              (Big.double
              (Big.double
              Big.one)))))
          b0))
  
  (** val word :
      grammar **)
  
  let word =
    map
      (Pair_t
      (byte_t,
      (Pair_t
      (byte_t,
      (Pair_t
      (byte_t,
      byte_t))))))
      word_t
      (seq
        byte_t
        (Pair_t
        (byte_t,
        (Pair_t
        (byte_t,
        byte_t))))
        byte
        (seq
          byte_t
          (Pair_t
          (byte_t,
          byte_t))
          byte
          (seq
            byte_t
            byte_t
            byte
            byte)))
      (fun p ->
      let b0 =
        zero_extend8_32
          (fst
            (Obj.magic
              p))
      in
      let b1 =
        zero_extend8_32
          (fst
            (snd
              (Obj.magic
                p)))
      in
      let b2 =
        zero_extend8_32
          (fst
            (snd
              (snd
                (Obj.magic
                  p))))
      in
      let b3 =
        zero_extend8_32
          (snd
            (snd
              (snd
                (Obj.magic
                  p))))
      in
      let w1 =
        Word.shl
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))))))))))))))))))
          b1
          (Word.repr
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))))))))))))))))))))))))
            (Big.double
            (Big.double
            (Big.double
            Big.one))))
      in
      let w2 =
        Word.shl
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))))))))))))))))))
          b2
          (Word.repr
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))))))))))))))))))))))))
            (Big.double
            (Big.double
            (Big.double
            (Big.double
            Big.one)))))
      in
      let w3 =
        Word.shl
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))))))))))))))))))
          b3
          (Word.repr
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))))))))))))))))))))))))
            (Big.double
            (Big.double
            (Big.double
            (Big.doubleplusone
            Big.one)))))
      in
      Obj.magic
        (Word.coq_or
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero)))))))))))))))))))))))))))))))
          w3
          (Word.coq_or
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))))))))))))))))))))))))
            w2
            (Word.coq_or
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              Big.zero)))))))))))))))))))))))))))))))
              w1
              b0))))
  
  (** val scale_p :
      grammar **)
  
  let scale_p =
    map
      int_t
      scale_t
      (field
        (Big.succ
        (Big.succ
        Big.zero)))
      (Obj.magic
        z_to_scale)
  
  (** val tttn :
      grammar **)
  
  let tttn =
    map
      int_t
      condition_t
      (field
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero)))))
      (Obj.magic
        z_to_condition_type)
  
  (** val reg_no_esp :
      grammar **)
  
  let reg_no_esp =
    map
      (bits_n
        (length0
          ('0'::('0'::('0'::[])))))
      register_t
      (alt
        (bits_n
          (length0
            ('0'::('0'::('0'::[])))))
        (bits
          ('0'::('0'::('0'::[]))))
        (alt
          (bits_n
            (length0
              ('0'::('0'::('1'::[])))))
          (bits
            ('0'::('0'::('1'::[]))))
          (alt
            (bits_n
              (length0
                ('0'::('1'::('0'::[])))))
            (bits
              ('0'::('1'::('0'::[]))))
            (alt
              (bits_n
                (length0
                  ('0'::('1'::('1'::[])))))
              (bits
                ('0'::('1'::('1'::[]))))
              (alt
                (bits_n
                  (length0
                    ('1'::('0'::('1'::[])))))
                (bits
                  ('1'::('0'::('1'::[]))))
                (alt
                  (bits_n
                    (length0
                      ('1'::('1'::('0'::[])))))
                  (bits
                    ('1'::('1'::('0'::[]))))
                  (bits
                    ('1'::('1'::('1'::[]))))))))))
      (fun bs ->
      Obj.magic
        (z_to_register
          (Obj.magic
            (bits2int
              (Big.succ
              (Big.succ
              (Big.succ
              Big.zero)))
              bs))))
  
  (** val reg_no_ebp :
      grammar **)
  
  let reg_no_ebp =
    map
      (bits_n
        (length0
          ('0'::('0'::('0'::[])))))
      register_t
      (alt
        (bits_n
          (length0
            ('0'::('0'::('0'::[])))))
        (bits
          ('0'::('0'::('0'::[]))))
        (alt
          (bits_n
            (length0
              ('0'::('0'::('1'::[])))))
          (bits
            ('0'::('0'::('1'::[]))))
          (alt
            (bits_n
              (length0
                ('0'::('1'::('0'::[])))))
            (bits
              ('0'::('1'::('0'::[]))))
            (alt
              (bits_n
                (length0
                  ('0'::('1'::('1'::[])))))
              (bits
                ('0'::('1'::('1'::[]))))
              (alt
                (bits_n
                  (length0
                    ('1'::('0'::('0'::[])))))
                (bits
                  ('1'::('0'::('0'::[]))))
                (alt
                  (bits_n
                    (length0
                      ('1'::('1'::('0'::[])))))
                  (bits
                    ('1'::('1'::('0'::[]))))
                  (bits
                    ('1'::('1'::('1'::[]))))))))))
      (fun bs ->
      Obj.magic
        (z_to_register
          (Obj.magic
            (bits2int
              (Big.succ
              (Big.succ
              (Big.succ
              Big.zero)))
              bs))))
  
  (** val si :
      grammar **)
  
  let si =
    map
      (Pair_t
      (scale_t,
      register_t))
      (option_t
        (X86_PARSER_ARG.UPair_t
        (X86_PARSER_ARG.Scale_t,
        X86_PARSER_ARG.Register_t)))
      (seq
        scale_t
        register_t
        scale_p
        reg)
      (fun p ->
      match snd
              (Obj.magic
                p) with
      | ESP ->
        Obj.magic
          None
      | _ ->
        Obj.magic
          (Some
          p))
  
  (** val sib :
      grammar **)
  
  let sib =
    seq
      (option_t
        (X86_PARSER_ARG.UPair_t
        (X86_PARSER_ARG.Scale_t,
        X86_PARSER_ARG.Register_t)))
      register_t
      si
      reg
  
  (** val rm00 :
      grammar **)
  
  let rm00 =
    alt
      address_t
      (map
        (bits_n
          (length0
            ('0'::('0'::('0'::[])))))
        address_t
        (alt
          (bits_n
            (length0
              ('0'::('0'::('0'::[])))))
          (bits
            ('0'::('0'::('0'::[]))))
          (alt
            (bits_n
              (length0
                ('0'::('0'::('1'::[])))))
            (bits
              ('0'::('0'::('1'::[]))))
            (alt
              (bits_n
                (length0
                  ('0'::('1'::('0'::[])))))
              (bits
                ('0'::('1'::('0'::[]))))
              (alt
                (bits_n
                  (length0
                    ('0'::('1'::('1'::[])))))
                (bits
                  ('0'::('1'::('1'::[]))))
                (alt
                  (bits_n
                    (length0
                      ('1'::('1'::('0'::[])))))
                  (bits
                    ('1'::('1'::('0'::[]))))
                  (bits
                    ('1'::('1'::('1'::[])))))))))
        (fun bs ->
        Obj.magic
          { addrDisp =
          (Word.repr
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))))))))))))))))))))))))
            Big.zero);
          addrBase =
          (Some
          (z_to_register
            (Obj.magic
              (bits2int
                (Big.succ
                (Big.succ
                (Big.succ
                Big.zero)))
                bs))));
          addrIndex =
          None }))
      (alt
        address_t
        (map
          (Pair_t
          ((bits_n
             (length0
               ('1'::('0'::('0'::[]))))),
          (Pair_t
          ((option_t
             (X86_PARSER_ARG.UPair_t
             (X86_PARSER_ARG.Scale_t,
             X86_PARSER_ARG.Register_t))),
          register_t))))
          address_t
          (seq
            (bits_n
              (length0
                ('1'::('0'::('0'::[])))))
            (Pair_t
            ((option_t
               (X86_PARSER_ARG.UPair_t
               (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))),
            register_t))
            (bits
              ('1'::('0'::('0'::[]))))
            (seq
              (option_t
                (X86_PARSER_ARG.UPair_t
                (X86_PARSER_ARG.Scale_t,
                X86_PARSER_ARG.Register_t)))
              register_t
              si
              reg_no_ebp))
          (fun p ->
          let (i,
               i0) =
            Obj.magic
              p
          in
          let (si0,
               base) =
            i0
          in
          Obj.magic
            { addrDisp =
            (Word.repr
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              Big.zero)))))))))))))))))))))))))))))))
              Big.zero);
            addrBase =
            (Some
            base);
            addrIndex =
            si0 }))
        (alt
          address_t
          (map
            (Pair_t
            ((bits_n
               (length0
                 ('1'::('0'::('0'::[]))))),
            (Pair_t
            ((option_t
               (X86_PARSER_ARG.UPair_t
               (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))),
            (Pair_t
            ((bits_n
               (length0
                 ('1'::('0'::('1'::[]))))),
            word_t))))))
            address_t
            (seq
              (bits_n
                (length0
                  ('1'::('0'::('0'::[])))))
              (Pair_t
              ((option_t
                 (X86_PARSER_ARG.UPair_t
                 (X86_PARSER_ARG.Scale_t,
                 X86_PARSER_ARG.Register_t))),
              (Pair_t
              ((bits_n
                 (length0
                   ('1'::('0'::('1'::[]))))),
              word_t))))
              (bits
                ('1'::('0'::('0'::[]))))
              (seq
                (option_t
                  (X86_PARSER_ARG.UPair_t
                  (X86_PARSER_ARG.Scale_t,
                  X86_PARSER_ARG.Register_t)))
                (Pair_t
                ((bits_n
                   (length0
                     ('1'::('0'::('1'::[]))))),
                word_t))
                si
                (seq
                  (bits_n
                    (length0
                      ('1'::('0'::('1'::[])))))
                  word_t
                  (bits
                    ('1'::('0'::('1'::[]))))
                  word)))
            (fun p ->
            let (i,
                 i0) =
              Obj.magic
                p
            in
            let (si0,
                 i1) =
              i0
            in
            let (i2,
                 disp) =
              i1
            in
            Obj.magic
              { addrDisp =
              disp;
              addrBase =
              None;
              addrIndex =
              si0 }))
          (map
            (Pair_t
            ((bits_n
               (length0
                 ('1'::('0'::('1'::[]))))),
            word_t))
            address_t
            (seq
              (bits_n
                (length0
                  ('1'::('0'::('1'::[])))))
              word_t
              (bits
                ('1'::('0'::('1'::[]))))
              word)
            (fun p ->
            let (i,
                 disp) =
              Obj.magic
                p
            in
            Obj.magic
              { addrDisp =
              disp;
              addrBase =
              None;
              addrIndex =
              None }))))
  
  (** val rm01 :
      grammar **)
  
  let rm01 =
    alt
      address_t
      (map
        (Pair_t
        ((bits_n
           (length0
             ('0'::('0'::('0'::[]))))),
        byte_t))
        address_t
        (seq
          (bits_n
            (length0
              ('0'::('0'::('0'::[])))))
          byte_t
          (alt
            (bits_n
              (length0
                ('0'::('0'::('0'::[])))))
            (bits
              ('0'::('0'::('0'::[]))))
            (alt
              (bits_n
                (length0
                  ('0'::('0'::('1'::[])))))
              (bits
                ('0'::('0'::('1'::[]))))
              (alt
                (bits_n
                  (length0
                    ('0'::('1'::('0'::[])))))
                (bits
                  ('0'::('1'::('0'::[]))))
                (alt
                  (bits_n
                    (length0
                      ('0'::('1'::('1'::[])))))
                  (bits
                    ('0'::('1'::('1'::[]))))
                  (alt
                    (bits_n
                      (length0
                        ('1'::('0'::('1'::[])))))
                    (bits
                      ('1'::('0'::('1'::[]))))
                    (alt
                      (bits_n
                        (length0
                          ('1'::('1'::('0'::[])))))
                      (bits
                        ('1'::('1'::('0'::[]))))
                      (bits
                        ('1'::('1'::('1'::[]))))))))))
          byte)
        (fun p ->
        let (bs,
             disp) =
          Obj.magic
            p
        in
        Obj.magic
          { addrDisp =
          (sign_extend8_32
            disp);
          addrBase =
          (Some
          (z_to_register
            (Obj.magic
              (bits2int
                (Big.succ
                (Big.succ
                (Big.succ
                Big.zero)))
                bs))));
          addrIndex =
          None }))
      (map
        (Pair_t
        ((bits_n
           (length0
             ('1'::('0'::('0'::[]))))),
        (Pair_t
        ((Pair_t
        ((option_t
           (X86_PARSER_ARG.UPair_t
           (X86_PARSER_ARG.Scale_t,
           X86_PARSER_ARG.Register_t))),
        register_t)),
        byte_t))))
        address_t
        (seq
          (bits_n
            (length0
              ('1'::('0'::('0'::[])))))
          (Pair_t
          ((Pair_t
          ((option_t
             (X86_PARSER_ARG.UPair_t
             (X86_PARSER_ARG.Scale_t,
             X86_PARSER_ARG.Register_t))),
          register_t)),
          byte_t))
          (bits
            ('1'::('0'::('0'::[]))))
          (seq
            (Pair_t
            ((option_t
               (X86_PARSER_ARG.UPair_t
               (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))),
            register_t))
            byte_t
            sib
            byte))
        (fun p ->
        let (i,
             i0) =
          Obj.magic
            p
        in
        let (i1,
             disp) =
          i0
        in
        let (si0,
             base) =
          i1
        in
        Obj.magic
          { addrDisp =
          (sign_extend8_32
            disp);
          addrBase =
          (Some
          base);
          addrIndex =
          si0 }))
  
  (** val rm10 :
      grammar **)
  
  let rm10 =
    alt
      address_t
      (map
        (Pair_t
        ((bits_n
           (length0
             ('0'::('0'::('0'::[]))))),
        word_t))
        address_t
        (seq
          (bits_n
            (length0
              ('0'::('0'::('0'::[])))))
          word_t
          (alt
            (bits_n
              (length0
                ('0'::('0'::('0'::[])))))
            (bits
              ('0'::('0'::('0'::[]))))
            (alt
              (bits_n
                (length0
                  ('0'::('0'::('1'::[])))))
              (bits
                ('0'::('0'::('1'::[]))))
              (alt
                (bits_n
                  (length0
                    ('0'::('1'::('0'::[])))))
                (bits
                  ('0'::('1'::('0'::[]))))
                (alt
                  (bits_n
                    (length0
                      ('0'::('1'::('1'::[])))))
                  (bits
                    ('0'::('1'::('1'::[]))))
                  (alt
                    (bits_n
                      (length0
                        ('1'::('0'::('1'::[])))))
                    (bits
                      ('1'::('0'::('1'::[]))))
                    (alt
                      (bits_n
                        (length0
                          ('1'::('1'::('0'::[])))))
                      (bits
                        ('1'::('1'::('0'::[]))))
                      (bits
                        ('1'::('1'::('1'::[]))))))))))
          word)
        (fun p ->
        let (bs,
             disp) =
          Obj.magic
            p
        in
        Obj.magic
          { addrDisp =
          disp;
          addrBase =
          (Some
          (z_to_register
            (Obj.magic
              (bits2int
                (Big.succ
                (Big.succ
                (Big.succ
                Big.zero)))
                bs))));
          addrIndex =
          None }))
      (map
        (Pair_t
        ((bits_n
           (length0
             ('1'::('0'::('0'::[]))))),
        (Pair_t
        ((Pair_t
        ((option_t
           (X86_PARSER_ARG.UPair_t
           (X86_PARSER_ARG.Scale_t,
           X86_PARSER_ARG.Register_t))),
        register_t)),
        word_t))))
        address_t
        (seq
          (bits_n
            (length0
              ('1'::('0'::('0'::[])))))
          (Pair_t
          ((Pair_t
          ((option_t
             (X86_PARSER_ARG.UPair_t
             (X86_PARSER_ARG.Scale_t,
             X86_PARSER_ARG.Register_t))),
          register_t)),
          word_t))
          (bits
            ('1'::('0'::('0'::[]))))
          (seq
            (Pair_t
            ((option_t
               (X86_PARSER_ARG.UPair_t
               (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))),
            register_t))
            word_t
            sib
            word))
        (fun p ->
        let (i,
             i0) =
          Obj.magic
            p
        in
        let (i1,
             disp) =
          i0
        in
        let (si0,
             base) =
          i1
        in
        Obj.magic
          { addrDisp =
          disp;
          addrBase =
          (Some
          base);
          addrIndex =
          si0 }))
  
  (** val modrm_gen :
      type0
      ->
      grammar
      ->
      (address
      ->
      interp)
      ->
      grammar **)
  
  let modrm_gen res_t reg_p addr_op =
    alt
      (Pair_t
      (res_t,
      res_t))
      (map
        (Pair_t
        (res_t,
        address_t))
        (Pair_t
        (res_t,
        res_t))
        (alt
          (Pair_t
          (res_t,
          address_t))
          (bitsleft
            (Pair_t
            (res_t,
            address_t))
            ('0'::('0'::[]))
            (seq
              res_t
              address_t
              reg_p
              rm00))
          (alt
            (Pair_t
            (res_t,
            address_t))
            (bitsleft
              (Pair_t
              (res_t,
              address_t))
              ('0'::('1'::[]))
              (seq
                res_t
                address_t
                reg_p
                rm01))
            (bitsleft
              (Pair_t
              (res_t,
              address_t))
              ('1'::('0'::[]))
              (seq
                res_t
                address_t
                reg_p
                rm10))))
        (fun p ->
        let (op1,
             addr) =
          Obj.magic
            p
        in
        Obj.magic
          (op1,
          (addr_op
            addr))))
      (map
        (Pair_t
        (res_t,
        res_t))
        (Pair_t
        (res_t,
        res_t))
        (bitsleft
          (Pair_t
          (res_t,
          res_t))
          ('1'::('1'::[]))
          (seq
            res_t
            res_t
            reg_p
            reg_p))
        (fun p ->
        let (op1,
             op2) =
          Obj.magic
            p
        in
        Obj.magic
          (op1,
          op2)))
  
  (** val reg_op :
      grammar **)
  
  let reg_op =
    map
      register_t
      operand_t
      reg
      (fun x ->
      Obj.magic
        (Reg_op
        (Obj.magic
          x)))
  
  (** val modrm :
      grammar **)
  
  let modrm =
    modrm_gen
      operand_t
      reg_op
      (Obj.magic
        (fun x ->
        Address_op
        x))
  
  (** val mmx_reg_op :
      grammar **)
  
  let mmx_reg_op =
    map
      mmx_register_t
      mmx_operand_t
      mmx_reg
      (fun r2 ->
      Obj.magic
        (MMX_Reg_op
        (Obj.magic
          r2)))
  
  (** val modrm_mmx :
      grammar **)
  
  let modrm_mmx =
    modrm_gen
      mmx_operand_t
      mmx_reg_op
      (Obj.magic
        (fun x ->
        MMX_Addr_op
        x))
  
  (** val sse_reg_op :
      grammar **)
  
  let sse_reg_op =
    map
      sse_register_t
      sse_operand_t
      sse_reg
      (fun r2 ->
      Obj.magic
        (SSE_XMM_Reg_op
        (Obj.magic
          r2)))
  
  (** val modrm_xmm :
      grammar **)
  
  let modrm_xmm =
    modrm_gen
      sse_operand_t
      sse_reg_op
      (Obj.magic
        (fun x ->
        SSE_Addr_op
        x))
  
  (** val modrm_mm :
      grammar **)
  
  let modrm_mm =
    modrm_gen
      sse_operand_t
      (map
        mmx_register_t
        sse_operand_t
        mmx_reg
        (fun r2 ->
        Obj.magic
          (SSE_MM_Reg_op
          (Obj.magic
            r2))))
      (Obj.magic
        (fun x ->
        SSE_Addr_op
        x))
  
  (** val modrm_gen_noreg :
      type0
      ->
      type0
      ->
      grammar
      ->
      (address
      ->
      interp)
      ->
      grammar **)
  
  let modrm_gen_noreg reg_t res_t reg_p addr_op =
    map
      (Pair_t
      (reg_t,
      address_t))
      (Pair_t
      (reg_t,
      res_t))
      (alt
        (Pair_t
        (reg_t,
        address_t))
        (bitsleft
          (Pair_t
          (reg_t,
          address_t))
          ('0'::('0'::[]))
          (seq
            reg_t
            address_t
            reg_p
            rm00))
        (alt
          (Pair_t
          (reg_t,
          address_t))
          (bitsleft
            (Pair_t
            (reg_t,
            address_t))
            ('0'::('1'::[]))
            (seq
              reg_t
              address_t
              reg_p
              rm01))
          (bitsleft
            (Pair_t
            (reg_t,
            address_t))
            ('1'::('0'::[]))
            (seq
              reg_t
              address_t
              reg_p
              rm10))))
      (fun p ->
      let (op1,
           addr) =
        Obj.magic
          p
      in
      Obj.magic
        (op1,
        (addr_op
          addr)))
  
  (** val modrm_noreg :
      grammar **)
  
  let modrm_noreg =
    modrm_gen_noreg
      register_t
      operand_t
      reg
      (Obj.magic
        (fun x ->
        Address_op
        x))
  
  (** val modrm_xmm_noreg :
      grammar **)
  
  let modrm_xmm_noreg =
    modrm_gen_noreg
      sse_operand_t
      sse_operand_t
      sse_reg_op
      (Obj.magic
        (fun x ->
        SSE_Addr_op
        x))
  
  (** val modrm_xmm_gp_noreg :
      grammar **)
  
  let modrm_xmm_gp_noreg =
    modrm_gen_noreg
      sse_operand_t
      sse_operand_t
      (map
        register_t
        sse_operand_t
        reg
        (fun r2 ->
        Obj.magic
          (SSE_GP_Reg_op
          (Obj.magic
            r2))))
      (Obj.magic
        (fun x ->
        SSE_Addr_op
        x))
  
  (** val modrm_mm_noreg :
      grammar **)
  
  let modrm_mm_noreg =
    modrm_gen_noreg
      sse_operand_t
      sse_operand_t
      (map
        mmx_register_t
        sse_operand_t
        mmx_reg
        (fun r2 ->
        Obj.magic
          (SSE_MM_Reg_op
          (Obj.magic
            r2))))
      (Obj.magic
        (fun x ->
        SSE_Addr_op
        x))
  
  (** val ext_op_modrm_gen :
      type0
      ->
      (address
      ->
      interp)
      ->
      char list
      ->
      grammar **)
  
  let ext_op_modrm_gen res_t addr_op bs =
    map
      (Pair_t
      ((bits_n
         (length0
           ('0'::('0'::[])))),
      (Pair_t
      ((bits_n
         (length0
           bs)),
      address_t))))
      res_t
      (alt
        (Pair_t
        ((bits_n
           (length0
             ('0'::('0'::[])))),
        (Pair_t
        ((bits_n
           (length0
             bs)),
        address_t))))
        (seq
          (bits_n
            (length0
              ('0'::('0'::[]))))
          (Pair_t
          ((bits_n
             (length0
               bs)),
          address_t))
          (bits
            ('0'::('0'::[])))
          (seq
            (bits_n
              (length0
                bs))
            address_t
            (bits
              bs)
            rm00))
        (alt
          (Pair_t
          ((bits_n
             (length0
               ('0'::('1'::[])))),
          (Pair_t
          ((bits_n
             (length0
               bs)),
          address_t))))
          (seq
            (bits_n
              (length0
                ('0'::('1'::[]))))
            (Pair_t
            ((bits_n
               (length0
                 bs)),
            address_t))
            (bits
              ('0'::('1'::[])))
            (seq
              (bits_n
                (length0
                  bs))
              address_t
              (bits
                bs)
              rm01))
          (seq
            (bits_n
              (length0
                ('1'::('0'::[]))))
            (Pair_t
            ((bits_n
               (length0
                 bs)),
            address_t))
            (bits
              ('1'::('0'::[])))
            (seq
              (bits_n
                (length0
                  bs))
              address_t
              (bits
                bs)
              rm10))))
      (fun p ->
      let (i,
           i0) =
        Obj.magic
          p
      in
      let (i1,
           addr) =
        i0
      in
      addr_op
        addr)
  
  (** val ext_op_modrm :
      char list
      ->
      grammar **)
  
  let ext_op_modrm =
    ext_op_modrm_gen
      operand_t
      (Obj.magic
        (fun x ->
        Address_op
        x))
  
  (** val ext_op_modrm_sse :
      char list
      ->
      grammar **)
  
  let ext_op_modrm_sse =
    ext_op_modrm_gen
      sse_operand_t
      (Obj.magic
        (fun x ->
        SSE_Addr_op
        x))
  
  (** val ext_op_modrm_FPM16 :
      char list
      ->
      grammar **)
  
  let ext_op_modrm_FPM16 =
    ext_op_modrm_gen
      fp_operand_t
      (Obj.magic
        (fun x ->
        FPM16_op
        x))
  
  (** val ext_op_modrm_FPM32 :
      char list
      ->
      grammar **)
  
  let ext_op_modrm_FPM32 =
    ext_op_modrm_gen
      fp_operand_t
      (Obj.magic
        (fun x ->
        FPM32_op
        x))
  
  (** val ext_op_modrm_FPM64 :
      char list
      ->
      grammar **)
  
  let ext_op_modrm_FPM64 =
    ext_op_modrm_gen
      fp_operand_t
      (Obj.magic
        (fun x ->
        FPM64_op
        x))
  
  (** val ext_op_modrm_FPM80 :
      char list
      ->
      grammar **)
  
  let ext_op_modrm_FPM80 =
    ext_op_modrm_gen
      fp_operand_t
      (Obj.magic
        (fun x ->
        FPM80_op
        x))
  
  (** val ext_op_modrm2_gen :
      type0
      ->
      grammar
      ->
      (address
      ->
      interp)
      ->
      char list
      ->
      grammar **)
  
  let ext_op_modrm2_gen res_t reg_p addr_op bs =
    alt
      res_t
      (map
        (Pair_t
        ((bits_n
           (length0
             ('0'::('0'::[])))),
        (Pair_t
        ((bits_n
           (length0
             bs)),
        address_t))))
        res_t
        (alt
          (Pair_t
          ((bits_n
             (length0
               ('0'::('0'::[])))),
          (Pair_t
          ((bits_n
             (length0
               bs)),
          address_t))))
          (seq
            (bits_n
              (length0
                ('0'::('0'::[]))))
            (Pair_t
            ((bits_n
               (length0
                 bs)),
            address_t))
            (bits
              ('0'::('0'::[])))
            (seq
              (bits_n
                (length0
                  bs))
              address_t
              (bits
                bs)
              rm00))
          (alt
            (Pair_t
            ((bits_n
               (length0
                 ('0'::('1'::[])))),
            (Pair_t
            ((bits_n
               (length0
                 bs)),
            address_t))))
            (seq
              (bits_n
                (length0
                  ('0'::('1'::[]))))
              (Pair_t
              ((bits_n
                 (length0
                   bs)),
              address_t))
              (bits
                ('0'::('1'::[])))
              (seq
                (bits_n
                  (length0
                    bs))
                address_t
                (bits
                  bs)
                rm01))
            (seq
              (bits_n
                (length0
                  ('1'::('0'::[]))))
              (Pair_t
              ((bits_n
                 (length0
                   bs)),
              address_t))
              (bits
                ('1'::('0'::[])))
              (seq
                (bits_n
                  (length0
                    bs))
                address_t
                (bits
                  bs)
                rm10))))
        (fun p ->
        let (i,
             i0) =
          Obj.magic
            p
        in
        let (i1,
             addr) =
          i0
        in
        addr_op
          addr))
      (map
        (Pair_t
        ((bits_n
           (length0
             bs)),
        res_t))
        res_t
        (bitsleft
          (Pair_t
          ((bits_n
             (length0
               bs)),
          res_t))
          ('1'::('1'::[]))
          (seq
            (bits_n
              (length0
                bs))
            res_t
            (bits
              bs)
            reg_p))
        (fun p ->
        let (i,
             op) =
          Obj.magic
            p
        in
        op))
  
  (** val ext_op_modrm2 :
      char list
      ->
      grammar **)
  
  let ext_op_modrm2 =
    ext_op_modrm2_gen
      operand_t
      reg_op
      (Obj.magic
        (fun x ->
        Address_op
        x))
  
  (** val coq_AAA_p :
      grammar **)
  
  let coq_AAA_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('1'::('1'::('0'::('1'::('1'::('1'::[]))))))))))
      instruction_t
      (bits
        ('0'::('0'::('1'::('1'::('0'::('1'::('1'::('1'::[])))))))))
      (fun x ->
      Obj.magic
        AAA)
  
  (** val coq_AAD_p :
      grammar **)
  
  let coq_AAD_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[]))))))))))))))))))
      instruction_t
      (bits
        ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[])))))))))))))))))
      (fun x ->
      Obj.magic
        AAD)
  
  (** val coq_AAM_p :
      grammar **)
  
  let coq_AAM_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[]))))))))))))))))))
      instruction_t
      (bits
        ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[])))))))))))))))))
      (fun x ->
      Obj.magic
        AAM)
  
  (** val coq_AAS_p :
      grammar **)
  
  let coq_AAS_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))))
      instruction_t
      (bits
        ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[])))))))))
      (fun x ->
      Obj.magic
        AAS)
  
  (** val imm_op :
      bool
      ->
      grammar **)
  
  let imm_op = function
  | true ->
    map
      half_t
      operand_t
      halfword
      (fun w ->
      Obj.magic
        (Imm_op
        (sign_extend16_32
          (Obj.magic
            w))))
  | false ->
    map
      word_t
      operand_t
      word
      (fun w ->
      Obj.magic
        (Imm_op
        (Obj.magic
          w)))
  
  (** val logic_or_arith_p :
      bool
      ->
      char list
      ->
      char list
      ->
      (bool
      ->
      operand
      ->
      operand
      ->
      instr)
      ->
      grammar **)
  
  let logic_or_arith_p opsize_override op1 op2 instCon =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        (Pair_t
        (Char_t,
        (Pair_t
        (operand_t,
        operand_t))))))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          operand_t))))))
          op1
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            operand_t))))))
            ('0'::[])
            (seq
              Char_t
              (Pair_t
              (Char_t,
              (Pair_t
              (operand_t,
              operand_t))))
              anybit
              (seq
                Char_t
                (Pair_t
                (operand_t,
                operand_t))
                anybit
                modrm))))
        (fun p ->
        let (d,
             i) =
          Obj.magic
            p
        in
        let (w,
             i0) =
          i
        in
        let (op3,
             op4) =
          i0
        in
        if d
        then Obj.magic
               instCon
               w
               op3
               op4
        else Obj.magic
               instCon
               w
               op4
               op3))
      (alt
        instruction_t
        (map
          (Pair_t
          (register_t,
          byte_t))
          instruction_t
          (bitsleft
            (Pair_t
            (register_t,
            byte_t))
            ('1'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (register_t,
              byte_t))
              ('0'::('0'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (register_t,
                byte_t))
                ('1'::('1'::[]))
                (bitsleft
                  (Pair_t
                  (register_t,
                  byte_t))
                  op2
                  (seq
                    register_t
                    byte_t
                    reg
                    byte)))))
          (fun p ->
          let (r2,
               imm) =
            Obj.magic
              p
          in
          Obj.magic
            instCon
            true
            (Reg_op
            r2)
            (Imm_op
            (sign_extend8_32
              imm))))
        (alt
          instruction_t
          (map
            (Pair_t
            (register_t,
            byte_t))
            instruction_t
            (bitsleft
              (Pair_t
              (register_t,
              byte_t))
              ('1'::('0'::('0'::('0'::[]))))
              (bitsleft
                (Pair_t
                (register_t,
                byte_t))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (register_t,
                  byte_t))
                  ('1'::('1'::[]))
                  (bitsleft
                    (Pair_t
                    (register_t,
                    byte_t))
                    op2
                    (seq
                      register_t
                      byte_t
                      reg
                      byte)))))
            (fun p ->
            let (r2,
                 imm) =
              Obj.magic
                p
            in
            Obj.magic
              instCon
              false
              (Reg_op
              r2)
              (Imm_op
              (zero_extend8_32
                imm))))
          (alt
            instruction_t
            (map
              (Pair_t
              (register_t,
              operand_t))
              instruction_t
              (bitsleft
                (Pair_t
                (register_t,
                operand_t))
                ('1'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (register_t,
                  operand_t))
                  ('0'::('0'::('0'::('1'::[]))))
                  (bitsleft
                    (Pair_t
                    (register_t,
                    operand_t))
                    ('1'::('1'::[]))
                    (bitsleft
                      (Pair_t
                      (register_t,
                      operand_t))
                      op2
                      (seq
                        register_t
                        operand_t
                        reg
                        (imm_op
                          opsize_override))))))
              (fun p ->
              let (r2,
                   imm) =
                Obj.magic
                  p
              in
              Obj.magic
                instCon
                true
                (Reg_op
                r2)
                imm))
            (alt
              instruction_t
              (map
                byte_t
                instruction_t
                (bitsleft
                  byte_t
                  op1
                  (bitsleft
                    byte_t
                    ('1'::('0'::('0'::[])))
                    byte))
                (fun imm ->
                Obj.magic
                  instCon
                  false
                  (Reg_op
                  EAX)
                  (Imm_op
                  (zero_extend8_32
                    (Obj.magic
                      imm)))))
              (alt
                instruction_t
                (map
                  operand_t
                  instruction_t
                  (bitsleft
                    operand_t
                    op1
                    (bitsleft
                      operand_t
                      ('1'::('0'::('1'::[])))
                      (imm_op
                        opsize_override)))
                  (fun imm ->
                  Obj.magic
                    instCon
                    true
                    (Reg_op
                    EAX)
                    imm))
                (alt
                  instruction_t
                  (map
                    (Pair_t
                    (operand_t,
                    byte_t))
                    instruction_t
                    (bitsleft
                      (Pair_t
                      (operand_t,
                      byte_t))
                      ('1'::('0'::('0'::('0'::[]))))
                      (bitsleft
                        (Pair_t
                        (operand_t,
                        byte_t))
                        ('0'::('0'::('0'::('0'::[]))))
                        (seq
                          operand_t
                          byte_t
                          (ext_op_modrm
                            op2)
                          byte)))
                    (fun p ->
                    let (op,
                         imm) =
                      Obj.magic
                        p
                    in
                    Obj.magic
                      instCon
                      false
                      op
                      (Imm_op
                      (zero_extend8_32
                        imm))))
                  (alt
                    instruction_t
                    (map
                      (Pair_t
                      (operand_t,
                      byte_t))
                      instruction_t
                      (bitsleft
                        (Pair_t
                        (operand_t,
                        byte_t))
                        ('1'::('0'::('0'::('0'::[]))))
                        (bitsleft
                          (Pair_t
                          (operand_t,
                          byte_t))
                          ('0'::('0'::('1'::('1'::[]))))
                          (seq
                            operand_t
                            byte_t
                            (ext_op_modrm
                              op2)
                            byte)))
                      (fun p ->
                      let (op,
                           imm) =
                        Obj.magic
                          p
                      in
                      Obj.magic
                        instCon
                        true
                        op
                        (Imm_op
                        (sign_extend8_32
                          imm))))
                    (map
                      (Pair_t
                      (operand_t,
                      operand_t))
                      instruction_t
                      (bitsleft
                        (Pair_t
                        (operand_t,
                        operand_t))
                        ('1'::('0'::('0'::('0'::[]))))
                        (bitsleft
                          (Pair_t
                          (operand_t,
                          operand_t))
                          ('0'::('0'::('0'::('1'::[]))))
                          (seq
                            operand_t
                            operand_t
                            (ext_op_modrm
                              op2)
                            (imm_op
                              opsize_override))))
                      (fun p ->
                      let (op,
                           imm) =
                        Obj.magic
                          p
                      in
                      Obj.magic
                        instCon
                        true
                        op
                        imm)))))))))
  
  (** val coq_ADC_p :
      bool
      ->
      grammar **)
  
  let coq_ADC_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('0'::('1'::('0'::[])))))
      ('0'::('1'::('0'::[])))
      (fun x x0 x1 ->
      ADC
      (x,
      x0,
      x1))
  
  (** val coq_ADD_p :
      bool
      ->
      grammar **)
  
  let coq_ADD_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('0'::('0'::('0'::[])))))
      ('0'::('0'::('0'::[])))
      (fun x x0 x1 ->
      ADD
      (x,
      x0,
      x1))
  
  (** val coq_AND_p :
      bool
      ->
      grammar **)
  
  let coq_AND_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('1'::('0'::('0'::[])))))
      ('1'::('0'::('0'::[])))
      (fun x x0 x1 ->
      AND
      (x,
      x0,
      x1))
  
  (** val coq_CMP_p :
      bool
      ->
      grammar **)
  
  let coq_CMP_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('1'::('1'::('1'::[])))))
      ('1'::('1'::('1'::[])))
      (fun x x0 x1 ->
      CMP
      (x,
      x0,
      x1))
  
  (** val coq_OR_p :
      bool
      ->
      grammar **)
  
  let coq_OR_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('0'::('0'::('1'::[])))))
      ('0'::('0'::('1'::[])))
      (fun x x0 x1 ->
      OR
      (x,
      x0,
      x1))
  
  (** val coq_SBB_p :
      bool
      ->
      grammar **)
  
  let coq_SBB_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('0'::('1'::('1'::[])))))
      ('0'::('1'::('1'::[])))
      (fun x x0 x1 ->
      SBB
      (x,
      x0,
      x1))
  
  (** val coq_SUB_p :
      bool
      ->
      grammar **)
  
  let coq_SUB_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('1'::('0'::('1'::[])))))
      ('1'::('0'::('1'::[])))
      (fun x x0 x1 ->
      SUB
      (x,
      x0,
      x1))
  
  (** val coq_XOR_p :
      bool
      ->
      grammar **)
  
  let coq_XOR_p s =
    logic_or_arith_p
      s
      ('0'::('0'::('1'::('1'::('0'::[])))))
      ('1'::('1'::('0'::[])))
      (fun x x0 x1 ->
      XOR
      (x,
      x0,
      x1))
  
  (** val coq_ARPL_p :
      grammar **)
  
  let coq_ARPL_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('1'::('1'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          modrm))
      (fun p ->
      let (op1,
           op2) =
        Obj.magic
          p
      in
      Obj.magic
        (ARPL
        (op1,
        op2)))
  
  (** val coq_BOUND_p :
      grammar **)
  
  let coq_BOUND_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('1'::('1'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('0'::('0'::('1'::('0'::[]))))
          modrm))
      (fun p ->
      let (op1,
           op2) =
        Obj.magic
          p
      in
      Obj.magic
        (BOUND
        (op1,
        op2)))
  
  (** val coq_BSF_p :
      grammar **)
  
  let coq_BSF_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('1'::('1'::('0'::('0'::[]))))
              modrm))))
      (fun p ->
      let (op1,
           op2) =
        Obj.magic
          p
      in
      Obj.magic
        (BSF
        (op1,
        op2)))
  
  (** val coq_BSR_p :
      grammar **)
  
  let coq_BSR_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('1'::('1'::('0'::('1'::[]))))
              modrm))))
      (fun p ->
      let (op1,
           op2) =
        Obj.magic
          p
      in
      Obj.magic
        (BSR
        (op1,
        op2)))
  
  (** val coq_BSWAP_p :
      grammar **)
  
  let coq_BSWAP_p =
    map
      register_t
      instruction_t
      (bitsleft
        register_t
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          register_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            register_t
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft
              register_t
              ('1'::[])
              reg))))
      (fun x ->
      Obj.magic
        (BSWAP
        (Obj.magic
          x)))
  
  (** val bit_test_p :
      char list
      ->
      char list
      ->
      (operand
      ->
      operand
      ->
      instr)
      ->
      grammar **)
  
  let bit_test_p opcode1 opcode2 instr0 =
    alt
      instruction_t
      (map
        (Pair_t
        (register_t,
        byte_t))
        instruction_t
        (bitsleft
          (Pair_t
          (register_t,
          byte_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (register_t,
            byte_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (register_t,
              byte_t))
              ('1'::('0'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (register_t,
                byte_t))
                ('1'::('0'::('1'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (register_t,
                  byte_t))
                  ('1'::('1'::[]))
                  (bitsleft
                    (Pair_t
                    (register_t,
                    byte_t))
                    opcode1
                    (seq
                      register_t
                      byte_t
                      reg
                      byte)))))))
        (fun p ->
        let (r2,
             imm) =
          Obj.magic
            p
        in
        Obj.magic
          instr0
          (Reg_op
          r2)
          (Imm_op
          (zero_extend8_32
            imm))))
      (alt
        instruction_t
        (map
          (Pair_t
          (operand_t,
          byte_t))
          instruction_t
          (bitsleft
            (Pair_t
            (operand_t,
            byte_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              byte_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (operand_t,
                byte_t))
                ('1'::('0'::('1'::('1'::[]))))
                (bitsleft
                  (Pair_t
                  (operand_t,
                  byte_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (seq
                    operand_t
                    byte_t
                    (ext_op_modrm
                      opcode1)
                    byte)))))
          (fun p ->
          let (op1,
               imm) =
            Obj.magic
              p
          in
          Obj.magic
            instr0
            op1
            (Imm_op
            (zero_extend8_32
              imm))))
        (map
          (Pair_t
          (operand_t,
          operand_t))
          instruction_t
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (operand_t,
                operand_t))
                ('1'::('0'::('1'::[])))
                (bitsleft
                  (Pair_t
                  (operand_t,
                  operand_t))
                  opcode2
                  (bitsleft
                    (Pair_t
                    (operand_t,
                    operand_t))
                    ('0'::('1'::('1'::[])))
                    modrm)))))
          (fun p ->
          let (op2,
               op1) =
            Obj.magic
              p
          in
          Obj.magic
            instr0
            op1
            op2)))
  
  (** val coq_BT_p :
      grammar **)
  
  let coq_BT_p =
    bit_test_p
      ('1'::('0'::('0'::[])))
      ('0'::('0'::[]))
      (fun x x0 ->
      BT
      (x,
      x0))
  
  (** val coq_BTC_p :
      grammar **)
  
  let coq_BTC_p =
    bit_test_p
      ('1'::('1'::('1'::[])))
      ('1'::('1'::[]))
      (fun x x0 ->
      BTC
      (x,
      x0))
  
  (** val coq_BTR_p :
      grammar **)
  
  let coq_BTR_p =
    bit_test_p
      ('1'::('1'::('0'::[])))
      ('1'::('0'::[]))
      (fun x x0 ->
      BTR
      (x,
      x0))
  
  (** val coq_BTS_p :
      grammar **)
  
  let coq_BTS_p =
    bit_test_p
      ('1'::('0'::('1'::[])))
      ('0'::('1'::[]))
      (fun x x0 ->
      BTS
      (x,
      x0))
  
  (** val coq_CALL_p :
      grammar **)
  
  let coq_CALL_p =
    alt
      instruction_t
      (map
        word_t
        instruction_t
        (bitsleft
          word_t
          ('1'::('1'::('1'::('0'::[]))))
          (bitsleft
            word_t
            ('1'::('0'::('0'::('0'::[]))))
            word))
        (fun w ->
        Obj.magic
          (CALL
          (true,
          false,
          (Imm_op
          (Obj.magic
            w)),
          None))))
      (alt
        instruction_t
        (map
          operand_t
          instruction_t
          (bitsleft
            operand_t
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              operand_t
              ('1'::('1'::('1'::('1'::[]))))
              (ext_op_modrm2
                ('0'::('1'::('0'::[]))))))
          (fun op ->
          Obj.magic
            (CALL
            (true,
            true,
            (Obj.magic
              op),
            None))))
        (alt
          instruction_t
          (map
            (Pair_t
            (word_t,
            half_t))
            instruction_t
            (bitsleft
              (Pair_t
              (word_t,
              half_t))
              ('1'::('0'::('0'::('1'::[]))))
              (bitsleft
                (Pair_t
                (word_t,
                half_t))
                ('1'::('0'::('1'::('0'::[]))))
                (seq
                  word_t
                  half_t
                  word
                  halfword)))
            (fun p ->
            Obj.magic
              (CALL
              (false,
              true,
              (Imm_op
              (fst
                (Obj.magic
                  p))),
              (Some
              (snd
                (Obj.magic
                  p)))))))
          (map
            operand_t
            instruction_t
            (bitsleft
              operand_t
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                operand_t
                ('1'::('1'::('1'::('1'::[]))))
                (ext_op_modrm2
                  ('0'::('1'::('1'::[]))))))
            (fun op ->
            Obj.magic
              (CALL
              (false,
              true,
              (Obj.magic
                op),
              None))))))
  
  (** val coq_CDQ_p :
      grammar **)
  
  let coq_CDQ_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('0'::('1'::[]))))))
        ('1'::('0'::('0'::('1'::[]))))
        (bits
          ('1'::('0'::('0'::('1'::[]))))))
      (fun x ->
      Obj.magic
        CDQ)
  
  (** val coq_CLC_p :
      grammar **)
  
  let coq_CLC_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[]))))
        (bits
          ('1'::('0'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        CLC)
  
  (** val coq_CLD_p :
      grammar **)
  
  let coq_CLD_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[]))))
        (bits
          ('1'::('1'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        CLD)
  
  (** val coq_CLI_p :
      grammar **)
  
  let coq_CLI_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('1'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('1'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[]))))
        (bits
          ('1'::('0'::('1'::('0'::[]))))))
      (fun x ->
      Obj.magic
        CLI)
  
  (** val coq_CLTS_p :
      grammar **)
  
  let coq_CLTS_p =
    map
      (bits_n
        (length0
          ('0'::('1'::('1'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('1'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('0'::('1'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('0'::('1'::('1'::('0'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits
              ('0'::('1'::('1'::('0'::[]))))))))
      (fun x ->
      Obj.magic
        CLTS)
  
  (** val coq_CMC_p :
      grammar **)
  
  let coq_CMC_p =
    map
      (bits_n
        (length0
          ('0'::('1'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('1'::('0'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[]))))
        (bits
          ('0'::('1'::('0'::('1'::[]))))))
      (fun x ->
      Obj.magic
        CMC)
  
  (** val coq_CMPS_p :
      grammar **)
  
  let coq_CMPS_p =
    map
      Char_t
      instruction_t
      (bitsleft
        Char_t
        ('1'::('0'::('1'::('0'::[]))))
        (bitsleft
          Char_t
          ('0'::('1'::('1'::[])))
          anybit))
      (fun x ->
      Obj.magic
        (CMPS
        (Obj.magic
          x)))
  
  (** val coq_CMPXCHG_p :
      grammar **)
  
  let coq_CMPXCHG_p =
    map
      (Pair_t
      (Char_t,
      (Pair_t
      (operand_t,
      operand_t))))
      instruction_t
      (bitsleft
        (Pair_t
        (Char_t,
        (Pair_t
        (operand_t,
        operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            operand_t))))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              (Pair_t
              (operand_t,
              operand_t))))
              ('0'::('0'::('0'::[])))
              (seq
                Char_t
                (Pair_t
                (operand_t,
                operand_t))
                anybit
                modrm)))))
      (fun p ->
      let (w,
           i) =
        Obj.magic
          p
      in
      let (op1,
           op2) =
        i
      in
      Obj.magic
        (CMPXCHG
        (w,
        op2,
        op1)))
  
  (** val coq_CPUID_p :
      grammar **)
  
  let coq_CPUID_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('1'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('0'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('0'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('0'::('0'::('1'::('0'::[]))))))
            ('1'::('0'::('1'::('0'::[]))))
            (bits
              ('0'::('0'::('1'::('0'::[]))))))))
      (fun x ->
      Obj.magic
        CPUID)
  
  (** val coq_CWDE_p :
      grammar **)
  
  let coq_CWDE_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('0'::('0'::[]))))))
        ('1'::('0'::('0'::('1'::[]))))
        (bits
          ('1'::('0'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        CWDE)
  
  (** val coq_DAA_p :
      grammar **)
  
  let coq_DAA_p =
    map
      (bits_n
        (length0
          ('0'::('1'::('1'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('1'::('1'::('1'::[]))))))
        ('0'::('0'::('1'::('0'::[]))))
        (bits
          ('0'::('1'::('1'::('1'::[]))))))
      (fun x ->
      Obj.magic
        DAA)
  
  (** val coq_DAS_p :
      grammar **)
  
  let coq_DAS_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('1'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('1'::('1'::[]))))))
        ('0'::('0'::('1'::('0'::[]))))
        (bits
          ('1'::('1'::('1'::('1'::[]))))))
      (fun x ->
      Obj.magic
        DAS)
  
  (** val coq_DEC_p :
      grammar **)
  
  let coq_DEC_p =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            register_t))
            ('1'::('1'::('1'::[])))
            (seq
              Char_t
              register_t
              anybit
              (bitsleft
                register_t
                ('1'::('1'::('0'::('0'::('1'::[])))))
                reg))))
        (fun p ->
        let (w,
             r2) =
          Obj.magic
            p
        in
        Obj.magic
          (DEC
          (w,
          (Reg_op
          r2)))))
      (alt
        instruction_t
        (map
          register_t
          instruction_t
          (bitsleft
            register_t
            ('0'::('1'::('0'::('0'::[]))))
            (bitsleft
              register_t
              ('1'::[])
              reg))
          (fun r2 ->
          Obj.magic
            (DEC
            (true,
            (Reg_op
            (Obj.magic
              r2))))))
        (map
          (Pair_t
          (Char_t,
          operand_t))
          instruction_t
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              operand_t))
              ('1'::('1'::('1'::[])))
              (seq
                Char_t
                operand_t
                anybit
                (ext_op_modrm
                  ('0'::('0'::('1'::[])))))))
          (fun p ->
          let (w,
               op1) =
            Obj.magic
              p
          in
          Obj.magic
            (DEC
            (w,
            op1)))))
  
  (** val coq_DIV_p :
      grammar **)
  
  let coq_DIV_p =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            register_t))
            ('0'::('1'::('1'::[])))
            (seq
              Char_t
              register_t
              anybit
              (bitsleft
                register_t
                ('1'::('1'::('1'::('1'::('0'::[])))))
                reg))))
        (fun p ->
        let (w,
             r2) =
          Obj.magic
            p
        in
        Obj.magic
          (DIV
          (w,
          (Reg_op
          r2)))))
      (map
        (Pair_t
        (Char_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('0'::('1'::('1'::[])))
            (seq
              Char_t
              operand_t
              anybit
              (ext_op_modrm
                ('1'::('1'::('0'::[])))))))
        (fun p ->
        let (w,
             op1) =
          Obj.magic
            p
        in
        Obj.magic
          (DIV
          (w,
          op1))))
  
  (** val coq_HLT_p :
      grammar **)
  
  let coq_HLT_p =
    map
      (bits_n
        (length0
          ('0'::('1'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[]))))
        (bits
          ('0'::('1'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        HLT)
  
  (** val coq_IDIV_p :
      grammar **)
  
  let coq_IDIV_p =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            register_t))
            ('0'::('1'::('1'::[])))
            (seq
              Char_t
              register_t
              anybit
              (bitsleft
                register_t
                ('1'::('1'::('1'::('1'::('1'::[])))))
                reg))))
        (fun p ->
        let (w,
             r2) =
          Obj.magic
            p
        in
        Obj.magic
          (IDIV
          (w,
          (Reg_op
          r2)))))
      (map
        (Pair_t
        (Char_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('0'::('1'::('1'::[])))
            (seq
              Char_t
              operand_t
              anybit
              (ext_op_modrm
                ('1'::('1'::('1'::[])))))))
        (fun p ->
        let (w,
             op1) =
          Obj.magic
            p
        in
        Obj.magic
          (IDIV
          (w,
          op1))))
  
  (** val coq_IMUL_p :
      bool
      ->
      grammar **)
  
  let coq_IMUL_p opsize_override =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('0'::('1'::('1'::[])))
            (seq
              Char_t
              operand_t
              anybit
              (ext_op_modrm2
                ('1'::('0'::('1'::[])))))))
        (fun p ->
        let (w,
             op1) =
          Obj.magic
            p
        in
        Obj.magic
          (IMUL
          (w,
          op1,
          None,
          None))))
      (alt
        instruction_t
        (map
          (Pair_t
          (operand_t,
          operand_t))
          instruction_t
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (operand_t,
                operand_t))
                ('1'::('0'::('1'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (operand_t,
                  operand_t))
                  ('1'::('1'::('1'::('1'::[]))))
                  modrm))))
          (fun p ->
          let (op1,
               op2) =
            Obj.magic
              p
          in
          Obj.magic
            (IMUL
            (false,
            op1,
            (Some
            op2),
            None))))
        (alt
          instruction_t
          (map
            (Pair_t
            ((Pair_t
            (operand_t,
            operand_t)),
            byte_t))
            instruction_t
            (bitsleft
              (Pair_t
              ((Pair_t
              (operand_t,
              operand_t)),
              byte_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft
                (Pair_t
                ((Pair_t
                (operand_t,
                operand_t)),
                byte_t))
                ('1'::('0'::('1'::('1'::[]))))
                (seq
                  (Pair_t
                  (operand_t,
                  operand_t))
                  byte_t
                  modrm
                  byte)))
            (fun p ->
            let (i,
                 imm) =
              Obj.magic
                p
            in
            let (op1,
                 op2) =
              i
            in
            Obj.magic
              (IMUL
              (true,
              op1,
              (Some
              op2),
              (Some
              (sign_extend8_32
                imm))))))
          (if opsize_override
           then map
                  (Pair_t
                  ((Pair_t
                  (operand_t,
                  operand_t)),
                  half_t))
                  instruction_t
                  (bitsleft
                    (Pair_t
                    ((Pair_t
                    (operand_t,
                    operand_t)),
                    half_t))
                    ('0'::('1'::('1'::('0'::[]))))
                    (bitsleft
                      (Pair_t
                      ((Pair_t
                      (operand_t,
                      operand_t)),
                      half_t))
                      ('1'::('0'::('0'::('1'::[]))))
                      (seq
                        (Pair_t
                        (operand_t,
                        operand_t))
                        half_t
                        modrm
                        halfword)))
                  (fun p ->
                  let (i,
                       imm) =
                    Obj.magic
                      p
                  in
                  let (op1,
                       op2) =
                    i
                  in
                  Obj.magic
                    (IMUL
                    (false,
                    op1,
                    (Some
                    op2),
                    (Some
                    (sign_extend16_32
                      imm)))))
           else map
                  (Pair_t
                  ((Pair_t
                  (operand_t,
                  operand_t)),
                  word_t))
                  instruction_t
                  (bitsleft
                    (Pair_t
                    ((Pair_t
                    (operand_t,
                    operand_t)),
                    word_t))
                    ('0'::('1'::('1'::('0'::[]))))
                    (bitsleft
                      (Pair_t
                      ((Pair_t
                      (operand_t,
                      operand_t)),
                      word_t))
                      ('1'::('0'::('0'::('1'::[]))))
                      (seq
                        (Pair_t
                        (operand_t,
                        operand_t))
                        word_t
                        modrm
                        word)))
                  (fun p ->
                  let (i,
                       imm) =
                    Obj.magic
                      p
                  in
                  let (op1,
                       op2) =
                    i
                  in
                  Obj.magic
                    (IMUL
                    (true,
                    op1,
                    (Some
                    op2),
                    (Some
                    imm)))))))
  
  (** val coq_IN_p :
      grammar **)
  
  let coq_IN_p =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        byte_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          byte_t))
          ('1'::('1'::('1'::('0'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            byte_t))
            ('0'::('1'::('0'::[])))
            (seq
              Char_t
              byte_t
              anybit
              byte)))
        (fun p ->
        let (w,
             pt) =
          Obj.magic
            p
        in
        Obj.magic
          (IN
          (w,
          (Some
          pt)))))
      (map
        Char_t
        instruction_t
        (bitsleft
          Char_t
          ('1'::('1'::('1'::('0'::[]))))
          (bitsleft
            Char_t
            ('1'::('1'::('0'::[])))
            anybit))
        (fun w ->
        Obj.magic
          (IN
          ((Obj.magic
             w),
          None))))
  
  (** val coq_INC_p :
      grammar **)
  
  let coq_INC_p =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            register_t))
            ('1'::('1'::('1'::[])))
            (seq
              Char_t
              register_t
              anybit
              (bitsleft
                register_t
                ('1'::('1'::('0'::('0'::('0'::[])))))
                reg))))
        (fun p ->
        let (w,
             r2) =
          Obj.magic
            p
        in
        Obj.magic
          (INC
          (w,
          (Reg_op
          r2)))))
      (alt
        instruction_t
        (map
          register_t
          instruction_t
          (bitsleft
            register_t
            ('0'::('1'::('0'::('0'::[]))))
            (bitsleft
              register_t
              ('0'::[])
              reg))
          (fun r2 ->
          Obj.magic
            (INC
            (true,
            (Reg_op
            (Obj.magic
              r2))))))
        (map
          (Pair_t
          (Char_t,
          operand_t))
          instruction_t
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              operand_t))
              ('1'::('1'::('1'::[])))
              (seq
                Char_t
                operand_t
                anybit
                (ext_op_modrm
                  ('0'::('0'::('0'::[])))))))
          (fun p ->
          let (w,
               op1) =
            Obj.magic
              p
          in
          Obj.magic
            (INC
            (w,
            op1)))))
  
  (** val coq_INS_p :
      grammar **)
  
  let coq_INS_p =
    map
      Char_t
      instruction_t
      (bitsleft
        Char_t
        ('0'::('1'::('1'::('0'::[]))))
        (bitsleft
          Char_t
          ('1'::('1'::('0'::[])))
          anybit))
      (fun x ->
      Obj.magic
        (INS
        (Obj.magic
          x)))
  
  (** val coq_INTn_p :
      grammar **)
  
  let coq_INTn_p =
    map
      byte_t
      instruction_t
      (bitsleft
        byte_t
        ('1'::('1'::('0'::('0'::[]))))
        (bitsleft
          byte_t
          ('1'::('1'::('0'::('1'::[]))))
          byte))
      (fun x ->
      Obj.magic
        (INTn
        (Obj.magic
          x)))
  
  (** val coq_INT_p :
      grammar **)
  
  let coq_INT_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('0'::('0'::[]))))
        (bits
          ('1'::('1'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        INT)
  
  (** val coq_INTO_p :
      grammar **)
  
  let coq_INTO_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('1'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('1'::('0'::[]))))))
        ('1'::('1'::('0'::('0'::[]))))
        (bits
          ('1'::('1'::('1'::('0'::[]))))))
      (fun x ->
      Obj.magic
        INTO)
  
  (** val coq_INVD_p :
      grammar **)
  
  let coq_INVD_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('0'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('1'::('0'::('0'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('1'::('0'::('0'::('0'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits
              ('1'::('0'::('0'::('0'::[]))))))))
      (fun x ->
      Obj.magic
        INVD)
  
  (** val coq_INVLPG_p :
      grammar **)
  
  let coq_INVLPG_p =
    map
      operand_t
      instruction_t
      (bitsleft
        operand_t
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          operand_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            operand_t
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              operand_t
              ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm
                ('1'::('1'::('1'::[]))))))))
      (fun x ->
      Obj.magic
        (INVLPG
        (Obj.magic
          x)))
  
  (** val coq_IRET_p :
      grammar **)
  
  let coq_IRET_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('1'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('1'::('1'::[]))))))
        ('1'::('1'::('0'::('0'::[]))))
        (bits
          ('1'::('1'::('1'::('1'::[]))))))
      (fun x ->
      Obj.magic
        IRET)
  
  (** val coq_Jcc_p :
      grammar **)
  
  let coq_Jcc_p =
    alt
      instruction_t
      (map
        (Pair_t
        (condition_t,
        byte_t))
        instruction_t
        (bitsleft
          (Pair_t
          (condition_t,
          byte_t))
          ('0'::('1'::('1'::('1'::[]))))
          (seq
            condition_t
            byte_t
            tttn
            byte))
        (fun p ->
        let (ct,
             imm) =
          Obj.magic
            p
        in
        Obj.magic
          (Jcc
          (ct,
          (sign_extend8_32
            imm)))))
      (map
        (Pair_t
        (condition_t,
        word_t))
        instruction_t
        (bitsleft
          (Pair_t
          (condition_t,
          word_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (condition_t,
            word_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (condition_t,
              word_t))
              ('1'::('0'::('0'::('0'::[]))))
              (seq
                condition_t
                word_t
                tttn
                word))))
        (fun p ->
        let (ct,
             imm) =
          Obj.magic
            p
        in
        Obj.magic
          (Jcc
          (ct,
          imm))))
  
  (** val coq_JCXZ_p :
      grammar **)
  
  let coq_JCXZ_p =
    map
      byte_t
      instruction_t
      (bitsleft
        byte_t
        ('1'::('1'::('1'::('0'::[]))))
        (bitsleft
          byte_t
          ('0'::('0'::('1'::('1'::[]))))
          byte))
      (fun x ->
      Obj.magic
        (JCXZ
        (Obj.magic
          x)))
  
  (** val coq_JMP_p :
      grammar **)
  
  let coq_JMP_p =
    alt
      instruction_t
      (map
        byte_t
        instruction_t
        (bitsleft
          byte_t
          ('1'::('1'::('1'::('0'::[]))))
          (bitsleft
            byte_t
            ('1'::('0'::('1'::('1'::[]))))
            byte))
        (fun b ->
        Obj.magic
          (JMP
          (true,
          false,
          (Imm_op
          (sign_extend8_32
            (Obj.magic
              b))),
          None))))
      (alt
        instruction_t
        (map
          word_t
          instruction_t
          (bitsleft
            word_t
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft
              word_t
              ('1'::('0'::('0'::('1'::[]))))
              word))
          (fun w ->
          Obj.magic
            (JMP
            (true,
            false,
            (Imm_op
            (Obj.magic
              w)),
            None))))
        (alt
          instruction_t
          (map
            operand_t
            instruction_t
            (bitsleft
              operand_t
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                operand_t
                ('1'::('1'::('1'::('1'::[]))))
                (ext_op_modrm2
                  ('1'::('0'::('0'::[]))))))
            (fun op ->
            Obj.magic
              (JMP
              (true,
              true,
              (Obj.magic
                op),
              None))))
          (alt
            instruction_t
            (map
              (Pair_t
              (word_t,
              half_t))
              instruction_t
              (bitsleft
                (Pair_t
                (word_t,
                half_t))
                ('1'::('1'::('1'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (word_t,
                  half_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (seq
                    word_t
                    half_t
                    word
                    halfword)))
              (fun p ->
              Obj.magic
                (JMP
                (false,
                true,
                (Imm_op
                (fst
                  (Obj.magic
                    p))),
                (Some
                (snd
                  (Obj.magic
                    p)))))))
            (map
              operand_t
              instruction_t
              (bitsleft
                operand_t
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft
                  operand_t
                  ('1'::('1'::('1'::('1'::[]))))
                  (ext_op_modrm2
                    ('1'::('0'::('1'::[]))))))
              (fun op ->
              Obj.magic
                (JMP
                (false,
                true,
                (Obj.magic
                  op),
                None)))))))
  
  (** val coq_LAHF_p :
      grammar **)
  
  let coq_LAHF_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('1'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('1'::('1'::[]))))))
        ('1'::('0'::('0'::('1'::[]))))
        (bits
          ('1'::('1'::('1'::('1'::[]))))))
      (fun x ->
      Obj.magic
        LAHF)
  
  (** val coq_LAR_p :
      grammar **)
  
  let coq_LAR_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              modrm))))
      (fun p ->
      Obj.magic
        (LAR
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LDS_p :
      grammar **)
  
  let coq_LDS_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('1'::('1'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('0'::('1'::('0'::('1'::[]))))
          modrm))
      (fun p ->
      Obj.magic
        (LDS
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LEA_p :
      grammar **)
  
  let coq_LEA_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('1'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('0'::('1'::[]))))
          modrm))
      (fun p ->
      Obj.magic
        (LEA
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LEAVE_p :
      grammar **)
  
  let coq_LEAVE_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('0'::('1'::[]))))))
        ('1'::('1'::('0'::('0'::[]))))
        (bits
          ('1'::('0'::('0'::('1'::[]))))))
      (fun x ->
      Obj.magic
        LEAVE)
  
  (** val coq_LES_p :
      grammar **)
  
  let coq_LES_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('1'::('1'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('0'::('1'::('0'::('0'::[]))))
          modrm))
      (fun p ->
      Obj.magic
        (LES
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LFS_p :
      grammar **)
  
  let coq_LFS_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('1'::('0'::('0'::[]))))
              modrm))))
      (fun p ->
      Obj.magic
        (LFS
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LGDT_p :
      grammar **)
  
  let coq_LGDT_p =
    map
      operand_t
      instruction_t
      (bitsleft
        operand_t
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          operand_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            operand_t
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              operand_t
              ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm
                ('0'::('1'::('0'::[]))))))))
      (fun x ->
      Obj.magic
        (LGDT
        (Obj.magic
          x)))
  
  (** val coq_LGS_p :
      grammar **)
  
  let coq_LGS_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('1'::('0'::('1'::[]))))
              modrm))))
      (fun p ->
      Obj.magic
        (LGS
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LIDT_p :
      grammar **)
  
  let coq_LIDT_p =
    map
      operand_t
      instruction_t
      (bitsleft
        operand_t
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          operand_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            operand_t
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              operand_t
              ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm
                ('0'::('1'::('1'::[]))))))))
      (fun x ->
      Obj.magic
        (LIDT
        (Obj.magic
          x)))
  
  (** val coq_LLDT_p :
      grammar **)
  
  let coq_LLDT_p =
    alt
      instruction_t
      (map
        register_t
        instruction_t
        (bitsleft
          register_t
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            register_t
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              register_t
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft
                register_t
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft
                  register_t
                  ('1'::('1'::[]))
                  (bitsleft
                    register_t
                    ('0'::('1'::('0'::[])))
                    reg))))))
        (fun r2 ->
        Obj.magic
          (LLDT
          (Reg_op
          (Obj.magic
            r2)))))
      (map
        operand_t
        instruction_t
        (bitsleft
          operand_t
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            operand_t
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              operand_t
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft
                operand_t
                ('0'::('0'::('0'::('0'::[]))))
                (ext_op_modrm
                  ('0'::('1'::('0'::[]))))))))
        (fun x ->
        Obj.magic
          (LLDT
          (Obj.magic
            x))))
  
  (** val coq_LMSW_p :
      grammar **)
  
  let coq_LMSW_p =
    alt
      instruction_t
      (map
        register_t
        instruction_t
        (bitsleft
          register_t
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            register_t
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              register_t
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft
                register_t
                ('0'::('0'::('0'::('1'::[]))))
                (bitsleft
                  register_t
                  ('1'::('1'::[]))
                  (bitsleft
                    register_t
                    ('1'::('1'::('0'::[])))
                    reg))))))
        (fun r2 ->
        Obj.magic
          (LMSW
          (Reg_op
          (Obj.magic
            r2)))))
      (map
        operand_t
        instruction_t
        (bitsleft
          operand_t
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            operand_t
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              operand_t
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft
                operand_t
                ('0'::('0'::('0'::('1'::[]))))
                (bitsleft
                  operand_t
                  ('1'::('1'::[]))
                  (ext_op_modrm
                    ('1'::('1'::('0'::[])))))))))
        (fun x ->
        Obj.magic
          (LMSW
          (Obj.magic
            x))))
  
  (** val coq_LODS_p :
      grammar **)
  
  let coq_LODS_p =
    map
      Char_t
      instruction_t
      (bitsleft
        Char_t
        ('1'::('0'::('1'::('0'::[]))))
        (bitsleft
          Char_t
          ('1'::('1'::('0'::[])))
          anybit))
      (fun x ->
      Obj.magic
        (LODS
        (Obj.magic
          x)))
  
  (** val coq_LOOP_p :
      grammar **)
  
  let coq_LOOP_p =
    map
      byte_t
      instruction_t
      (bitsleft
        byte_t
        ('1'::('1'::('1'::('0'::[]))))
        (bitsleft
          byte_t
          ('0'::('0'::('1'::('0'::[]))))
          byte))
      (fun x ->
      Obj.magic
        (LOOP
        (Obj.magic
          x)))
  
  (** val coq_LOOPZ_p :
      grammar **)
  
  let coq_LOOPZ_p =
    map
      byte_t
      instruction_t
      (bitsleft
        byte_t
        ('1'::('1'::('1'::('0'::[]))))
        (bitsleft
          byte_t
          ('0'::('0'::('0'::('1'::[]))))
          byte))
      (fun x ->
      Obj.magic
        (LOOPZ
        (Obj.magic
          x)))
  
  (** val coq_LOOPNZ_p :
      grammar **)
  
  let coq_LOOPNZ_p =
    map
      byte_t
      instruction_t
      (bitsleft
        byte_t
        ('1'::('1'::('1'::('0'::[]))))
        (bitsleft
          byte_t
          ('0'::('0'::('0'::('0'::[]))))
          byte))
      (fun x ->
      Obj.magic
        (LOOPNZ
        (Obj.magic
          x)))
  
  (** val coq_LSL_p :
      grammar **)
  
  let coq_LSL_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('0'::('1'::('1'::[]))))
              modrm))))
      (fun p ->
      Obj.magic
        (LSL
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LSS_p :
      grammar **)
  
  let coq_LSS_p =
    map
      (Pair_t
      (operand_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (operand_t,
        operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              modrm))))
      (fun p ->
      Obj.magic
        (LSS
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_LTR_p :
      grammar **)
  
  let coq_LTR_p =
    map
      operand_t
      instruction_t
      (bitsleft
        operand_t
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          operand_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            operand_t
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              operand_t
              ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2
                ('0'::('1'::('1'::[]))))))))
      (fun x ->
      Obj.magic
        (LTR
        (Obj.magic
          x)))
  
  (** val coq_CMOVcc_p :
      grammar **)
  
  let coq_CMOVcc_p =
    map
      (Pair_t
      (condition_t,
      (Pair_t
      (operand_t,
      operand_t))))
      instruction_t
      (bitsleft
        (Pair_t
        (condition_t,
        (Pair_t
        (operand_t,
        operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (condition_t,
          (Pair_t
          (operand_t,
          operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (condition_t,
            (Pair_t
            (operand_t,
            operand_t))))
            ('0'::('1'::('0'::('0'::[]))))
            (seq
              condition_t
              (Pair_t
              (operand_t,
              operand_t))
              tttn
              modrm))))
      (fun p ->
      let (tttn0,
           i) =
        Obj.magic
          p
      in
      let (op1,
           op2) =
        i
      in
      Obj.magic
        (CMOVcc
        (tttn0,
        op1,
        op2)))
  
  (** val coq_MOV_p :
      bool
      ->
      grammar **)
  
  let coq_MOV_p opsize_override =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        (Pair_t
        (operand_t,
        operand_t))))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          operand_t))))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            operand_t))))
            ('1'::('0'::('1'::[])))
            (seq
              Char_t
              (Pair_t
              (operand_t,
              operand_t))
              anybit
              modrm)))
        (fun p ->
        let (w,
             i) =
          Obj.magic
            p
        in
        let (op1,
             op2) =
          i
        in
        Obj.magic
          (MOV
          (w,
          op1,
          op2))))
      (alt
        instruction_t
        (map
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          operand_t))))
          instruction_t
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            operand_t))))
            ('1'::('0'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              (Pair_t
              (operand_t,
              operand_t))))
              ('1'::('0'::('0'::[])))
              (seq
                Char_t
                (Pair_t
                (operand_t,
                operand_t))
                anybit
                modrm)))
          (fun p ->
          let (w,
               i) =
            Obj.magic
              p
          in
          let (op1,
               op2) =
            i
          in
          Obj.magic
            (MOV
            (w,
            op2,
            op1))))
        (alt
          instruction_t
          (map
            (Pair_t
            (register_t,
            operand_t))
            instruction_t
            (bitsleft
              (Pair_t
              (register_t,
              operand_t))
              ('1'::('1'::('0'::('0'::[]))))
              (bitsleft
                (Pair_t
                (register_t,
                operand_t))
                ('0'::('1'::('1'::('1'::[]))))
                (bitsleft
                  (Pair_t
                  (register_t,
                  operand_t))
                  ('1'::('1'::[]))
                  (bitsleft
                    (Pair_t
                    (register_t,
                    operand_t))
                    ('0'::('0'::('0'::[])))
                    (seq
                      register_t
                      operand_t
                      reg
                      (imm_op
                        opsize_override))))))
            (fun p ->
            let (r2,
                 w) =
              Obj.magic
                p
            in
            Obj.magic
              (MOV
              (true,
              (Reg_op
              r2),
              w))))
          (alt
            instruction_t
            (map
              (Pair_t
              (register_t,
              byte_t))
              instruction_t
              (bitsleft
                (Pair_t
                (register_t,
                byte_t))
                ('1'::('1'::('0'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (register_t,
                  byte_t))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bitsleft
                    (Pair_t
                    (register_t,
                    byte_t))
                    ('1'::('1'::[]))
                    (bitsleft
                      (Pair_t
                      (register_t,
                      byte_t))
                      ('0'::('0'::('0'::[])))
                      (seq
                        register_t
                        byte_t
                        reg
                        byte)))))
              (fun p ->
              let (r2,
                   b) =
                Obj.magic
                  p
              in
              Obj.magic
                (MOV
                (false,
                (Reg_op
                r2),
                (Imm_op
                (zero_extend8_32
                  b))))))
            (alt
              instruction_t
              (map
                (Pair_t
                (register_t,
                operand_t))
                instruction_t
                (bitsleft
                  (Pair_t
                  (register_t,
                  operand_t))
                  ('1'::('0'::('1'::('1'::[]))))
                  (bitsleft
                    (Pair_t
                    (register_t,
                    operand_t))
                    ('1'::[])
                    (seq
                      register_t
                      operand_t
                      reg
                      (imm_op
                        opsize_override))))
                (fun p ->
                let (r2,
                     w) =
                  Obj.magic
                    p
                in
                Obj.magic
                  (MOV
                  (true,
                  (Reg_op
                  r2),
                  w))))
              (alt
                instruction_t
                (map
                  (Pair_t
                  (register_t,
                  byte_t))
                  instruction_t
                  (bitsleft
                    (Pair_t
                    (register_t,
                    byte_t))
                    ('1'::('0'::('1'::('1'::[]))))
                    (bitsleft
                      (Pair_t
                      (register_t,
                      byte_t))
                      ('0'::[])
                      (seq
                        register_t
                        byte_t
                        reg
                        byte)))
                  (fun p ->
                  let (r2,
                       b) =
                    Obj.magic
                      p
                  in
                  Obj.magic
                    (MOV
                    (false,
                    (Reg_op
                    r2),
                    (Imm_op
                    (zero_extend8_32
                      b))))))
                (alt
                  instruction_t
                  (map
                    (Pair_t
                    (operand_t,
                    operand_t))
                    instruction_t
                    (bitsleft
                      (Pair_t
                      (operand_t,
                      operand_t))
                      ('1'::('1'::('0'::('0'::[]))))
                      (bitsleft
                        (Pair_t
                        (operand_t,
                        operand_t))
                        ('0'::('1'::('1'::('1'::[]))))
                        (seq
                          operand_t
                          operand_t
                          (ext_op_modrm
                            ('0'::('0'::('0'::[]))))
                          (imm_op
                            opsize_override))))
                    (fun p ->
                    let (op,
                         w) =
                      Obj.magic
                        p
                    in
                    Obj.magic
                      (MOV
                      (true,
                      op,
                      w))))
                  (alt
                    instruction_t
                    (map
                      (Pair_t
                      (operand_t,
                      byte_t))
                      instruction_t
                      (bitsleft
                        (Pair_t
                        (operand_t,
                        byte_t))
                        ('1'::('1'::('0'::('0'::[]))))
                        (bitsleft
                          (Pair_t
                          (operand_t,
                          byte_t))
                          ('0'::('1'::('1'::('0'::[]))))
                          (seq
                            operand_t
                            byte_t
                            (ext_op_modrm
                              ('0'::('0'::('0'::[]))))
                            byte)))
                      (fun p ->
                      let (op,
                           b) =
                        Obj.magic
                          p
                      in
                      Obj.magic
                        (MOV
                        (false,
                        op,
                        (Imm_op
                        (zero_extend8_32
                          b))))))
                    (alt
                      instruction_t
                      (map
                        word_t
                        instruction_t
                        (bitsleft
                          word_t
                          ('1'::('0'::('1'::('0'::[]))))
                          (bitsleft
                            word_t
                            ('0'::('0'::('0'::('1'::[]))))
                            word))
                        (fun w ->
                        Obj.magic
                          (MOV
                          (true,
                          (Reg_op
                          EAX),
                          (Offset_op
                          (Obj.magic
                            w))))))
                      (alt
                        instruction_t
                        (map
                          word_t
                          instruction_t
                          (bitsleft
                            word_t
                            ('1'::('0'::('1'::('0'::[]))))
                            (bitsleft
                              word_t
                              ('0'::('0'::('0'::('0'::[]))))
                              word))
                          (fun w ->
                          Obj.magic
                            (MOV
                            (false,
                            (Reg_op
                            EAX),
                            (Offset_op
                            (Obj.magic
                              w))))))
                        (alt
                          instruction_t
                          (map
                            word_t
                            instruction_t
                            (bitsleft
                              word_t
                              ('1'::('0'::('1'::('0'::[]))))
                              (bitsleft
                                word_t
                                ('0'::('0'::('1'::('1'::[]))))
                                word))
                            (fun w ->
                            Obj.magic
                              (MOV
                              (true,
                              (Offset_op
                              (Obj.magic
                                w)),
                              (Reg_op
                              EAX)))))
                          (map
                            word_t
                            instruction_t
                            (bitsleft
                              word_t
                              ('1'::('0'::('1'::('0'::[]))))
                              (bitsleft
                                word_t
                                ('0'::('0'::('1'::('0'::[]))))
                                word))
                            (fun w ->
                            Obj.magic
                              (MOV
                              (false,
                              (Offset_op
                              (Obj.magic
                                w)),
                              (Reg_op
                              EAX)))))))))))))))
  
  (** val control_reg_p :
      grammar **)
  
  let control_reg_p =
    alt
      control_register_t
      (map
        (bits_n
          (length0
            ('0'::('0'::('0'::[])))))
        control_register_t
        (bits
          ('0'::('0'::('0'::[]))))
        (fun x ->
        Obj.magic
          CR0))
      (alt
        control_register_t
        (map
          (bits_n
            (length0
              ('0'::('1'::('0'::[])))))
          control_register_t
          (bits
            ('0'::('1'::('0'::[]))))
          (fun x ->
          Obj.magic
            CR2))
        (alt
          control_register_t
          (map
            (bits_n
              (length0
                ('0'::('1'::('1'::[])))))
            control_register_t
            (bits
              ('0'::('1'::('1'::[]))))
            (fun x ->
            Obj.magic
              CR3))
          (map
            (bits_n
              (length0
                ('1'::('0'::('0'::[])))))
            control_register_t
            (bits
              ('1'::('0'::('0'::[]))))
            (fun x ->
            Obj.magic
              CR4))))
  
  (** val coq_MOVCR_p :
      grammar **)
  
  let coq_MOVCR_p =
    alt
      instruction_t
      (map
        (Pair_t
        (control_register_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (control_register_t,
          register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (control_register_t,
            register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (control_register_t,
              register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft
                (Pair_t
                (control_register_t,
                register_t))
                ('0'::('0'::('1'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (control_register_t,
                  register_t))
                  ('1'::('1'::[]))
                  (seq
                    control_register_t
                    register_t
                    control_reg_p
                    reg))))))
        (fun p ->
        Obj.magic
          (MOVCR
          (true,
          (fst
            (Obj.magic
              p)),
          (snd
            (Obj.magic
              p))))))
      (map
        (Pair_t
        (control_register_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (control_register_t,
          register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (control_register_t,
            register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (control_register_t,
              register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft
                (Pair_t
                (control_register_t,
                register_t))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (control_register_t,
                  register_t))
                  ('1'::('1'::[]))
                  (seq
                    control_register_t
                    register_t
                    control_reg_p
                    reg))))))
        (fun p ->
        Obj.magic
          (MOVCR
          (false,
          (fst
            (Obj.magic
              p)),
          (snd
            (Obj.magic
              p))))))
  
  (** val debug_reg_p :
      grammar **)
  
  let debug_reg_p =
    alt
      debug_register_t
      (map
        (bits_n
          (length0
            ('0'::('0'::('0'::[])))))
        debug_register_t
        (bits
          ('0'::('0'::('0'::[]))))
        (fun x ->
        Obj.magic
          DR0))
      (alt
        debug_register_t
        (map
          (bits_n
            (length0
              ('0'::('0'::('1'::[])))))
          debug_register_t
          (bits
            ('0'::('0'::('1'::[]))))
          (fun x ->
          Obj.magic
            DR1))
        (alt
          debug_register_t
          (map
            (bits_n
              (length0
                ('0'::('1'::('0'::[])))))
            debug_register_t
            (bits
              ('0'::('1'::('0'::[]))))
            (fun x ->
            Obj.magic
              DR2))
          (alt
            debug_register_t
            (map
              (bits_n
                (length0
                  ('0'::('1'::('1'::[])))))
              debug_register_t
              (bits
                ('0'::('1'::('1'::[]))))
              (fun x ->
              Obj.magic
                DR3))
            (alt
              debug_register_t
              (map
                (bits_n
                  (length0
                    ('1'::('1'::('0'::[])))))
                debug_register_t
                (bits
                  ('1'::('1'::('0'::[]))))
                (fun x ->
                Obj.magic
                  DR6))
              (map
                (bits_n
                  (length0
                    ('1'::('1'::('1'::[])))))
                debug_register_t
                (bits
                  ('1'::('1'::('1'::[]))))
                (fun x ->
                Obj.magic
                  DR7))))))
  
  (** val coq_MOVDR_p :
      grammar **)
  
  let coq_MOVDR_p =
    alt
      instruction_t
      (map
        (Pair_t
        (debug_register_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (debug_register_t,
          register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (debug_register_t,
            register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (debug_register_t,
              register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft
                (Pair_t
                (debug_register_t,
                register_t))
                ('0'::('0'::('1'::('1'::[]))))
                (bitsleft
                  (Pair_t
                  (debug_register_t,
                  register_t))
                  ('1'::('1'::[]))
                  (seq
                    debug_register_t
                    register_t
                    debug_reg_p
                    reg))))))
        (fun p ->
        Obj.magic
          (MOVDR
          (true,
          (fst
            (Obj.magic
              p)),
          (snd
            (Obj.magic
              p))))))
      (map
        (Pair_t
        (debug_register_t,
        register_t))
        instruction_t
        (bitsleft
          (Pair_t
          (debug_register_t,
          register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (debug_register_t,
            register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (debug_register_t,
              register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft
                (Pair_t
                (debug_register_t,
                register_t))
                ('0'::('0'::('0'::('1'::[]))))
                (bitsleft
                  (Pair_t
                  (debug_register_t,
                  register_t))
                  ('1'::('1'::[]))
                  (seq
                    debug_register_t
                    register_t
                    debug_reg_p
                    reg))))))
        (fun p ->
        Obj.magic
          (MOVDR
          (false,
          (fst
            (Obj.magic
              p)),
          (snd
            (Obj.magic
              p))))))
  
  (** val segment_reg_p :
      grammar **)
  
  let segment_reg_p =
    alt
      segment_register_t
      (map
        (bits_n
          (length0
            ('0'::('0'::('0'::[])))))
        segment_register_t
        (bits
          ('0'::('0'::('0'::[]))))
        (fun x ->
        Obj.magic
          ES))
      (alt
        segment_register_t
        (map
          (bits_n
            (length0
              ('0'::('0'::('1'::[])))))
          segment_register_t
          (bits
            ('0'::('0'::('1'::[]))))
          (fun x ->
          Obj.magic
            CS))
        (alt
          segment_register_t
          (map
            (bits_n
              (length0
                ('0'::('1'::('0'::[])))))
            segment_register_t
            (bits
              ('0'::('1'::('0'::[]))))
            (fun x ->
            Obj.magic
              SS))
          (alt
            segment_register_t
            (map
              (bits_n
                (length0
                  ('0'::('1'::('1'::[])))))
              segment_register_t
              (bits
                ('0'::('1'::('1'::[]))))
              (fun x ->
              Obj.magic
                DS))
            (alt
              segment_register_t
              (map
                (bits_n
                  (length0
                    ('1'::('0'::('0'::[])))))
                segment_register_t
                (bits
                  ('1'::('0'::('0'::[]))))
                (fun x ->
                Obj.magic
                  FS))
              (map
                (bits_n
                  (length0
                    ('1'::('0'::('1'::[])))))
                segment_register_t
                (bits
                  ('1'::('0'::('1'::[]))))
                (fun x ->
                Obj.magic
                  GS))))))
  
  (** val seg_modrm :
      grammar **)
  
  let seg_modrm =
    alt
      (Pair_t
      (segment_register_t,
      operand_t))
      (map
        (Pair_t
        (segment_register_t,
        address_t))
        (Pair_t
        (segment_register_t,
        operand_t))
        (alt
          (Pair_t
          (segment_register_t,
          address_t))
          (bitsleft
            (Pair_t
            (segment_register_t,
            address_t))
            ('0'::('0'::[]))
            (seq
              segment_register_t
              address_t
              segment_reg_p
              rm00))
          (alt
            (Pair_t
            (segment_register_t,
            address_t))
            (bitsleft
              (Pair_t
              (segment_register_t,
              address_t))
              ('0'::('1'::[]))
              (seq
                segment_register_t
                address_t
                segment_reg_p
                rm01))
            (bitsleft
              (Pair_t
              (segment_register_t,
              address_t))
              ('1'::('0'::[]))
              (seq
                segment_register_t
                address_t
                segment_reg_p
                rm10))))
        (fun p ->
        let (sr,
             addr) =
          Obj.magic
            p
        in
        Obj.magic
          (sr,
          (Address_op
          addr))))
      (bitsleft
        (Pair_t
        (segment_register_t,
        operand_t))
        ('1'::('1'::[]))
        (seq
          segment_register_t
          operand_t
          segment_reg_p
          reg_op))
  
  (** val coq_MOVSR_p :
      grammar **)
  
  let coq_MOVSR_p =
    alt
      instruction_t
      (map
        (Pair_t
        (segment_register_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (segment_register_t,
          operand_t))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (segment_register_t,
            operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            seg_modrm))
        (fun p ->
        Obj.magic
          (MOVSR
          (true,
          (fst
            (Obj.magic
              p)),
          (snd
            (Obj.magic
              p))))))
      (map
        (Pair_t
        (segment_register_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (segment_register_t,
          operand_t))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (segment_register_t,
            operand_t))
            ('1'::('1'::('0'::('0'::[]))))
            seg_modrm))
        (fun p ->
        Obj.magic
          (MOVSR
          (false,
          (fst
            (Obj.magic
              p)),
          (snd
            (Obj.magic
              p))))))
  
  (** val coq_MOVBE_p :
      grammar **)
  
  let coq_MOVBE_p =
    alt
      instruction_t
      (map
        (Pair_t
        (operand_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('0'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (operand_t,
                operand_t))
                ('1'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (operand_t,
                  operand_t))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft
                    (Pair_t
                    (operand_t,
                    operand_t))
                    ('0'::('0'::('0'::('1'::[]))))
                    modrm))))))
        (fun p ->
        Obj.magic
          (MOVBE
          ((snd
             (Obj.magic
               p)),
          (fst
            (Obj.magic
              p))))))
      (map
        (Pair_t
        (operand_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (operand_t,
          operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft
            (Pair_t
            (operand_t,
            operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (operand_t,
              operand_t))
              ('0'::('0'::('1'::('1'::[]))))
              (bitsleft
                (Pair_t
                (operand_t,
                operand_t))
                ('1'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (Pair_t
                  (operand_t,
                  operand_t))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft
                    (Pair_t
                    (operand_t,
                    operand_t))
                    ('0'::('0'::('0'::('0'::[]))))
                    modrm))))))
        (fun p ->
        Obj.magic
          (MOVBE
          ((fst
             (Obj.magic
               p)),
          (snd
            (Obj.magic
              p))))))
  
  (** val coq_MOVS_p :
      grammar **)
  
  let coq_MOVS_p =
    map
      Char_t
      instruction_t
      (bitsleft
        Char_t
        ('1'::('0'::('1'::('0'::[]))))
        (bitsleft
          Char_t
          ('0'::('1'::('0'::[])))
          anybit))
      (fun x ->
      Obj.magic
        (MOVS
        (Obj.magic
          x)))
  
  (** val coq_MOVSX_p :
      grammar **)
  
  let coq_MOVSX_p =
    map
      (Pair_t
      (Char_t,
      (Pair_t
      (operand_t,
      operand_t))))
      instruction_t
      (bitsleft
        (Pair_t
        (Char_t,
        (Pair_t
        (operand_t,
        operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            operand_t))))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              (Pair_t
              (operand_t,
              operand_t))))
              ('1'::('1'::('1'::[])))
              (seq
                Char_t
                (Pair_t
                (operand_t,
                operand_t))
                anybit
                modrm)))))
      (fun p ->
      let (w,
           i) =
        Obj.magic
          p
      in
      let (op1,
           op2) =
        i
      in
      Obj.magic
        (MOVSX
        (w,
        op1,
        op2)))
  
  (** val coq_MOVZX_p :
      grammar **)
  
  let coq_MOVZX_p =
    map
      (Pair_t
      (Char_t,
      (Pair_t
      (operand_t,
      operand_t))))
      instruction_t
      (bitsleft
        (Pair_t
        (Char_t,
        (Pair_t
        (operand_t,
        operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            operand_t))))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              (Pair_t
              (operand_t,
              operand_t))))
              ('0'::('1'::('1'::[])))
              (seq
                Char_t
                (Pair_t
                (operand_t,
                operand_t))
                anybit
                modrm)))))
      (fun p ->
      let (w,
           i) =
        Obj.magic
          p
      in
      let (op1,
           op2) =
        i
      in
      Obj.magic
        (MOVZX
        (w,
        op1,
        op2)))
  
  (** val coq_MUL_p :
      grammar **)
  
  let coq_MUL_p =
    map
      (Pair_t
      (Char_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (Char_t,
        operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('0'::('1'::('1'::[])))
          (seq
            Char_t
            operand_t
            anybit
            (ext_op_modrm2
              ('1'::('0'::('0'::[])))))))
      (fun p ->
      Obj.magic
        (MUL
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_NEG_p :
      grammar **)
  
  let coq_NEG_p =
    map
      (Pair_t
      (Char_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (Char_t,
        operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('0'::('1'::('1'::[])))
          (seq
            Char_t
            operand_t
            anybit
            (ext_op_modrm2
              ('0'::('1'::('1'::[])))))))
      (fun p ->
      Obj.magic
        (NEG
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_NOP_p :
      grammar **)
  
  let coq_NOP_p =
    map
      operand_t
      instruction_t
      (bitsleft
        operand_t
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          operand_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            operand_t
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft
              operand_t
              ('1'::('1'::('1'::('1'::[]))))
              (ext_op_modrm2
                ('0'::('0'::('0'::[]))))))))
      (fun op ->
      Obj.magic
        (NOP
        (Obj.magic
          op)))
  
  (** val coq_NOT_p :
      grammar **)
  
  let coq_NOT_p =
    map
      (Pair_t
      (Char_t,
      operand_t))
      instruction_t
      (bitsleft
        (Pair_t
        (Char_t,
        operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('0'::('1'::('1'::[])))
          (seq
            Char_t
            operand_t
            anybit
            (ext_op_modrm2
              ('0'::('1'::('0'::[])))))))
      (fun p ->
      Obj.magic
        (NOT
        ((fst
           (Obj.magic
             p)),
        (snd
          (Obj.magic
            p)))))
  
  (** val coq_OUT_p :
      grammar **)
  
  let coq_OUT_p =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        byte_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          byte_t))
          ('1'::('1'::('1'::('0'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            byte_t))
            ('0'::('1'::('1'::[])))
            (seq
              Char_t
              byte_t
              anybit
              byte)))
        (fun p ->
        Obj.magic
          (OUT
          ((fst
             (Obj.magic
               p)),
          (Some
          (snd
            (Obj.magic
              p)))))))
      (map
        Char_t
        instruction_t
        (bitsleft
          Char_t
          ('1'::('1'::('1'::('0'::[]))))
          (bitsleft
            Char_t
            ('1'::('1'::('1'::[])))
            anybit))
        (fun w ->
        Obj.magic
          (OUT
          ((Obj.magic
             w),
          None))))
  
  (** val coq_OUTS_p :
      grammar **)
  
  let coq_OUTS_p =
    map
      Char_t
      instruction_t
      (bitsleft
        Char_t
        ('0'::('1'::('1'::('0'::[]))))
        (bitsleft
          Char_t
          ('1'::('1'::('1'::[])))
          anybit))
      (fun x ->
      Obj.magic
        (OUTS
        (Obj.magic
          x)))
  
  (** val coq_POP_p :
      grammar **)
  
  let coq_POP_p =
    alt
      instruction_t
      (map
        operand_t
        instruction_t
        (bitsleft
          operand_t
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft
            operand_t
            ('1'::('1'::('1'::('1'::[]))))
            (ext_op_modrm2
              ('0'::('0'::('0'::[]))))))
        (fun x ->
        Obj.magic
          (POP
          (Obj.magic
            x))))
      (map
        register_t
        instruction_t
        (bitsleft
          register_t
          ('0'::('1'::('0'::('1'::[]))))
          (bitsleft
            register_t
            ('1'::[])
            reg))
        (fun r2 ->
        Obj.magic
          (POP
          (Reg_op
          (Obj.magic
            r2)))))
  
  (** val coq_POPSR_p :
      grammar **)
  
  let coq_POPSR_p =
    alt
      instruction_t
      (map
        (bits_n
          (length0
            ('1'::('1'::('1'::[])))))
        instruction_t
        (bitsleft
          (bits_n
            (length0
              ('1'::('1'::('1'::[])))))
          ('0'::('0'::('0'::[])))
          (bitsleft
            (bits_n
              (length0
                ('1'::('1'::('1'::[])))))
            ('0'::('0'::[]))
            (bits
              ('1'::('1'::('1'::[]))))))
        (fun x ->
        Obj.magic
          (POPSR
          ES)))
      (alt
        instruction_t
        (map
          (bits_n
            (length0
              ('1'::('1'::('1'::[])))))
          instruction_t
          (bitsleft
            (bits_n
              (length0
                ('1'::('1'::('1'::[])))))
            ('0'::('0'::('0'::[])))
            (bitsleft
              (bits_n
                (length0
                  ('1'::('1'::('1'::[])))))
              ('1'::('0'::[]))
              (bits
                ('1'::('1'::('1'::[]))))))
          (fun x ->
          Obj.magic
            (POPSR
            SS)))
        (alt
          instruction_t
          (map
            (bits_n
              (length0
                ('1'::('1'::('1'::[])))))
            instruction_t
            (bitsleft
              (bits_n
                (length0
                  ('1'::('1'::('1'::[])))))
              ('0'::('0'::('0'::[])))
              (bitsleft
                (bits_n
                  (length0
                    ('1'::('1'::('1'::[])))))
                ('1'::('1'::[]))
                (bits
                  ('1'::('1'::('1'::[]))))))
            (fun x ->
            Obj.magic
              (POPSR
              DS)))
          (alt
            instruction_t
            (map
              (bits_n
                (length0
                  ('0'::('0'::('1'::[])))))
              instruction_t
              (bitsleft
                (bits_n
                  (length0
                    ('0'::('0'::('1'::[])))))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (bits_n
                    (length0
                      ('0'::('0'::('1'::[])))))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft
                    (bits_n
                      (length0
                        ('0'::('0'::('1'::[])))))
                    ('1'::('0'::[]))
                    (bitsleft
                      (bits_n
                        (length0
                          ('0'::('0'::('1'::[])))))
                      ('1'::('0'::('0'::[])))
                      (bits
                        ('0'::('0'::('1'::[]))))))))
              (fun x ->
              Obj.magic
                (POPSR
                FS)))
            (map
              (bits_n
                (length0
                  ('0'::('0'::('1'::[])))))
              instruction_t
              (bitsleft
                (bits_n
                  (length0
                    ('0'::('0'::('1'::[])))))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft
                  (bits_n
                    (length0
                      ('0'::('0'::('1'::[])))))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft
                    (bits_n
                      (length0
                        ('0'::('0'::('1'::[])))))
                    ('1'::('0'::[]))
                    (bitsleft
                      (bits_n
                        (length0
                          ('0'::('0'::('1'::[])))))
                      ('1'::('0'::('1'::[])))
                      (bits
                        ('0'::('0'::('1'::[]))))))))
              (fun x ->
              Obj.magic
                (POPSR
                GS))))))
  
  (** val coq_POPA_p :
      grammar **)
  
  let coq_POPA_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('0'::('0'::('1'::[]))))))
        ('0'::('1'::('1'::('0'::[]))))
        (bits
          ('0'::('0'::('0'::('1'::[]))))))
      (fun x ->
      Obj.magic
        POPA)
  
  (** val coq_POPF_p :
      grammar **)
  
  let coq_POPF_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('0'::('1'::[]))))))
        ('1'::('0'::('0'::('1'::[]))))
        (bits
          ('1'::('1'::('0'::('1'::[]))))))
      (fun x ->
      Obj.magic
        POPF)
  
  (** val coq_PUSH_p :
      grammar **)
  
  let coq_PUSH_p =
    alt
      instruction_t
      (map
        operand_t
        instruction_t
        (bitsleft
          operand_t
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            operand_t
            ('1'::('1'::('1'::('1'::[]))))
            (ext_op_modrm
              ('1'::('1'::('0'::[]))))))
        (fun x ->
        Obj.magic
          (PUSH
          (true,
          (Obj.magic
            x)))))
      (alt
        instruction_t
        (map
          register_t
          instruction_t
          (bitsleft
            register_t
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft
              register_t
              ('0'::[])
              reg))
          (fun r2 ->
          Obj.magic
            (PUSH
            (true,
            (Reg_op
            (Obj.magic
              r2))))))
        (alt
          instruction_t
          (map
            byte_t
            instruction_t
            (bitsleft
              byte_t
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft
                byte_t
                ('1'::('0'::('1'::('0'::[]))))
                byte))
            (fun b ->
            Obj.magic
              (PUSH
              (false,
              (Imm_op
              (sign_extend8_32
                (Obj.magic
                  b)))))))
          (map
            word_t
            instruction_t
            (bitsleft
              word_t
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft
                word_t
                ('1'::('0'::('0'::('0'::[]))))
                word))
            (fun w ->
            Obj.magic
              (PUSH
              (true,
              (Imm_op
              (Obj.magic
                w))))))))
  
  (** val segment_reg2_p :
      grammar **)
  
  let segment_reg2_p =
    alt
      segment_register_t
      (map
        (bits_n
          (length0
            ('0'::('0'::[]))))
        segment_register_t
        (bits
          ('0'::('0'::[])))
        (fun x ->
        Obj.magic
          ES))
      (alt
        segment_register_t
        (map
          (bits_n
            (length0
              ('0'::('1'::[]))))
          segment_register_t
          (bits
            ('0'::('1'::[])))
          (fun x ->
          Obj.magic
            CS))
        (alt
          segment_register_t
          (map
            (bits_n
              (length0
                ('1'::('0'::[]))))
            segment_register_t
            (bits
              ('1'::('0'::[])))
            (fun x ->
            Obj.magic
              SS))
          (map
            (bits_n
              (length0
                ('1'::('1'::[]))))
            segment_register_t
            (bits
              ('1'::('1'::[])))
            (fun x ->
            Obj.magic
              DS))))
  
  (** val coq_PUSHSR_p :
      grammar **)
  
  let coq_PUSHSR_p =
    alt
      instruction_t
      (map
        (Pair_t
        (segment_register_t,
        (bits_n
          (length0
            ('1'::('1'::('0'::[])))))))
        instruction_t
        (bitsleft
          (Pair_t
          (segment_register_t,
          (bits_n
            (length0
              ('1'::('1'::('0'::[])))))))
          ('0'::('0'::('0'::[])))
          (seq
            segment_register_t
            (bits_n
              (length0
                ('1'::('1'::('0'::[])))))
            segment_reg2_p
            (bits
              ('1'::('1'::('0'::[]))))))
        (fun p ->
        Obj.magic
          (PUSHSR
          (fst
            (Obj.magic
              p)))))
      (alt
        instruction_t
        (map
          (bits_n
            (length0
              ('0'::('0'::('0'::[])))))
          instruction_t
          (bitsleft
            (bits_n
              (length0
                ('0'::('0'::('0'::[])))))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (bits_n
                (length0
                  ('0'::('0'::('0'::[])))))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                (bits_n
                  (length0
                    ('0'::('0'::('0'::[])))))
                ('1'::('0'::[]))
                (bitsleft
                  (bits_n
                    (length0
                      ('0'::('0'::('0'::[])))))
                  ('1'::('0'::('0'::[])))
                  (bits
                    ('0'::('0'::('0'::[]))))))))
          (fun x ->
          Obj.magic
            (PUSHSR
            FS)))
        (map
          (bits_n
            (length0
              ('0'::('0'::('0'::[])))))
          instruction_t
          (bitsleft
            (bits_n
              (length0
                ('0'::('0'::('0'::[])))))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (bits_n
                (length0
                  ('0'::('0'::('0'::[])))))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft
                (bits_n
                  (length0
                    ('0'::('0'::('0'::[])))))
                ('1'::('0'::[]))
                (bitsleft
                  (bits_n
                    (length0
                      ('0'::('0'::('0'::[])))))
                  ('1'::('0'::('1'::[])))
                  (bits
                    ('0'::('0'::('0'::[]))))))))
          (fun x ->
          Obj.magic
            (PUSHSR
            GS))))
  
  (** val coq_PUSHA_p :
      grammar **)
  
  let coq_PUSHA_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('0'::('0'::('0'::[]))))))
        ('0'::('1'::('1'::('0'::[]))))
        (bits
          ('0'::('0'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        PUSHA)
  
  (** val coq_PUSHF_p :
      grammar **)
  
  let coq_PUSHF_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('1'::('0'::('0'::[]))))))
        ('1'::('0'::('0'::('1'::[]))))
        (bits
          ('1'::('1'::('0'::('0'::[]))))))
      (fun x ->
      Obj.magic
        PUSHF)
  
  (** val rotate_p :
      char list
      ->
      (bool
      ->
      operand
      ->
      reg_or_immed
      ->
      instr)
      ->
      grammar **)
  
  let rotate_p extop inst =
    alt
      instruction_t
      (map
        (Pair_t
        (Char_t,
        operand_t))
        instruction_t
        (bitsleft
          (Pair_t
          (Char_t,
          operand_t))
          ('1'::('1'::('0'::('1'::[]))))
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('0'::('0'::('0'::[])))
            (seq
              Char_t
              operand_t
              anybit
              (ext_op_modrm2
                extop))))
        (fun p ->
        Obj.magic
          inst
          (fst
            (Obj.magic
              p))
          (snd
            (Obj.magic
              p))
          (Imm_ri
          (Word.repr
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))
            Big.one))))
      (alt
        instruction_t
        (map
          (Pair_t
          (Char_t,
          operand_t))
          instruction_t
          (bitsleft
            (Pair_t
            (Char_t,
            operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              operand_t))
              ('0'::('0'::('1'::[])))
              (seq
                Char_t
                operand_t
                anybit
                (ext_op_modrm2
                  extop))))
          (fun p ->
          Obj.magic
            inst
            (fst
              (Obj.magic
                p))
            (snd
              (Obj.magic
                p))
            (Reg_ri
            ECX)))
        (map
          (Pair_t
          (Char_t,
          (Pair_t
          (operand_t,
          byte_t))))
          instruction_t
          (bitsleft
            (Pair_t
            (Char_t,
            (Pair_t
            (operand_t,
            byte_t))))
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft
              (Pair_t
              (Char_t,
              (Pair_t
              (operand_t,
              byte_t))))
              ('0'::('0'::('0'::[])))
              (seq
                Char_t
                (Pair_t
                (operand_t,
                byte_t))
                anybit
                (seq
                  operand_t
                  byte_t
                  (ext_op_modrm2
                    extop)
                  byte))))
          (fun p ->
          let (w,
               i) =
            Obj.magic
              p
          in
          let (op,
               b) =
            i
          in
          Obj.magic
            inst
            w
            op
            (Imm_ri
            b))))
  
  (** val coq_RCL_p :
      grammar **)
  
  let coq_RCL_p =
    rotate_p
      ('0'::('1'::('0'::[])))
      (fun x x0 x1 ->
      RCL
      (x,
      x0,
      x1))
  
  (** val coq_RCR_p :
      grammar **)
  
  let coq_RCR_p =
    rotate_p
      ('0'::('1'::('1'::[])))
      (fun x x0 x1 ->
      RCR
      (x,
      x0,
      x1))
  
  (** val coq_RDMSR_p :
      grammar **)
  
  let coq_RDMSR_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('1'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('0'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('0'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('0'::('0'::('1'::('0'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits
              ('0'::('0'::('1'::('0'::[]))))))))
      (fun x ->
      Obj.magic
        RDMSR)
  
  (** val coq_RDPMC_p :
      grammar **)
  
  let coq_RDPMC_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('1'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('0'::('1'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('0'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('0'::('0'::('1'::('1'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits
              ('0'::('0'::('1'::('1'::[]))))))))
      (fun x ->
      Obj.magic
        RDPMC)
  
  (** val coq_RDTSC_p :
      grammar **)
  
  let coq_RDTSC_p =
    map
      (bits_n
        (length0
          ('0'::('0'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('0'::('0'::('0'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('0'::('0'::('0'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('0'::('0'::('0'::('1'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits
              ('0'::('0'::('0'::('1'::[]))))))))
      (fun x ->
      Obj.magic
        RDTSC)
  
  (** val coq_RDTSCP_p :
      grammar **)
  
  let coq_RDTSCP_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('0'::('1'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('0'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('1'::('0'::('0'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('1'::('0'::('0'::('1'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft
              (bits_n
                (length0
                  ('1'::('0'::('0'::('1'::[]))))))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft
                (bits_n
                  (length0
                    ('1'::('0'::('0'::('1'::[]))))))
                ('1'::('1'::('1'::('1'::[]))))
                (bits
                  ('1'::('0'::('0'::('1'::[]))))))))))
      (fun x ->
      Obj.magic
        RDTSCP)
  
  (** val coq_RET_p :
      grammar **)
  
  let coq_RET_p =
    alt
      instruction_t
      (map
        (bits_n
          (length0
            ('0'::('0'::('1'::('1'::[]))))))
        instruction_t
        (bitsleft
          (bits_n
            (length0
              ('0'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('0'::('0'::[]))))
          (bits
            ('0'::('0'::('1'::('1'::[]))))))
        (fun x ->
        Obj.magic
          (RET
          (true,
          None))))
      (alt
        instruction_t
        (map
          half_t
          instruction_t
          (bitsleft
            half_t
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft
              half_t
              ('0'::('0'::('1'::('0'::[]))))
              halfword))
          (fun h ->
          Obj.magic
            (RET
            (true,
            (Some
            (Obj.magic
              h))))))
        (alt
          instruction_t
          (map
            (bits_n
              (length0
                ('1'::('0'::('1'::('1'::[]))))))
            instruction_t
            (bitsleft
              (bits_n
                (length0
                  ('1'::('0'::('1'::('1'::[]))))))
              ('1'::('1'::('0'::('0'::[]))))
              (bits
                ('1'::('0'::('1'::('1'::[]))))))
            (fun x ->
            Obj.magic
              (RET
              (false,
              None))))
          (map
            half_t
            instruction_t
            (bitsleft
              half_t
              ('1'::('1'::('0'::('0'::[]))))
              (bitsleft
                half_t
                ('1'::('0'::('1'::('0'::[]))))
                halfword))
            (fun h ->
            Obj.magic
              (RET
              (false,
              (Some
              (Obj.magic
                h))))))))
  
  (** val coq_ROL_p :
      grammar **)
  
  let coq_ROL_p =
    rotate_p
      ('0'::('0'::('0'::[])))
      (fun x x0 x1 ->
      ROL
      (x,
      x0,
      x1))
  
  (** val coq_ROR_p :
      grammar **)
  
  let coq_ROR_p =
    rotate_p
      ('0'::('0'::('1'::[])))
      (fun x x0 x1 ->
      ROR
      (x,
      x0,
      x1))
  
  (** val coq_RSM_p :
      grammar **)
  
  let coq_RSM_p =
    map
      (bits_n
        (length0
          ('1'::('0'::('1'::('0'::[]))))))
      instruction_t
      (bitsleft
        (bits_n
          (length0
            ('1'::('0'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft
          (bits_n
            (length0
              ('1'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft
            (bits_n
              (length0
                ('1'::('0'::('1'::('0'::[]))))))
            ('1'::('0'::('1'::('0'::[]))))
            (bits
              ('1'::('0'::('1'::('0'::[]))))))))
      (fun x ->
      Obj.magic
        RSM)
  
  (** val coq_SAHF_p :
      grammar **)
  
  let coq_SAHF_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('1'::('1'::('0'::[]))))))
      (fun x -> Obj.magic SAHF)
  
  (** val coq_SAR_p : grammar **)
  
  let coq_SAR_p =
    rotate_p ('1'::('1'::('1'::[]))) (fun x x0 x1 -> SAR (x, x0, x1))
  
  (** val coq_SCAS_p : grammar **)
  
  let coq_SCAS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('1'::('1'::[]))) anybit)) (fun x ->
      Obj.magic (SCAS (Obj.magic x)))
  
  (** val coq_SETcc_p : grammar **)
  
  let coq_SETcc_p =
    map (Pair_t (condition_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('0'::('1'::[]))))
            (seq condition_t (Pair_t (operand_t, operand_t)) tttn modrm))))
      (fun p ->
      Obj.magic (SETcc ((fst (Obj.magic p)), (snd (snd (Obj.magic p))))))
  
  (** val coq_SGDT_p : grammar **)
  
  let coq_SGDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (SGDT (Obj.magic x)))
  
  (** val coq_SHL_p : grammar **)
  
  let coq_SHL_p =
    rotate_p ('1'::('0'::('0'::[]))) (fun x x0 x1 -> SHL (x, x0, x1))
  
  (** val shiftdouble_p :
      char list -> (operand -> register -> reg_or_immed -> interp) -> grammar **)
  
  let shiftdouble_p opcode inst =
    alt instruction_t
      (map (Pair_t (register_t, (Pair_t (register_t, byte_t)))) instruction_t
        (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
              ('1'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
                opcode
                (bitsleft (Pair_t (register_t, (Pair_t (register_t,
                  byte_t)))) ('0'::('0'::[]))
                  (bitsleft (Pair_t (register_t, (Pair_t (register_t,
                    byte_t)))) ('1'::('1'::[]))
                    (seq register_t (Pair_t (register_t, byte_t)) reg
                      (seq register_t byte_t reg byte)))))))) (fun p ->
        let (r2, i) = Obj.magic p in
        let (r3, b) = i in inst (Reg_op r3) r2 (Imm_ri b)))
      (alt instruction_t
        (map (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
          instruction_t
          (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
                ('1'::('0'::('1'::('0'::[]))))
                (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
                  opcode
                  (bitsleft (Pair_t ((Pair_t (register_t, operand_t)),
                    byte_t)) ('0'::('0'::[]))
                    (seq (Pair_t (register_t, operand_t)) byte_t modrm_noreg
                      byte)))))) (fun p ->
          let (i, b) = Obj.magic p in
          let (r2, op) = i in inst op r2 (Imm_ri b)))
        (alt instruction_t
          (map (Pair_t (register_t, register_t)) instruction_t
            (bitsleft (Pair_t (register_t, register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, register_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, register_t)) opcode
                    (bitsleft (Pair_t (register_t, register_t))
                      ('0'::('1'::[]))
                      (bitsleft (Pair_t (register_t, register_t))
                        ('1'::('1'::[])) (seq register_t register_t reg reg)))))))
            (fun p ->
            let (r2, r3) = Obj.magic p in inst (Reg_op r3) r2 (Reg_ri ECX)))
          (map (Pair_t (register_t, operand_t)) instruction_t
            (bitsleft (Pair_t (register_t, operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, operand_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, operand_t)) opcode
                    (bitsleft (Pair_t (register_t, operand_t))
                      ('0'::('1'::[])) modrm_noreg))))) (fun p ->
            let (r2, op) = Obj.magic p in inst op r2 (Reg_ri ECX)))))
  
  (** val coq_SHLD_p : grammar **)
  
  let coq_SHLD_p =
    shiftdouble_p ('0'::('1'::[]))
      (Obj.magic (fun x x0 x1 -> SHLD (x, x0, x1)))
  
  (** val coq_SHR_p : grammar **)
  
  let coq_SHR_p =
    rotate_p ('1'::('0'::('1'::[]))) (fun x x0 x1 -> SHR (x, x0, x1))
  
  (** val coq_SHRD_p : grammar **)
  
  let coq_SHRD_p =
    shiftdouble_p ('1'::('1'::[]))
      (Obj.magic (fun x x0 x1 -> SHRD (x, x0, x1)))
  
  (** val coq_SIDT_p : grammar **)
  
  let coq_SIDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (SIDT (Obj.magic x)))
  
  (** val coq_SLDT_p : grammar **)
  
  let coq_SLDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (SLDT (Obj.magic x)))
  
  (** val coq_SMSW_p : grammar **)
  
  let coq_SMSW_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm2 ('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (SMSW (Obj.magic x)))
  
  (** val coq_STC_p : grammar **)
  
  let coq_STC_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('0'::('0'::('1'::[]))))))
      (fun x -> Obj.magic STC)
  
  (** val coq_STD_p : grammar **)
  
  let coq_STD_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('1'::('0'::('1'::[]))))))
      (fun x -> Obj.magic STD)
  
  (** val coq_STI_p : grammar **)
  
  let coq_STI_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('0'::('1'::('1'::[]))))))
      (fun x -> Obj.magic STI)
  
  (** val coq_STOS_p : grammar **)
  
  let coq_STOS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('0'::('1'::[]))) anybit)) (fun x ->
      Obj.magic (STOS (Obj.magic x)))
  
  (** val coq_STR_p : grammar **)
  
  let coq_STR_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (STR (Obj.magic x)))
  
  (** val coq_TEST_p : bool -> grammar **)
  
  let coq_TEST_p opsize_override =
    alt instruction_t
      (map (Pair_t (operand_t, operand_t)) instruction_t
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('0'::('1'::('1'::('1'::[]))))
            (seq operand_t operand_t (ext_op_modrm2 ('0'::('0'::('0'::[]))))
              (imm_op opsize_override)))) (fun p ->
        Obj.magic (TEST (true, (fst (Obj.magic p)), (snd (Obj.magic p))))))
      (alt instruction_t
        (map (Pair_t (operand_t, byte_t)) instruction_t
          (bitsleft (Pair_t (operand_t, byte_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, byte_t))
              ('0'::('1'::('1'::('0'::[]))))
              (seq operand_t byte_t (ext_op_modrm2 ('0'::('0'::('0'::[]))))
                byte))) (fun p ->
          Obj.magic (TEST (false, (fst (Obj.magic p)), (Imm_op
            (zero_extend8_32 (snd (Obj.magic p))))))))
        (alt instruction_t
          (map (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            instruction_t
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('1'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
                ('0'::('1'::('0'::[])))
                (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))
            (fun p ->
            let (w, i) = Obj.magic p in
            let (op1, op2) = i in Obj.magic (TEST (w, op1, op2))))
          (alt instruction_t
            (map operand_t instruction_t
              (bitsleft operand_t ('1'::('0'::('1'::('0'::[]))))
                (bitsleft operand_t ('1'::('0'::('0'::('1'::[]))))
                  (imm_op opsize_override))) (fun w ->
              Obj.magic (TEST (true, (Obj.magic w), (Reg_op EAX)))))
            (map byte_t instruction_t
              (bitsleft byte_t ('1'::('0'::('1'::('0'::[]))))
                (bitsleft byte_t ('1'::('0'::('0'::('0'::[])))) byte))
              (fun b ->
              Obj.magic (TEST (true, (Reg_op EAX), (Imm_op
                (zero_extend8_32 (Obj.magic b))))))))))
  
  (** val coq_UD2_p : grammar **)
  
  let coq_UD2_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits ('1'::('0'::('1'::('1'::[])))))))) (fun x -> Obj.magic UD2)
  
  (** val coq_VERR_p : grammar **)
  
  let coq_VERR_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (VERR (Obj.magic x)))
  
  (** val coq_VERW_p : grammar **)
  
  let coq_VERW_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (VERW (Obj.magic x)))
  
  (** val coq_WBINVD_p : grammar **)
  
  let coq_WBINVD_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits ('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic WBINVD)
  
  (** val coq_WRMSR_p : grammar **)
  
  let coq_WRMSR_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic WRMSR)
  
  (** val coq_XADD_p : grammar **)
  
  let coq_XADD_p =
    map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('0'::('0'::('0'::[])))
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))))
      (fun p ->
      let (w, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (XADD (w, op2, op1)))
  
  (** val coq_XCHG_p : grammar **)
  
  let coq_XCHG_p =
    alt instruction_t
      (map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('0'::('1'::('1'::[])))
            (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))
        (fun p ->
        let (w, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (XCHG (w, op2, op1))))
      (map register_t instruction_t
        (bitsleft register_t ('1'::('0'::('0'::('1'::[]))))
          (bitsleft register_t ('0'::[]) reg)) (fun r2 ->
        Obj.magic (XCHG (false, (Reg_op EAX), (Reg_op (Obj.magic r2))))))
  
  (** val coq_XLAT_p : grammar **)
  
  let coq_XLAT_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('1'::('1'::('0'::('1'::[])))) (bits ('0'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic XLAT)
  
  (** val coq_F2XM1_p : grammar **)
  
  let coq_F2XM1_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic F2XM1)
  
  (** val coq_FABS_p : grammar **)
  
  let coq_FABS_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FABS)
  
  (** val coq_FADD_p : grammar **)
  
  let coq_FADD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FADD (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FADD (true, (Obj.magic x)))))
        (map (Pair_t (Char_t, fpu_register_t)) instruction_t
          (bitsleft (Pair_t (Char_t, fpu_register_t))
            ('1'::('1'::('0'::('1'::('1'::[])))))
            (seq Char_t fpu_register_t anybit
              (bitsleft fpu_register_t
                ('0'::('0'::('1'::('1'::('0'::('0'::('0'::[]))))))) fpu_reg)))
          (fun p ->
          let (d, s) = Obj.magic p in Obj.magic (FADD (d, (FPS_op s))))))
  
  (** val coq_FADDP_p : grammar **)
  
  let coq_FADDP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FADDP (FPS_op (Obj.magic x))))
  
  (** val coq_FBLD_p : grammar **)
  
  let coq_FBLD_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
          (ext_op_modrm_FPM64 ('1'::('0'::('0'::[])))))) (fun x ->
      Obj.magic (FBLD (Obj.magic x)))
  
  (** val coq_FBSTP_p : grammar **)
  
  let coq_FBSTP_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
          (ext_op_modrm_FPM64 ('1'::('1'::('0'::[])))))) (fun x ->
      Obj.magic (FBSTP (Obj.magic x)))
  
  (** val coq_FCHS_p : grammar **)
  
  let coq_FCHS_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FCHS)
  
  (** val coq_FCMOVcc_p : grammar **)
  
  let coq_FCMOVcc_p =
    map (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (Char_t,
      fpu_register_t)))))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (Char_t,
        fpu_register_t)))))) ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (Char_t,
          fpu_register_t)))))) ('0'::('1'::[]))
          (seq Char_t (Pair_t (Char_t, (Pair_t (Char_t, fpu_register_t))))
            anybit
            (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, fpu_register_t))))
              ('1'::('1'::('0'::[])))
              (seq Char_t (Pair_t (Char_t, fpu_register_t)) anybit
                (seq Char_t fpu_register_t anybit fpu_reg)))))) (fun p ->
      let (b2, i) = Obj.magic p in
      let (b1, i0) = i in
      let (b0, s) = i0 in
      let n =
        bits2int (Big.succ (Big.succ (Big.succ Big.zero)))
          (Obj.magic (b2, (b1, (b0, ()))))
      in
      Obj.magic (FCMOVcc ((z_to_fp_condition_type (Obj.magic n)), (FPS_op
        s))))
  
  (** val coq_FCOM_p : grammar **)
  
  let coq_FCOM_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FCOM (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('0'::[])))))) (fun x ->
          Obj.magic (FCOM (Obj.magic x))))
        (map fpu_register_t instruction_t
          (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fpu_register_t ('0'::('0'::('0'::[])))
              (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('0'::[])))))
                fpu_reg))) (fun x ->
          Obj.magic (FCOM (FPS_op (Obj.magic x))))))
  
  (** val coq_FCOMP_p : grammar **)
  
  let coq_FCOMP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FCOMP (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FCOMP (Obj.magic x))))
        (map fpu_register_t instruction_t
          (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fpu_register_t ('0'::('0'::('0'::[])))
              (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
                fpu_reg))) (fun x ->
          Obj.magic (FCOMP (FPS_op (Obj.magic x))))))
  
  (** val coq_FCOMPP_p : grammar **)
  
  let coq_FCOMPP_p =
    map (bits_n (length0 ('0'::('0'::('1'::[]))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
          ('1'::('1'::('0'::[])))
          (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
            ('1'::('1'::('0'::('1'::('1'::[])))))
            (bits ('0'::('0'::('1'::[]))))))) (fun x -> Obj.magic FCOMPP)
  
  (** val coq_FCOMIP_p : grammar **)
  
  let coq_FCOMIP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FCOMIP (FPS_op (Obj.magic x))))
  
  (** val coq_FCOS_p : grammar **)
  
  let coq_FCOS_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::[])))
          (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
            ('1'::('1'::('1'::[])))
            (bits ('1'::('1'::('1'::('1'::('1'::[]))))))))) (fun x ->
      Obj.magic FCOS)
  
  (** val coq_FDECSTP_p : grammar **)
  
  let coq_FDECSTP_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::[])))
          (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
            ('1'::('1'::('1'::[])))
            (bits ('1'::('0'::('1'::('1'::('0'::[]))))))))) (fun x ->
      Obj.magic FDECSTP)
  
  (** val coq_FDIV_p : grammar **)
  
  let coq_FDIV_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FDIV (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('1'::('0'::[])))))) (fun x ->
          Obj.magic (FDIV (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::[]))))
                    (bitsleft fpu_register_t ('0'::[]) fpu_reg))))) (fun i ->
            Obj.magic (FDIV (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('1'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FDIV (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FDIVP_p : grammar **)
  
  let coq_FDIVP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FDIVP (FPS_op (Obj.magic x))))
  
  (** val coq_FDIVR_p : grammar **)
  
  let coq_FDIVR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FDIVR (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FDIVR (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('1'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FDIVR (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('1'::[])
                      (bitsleft fpu_register_t ('0'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FDIVR (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FDIVRP_p : grammar **)
  
  let coq_FDIVRP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FDIVRP (FPS_op (Obj.magic x))))
  
  (** val coq_FFREE_p : grammar **)
  
  let coq_FFREE_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FFREE (FPS_op (Obj.magic x))))
  
  (** val coq_FIADD_p : grammar **)
  
  let coq_FIADD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FIADD (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FIADD (Obj.magic x))))
  
  (** val coq_FICOM_p : grammar **)
  
  let coq_FICOM_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FICOM (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FICOM (Obj.magic x))))
  
  (** val coq_FICOMP_p : grammar **)
  
  let coq_FICOMP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FICOMP (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FICOMP (Obj.magic x))))
  
  (** val coq_FIDIV_p : grammar **)
  
  let coq_FIDIV_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIDIV (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIDIV (Obj.magic x))))
  
  (** val coq_FIDIVR_p : grammar **)
  
  let coq_FIDIVR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FIDIVR (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FIDIVR (Obj.magic x))))
  
  (** val coq_FILD_p : grammar **)
  
  let coq_FILD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
            (ext_op_modrm_FPM16 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FILD (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
              (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FILD (Obj.magic x))))
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
              (ext_op_modrm_FPM64 ('1'::('0'::('1'::[])))))) (fun x ->
          Obj.magic (FILD (Obj.magic x)))))
  
  (** val coq_FIMUL_p : grammar **)
  
  let coq_FIMUL_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FIMUL (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FIMUL (Obj.magic x))))
  
  (** val coq_FINCSTP_p : grammar **)
  
  let coq_FINCSTP_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('1'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FINCSTP)
  
  (** val coq_FIST_p : grammar **)
  
  let coq_FIST_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIST (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIST (Obj.magic x))))
  
  (** val coq_FISTP_p : grammar **)
  
  let coq_FISTP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FISTP (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
              (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FISTP (Obj.magic x))))
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
              (ext_op_modrm_FPM64 ('1'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FISTP (Obj.magic x)))))
  
  (** val coq_FISUB_p : grammar **)
  
  let coq_FISUB_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FISUB (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FISUB (Obj.magic x))))
  
  (** val coq_FISUBR_p : grammar **)
  
  let coq_FISUBR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FISUBR (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FISUBR (Obj.magic x))))
  
  (** val coq_FLD_p : grammar **)
  
  let coq_FLD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FLD (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
              (ext_op_modrm_FPM64 ('0'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FLD (Obj.magic x))))
        (alt instruction_t
          (map fp_operand_t instruction_t
            (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
                (ext_op_modrm_FPM80 ('1'::('0'::('1'::[])))))) (fun x ->
            Obj.magic (FLD (Obj.magic x))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::('0'::('1'::[])))
                (bitsleft fpu_register_t
                  ('1'::('1'::('0'::('0'::('0'::[]))))) fpu_reg))) (fun x ->
            Obj.magic (FLD (FPS_op (Obj.magic x)))))))
  
  (** val coq_FLD1_p : grammar **)
  
  let coq_FLD1_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FLD1)
  
  (** val coq_FLDCW_p : grammar **)
  
  let coq_FLDCW_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('0'::('1'::[])))))) (fun x ->
      Obj.magic (FLDCW (Obj.magic x)))
  
  (** val coq_FLDENV_p : grammar **)
  
  let coq_FLDENV_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
      Obj.magic (FLDENV (Obj.magic x)))
  
  (** val coq_FLDL2E_p : grammar **)
  
  let coq_FLDL2E_p =
    map (bits_n (length0 ('0'::('1'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FLDL2E)
  
  (** val coq_FLDL2T_p : grammar **)
  
  let coq_FLDL2T_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FLDL2T)
  
  (** val coq_FLDLG2_p : grammar **)
  
  let coq_FLDLG2_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FLDLG2)
  
  (** val coq_FLDLN2_p : grammar **)
  
  let coq_FLDLN2_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FLDLN2)
  
  (** val coq_FLDPI_p : grammar **)
  
  let coq_FLDPI_p =
    map (bits_n (length0 ('0'::('1'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FLDPI)
  
  (** val coq_FLDZ_p : grammar **)
  
  let coq_FLDZ_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('1'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FLDZ)
  
  (** val coq_FMUL_p : grammar **)
  
  let coq_FMUL_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FMUL (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('0'::('1'::[])))))) (fun x ->
          Obj.magic (FMUL (true, (Obj.magic x)))))
        (map (Pair_t (Char_t, fpu_register_t)) instruction_t
          (bitsleft (Pair_t (Char_t, fpu_register_t))
            ('1'::('1'::('0'::('1'::('1'::[])))))
            (seq Char_t fpu_register_t anybit
              (bitsleft fpu_register_t ('0'::('0'::[]))
                (bitsleft fpu_register_t
                  ('1'::('1'::('0'::('0'::('1'::[]))))) fpu_reg)))) (fun p ->
          let (d, s) = Obj.magic p in Obj.magic (FMUL (d, (FPS_op s))))))
  
  (** val coq_FMULP_p : grammar **)
  
  let coq_FMULP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FMULP (FPS_op (Obj.magic x))))
  
  (** val coq_FNCLEX_p : grammar **)
  
  let coq_FNCLEX_p =
    map (bits_n (length0 ('0'::('0'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('0'::[])))))))
          ('0'::('1'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FNCLEX)
  
  (** val coq_FNINIT_p : grammar **)
  
  let coq_FNINIT_p =
    map (bits_n (length0 ('0'::('0'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('1'::[])))))))
          ('0'::('1'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FNINIT)
  
  (** val coq_FNOP_p : grammar **)
  
  let coq_FNOP_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('0'::[]))))))
          (bits ('1'::('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FNOP)
  
  (** val coq_FNSAVE_p : grammar **)
  
  let coq_FNSAVE_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t
        ('1'::('1'::('0'::('1'::('1'::('1'::('0'::('1'::[]))))))))
        (ext_op_modrm_FPM64 ('1'::('1'::('0'::[]))))) (fun x ->
      Obj.magic (FNSAVE (Obj.magic x)))
  
  (** val coq_FNSTCW_p : grammar **)
  
  let coq_FNSTCW_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
      Obj.magic (FNSTCW (Obj.magic x)))
  
  (** val coq_FNSTSW_p : grammar **)
  
  let coq_FNSTSW_p =
    alt instruction_t
      (map (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
        instruction_t
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
          ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
            ('1'::('1'::('1'::[])))
            (bitsleft
              (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
              ('1'::('1'::('1'::[])))
              (bits ('0'::('0'::('0'::('0'::('0'::[]))))))))) (fun x ->
        Obj.magic (FNSTSW None)))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FNSTSW (Some (Obj.magic x)))))
  
  (** val coq_FPATAN_p : grammar **)
  
  let coq_FPATAN_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FPATAN)
  
  (** val coq_FPREM_p : grammar **)
  
  let coq_FPREM_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FPREM)
  
  (** val coq_FPREM1_p : grammar **)
  
  let coq_FPREM1_p =
    map (bits_n (length0 ('1'::('0'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FPREM1)
  
  (** val coq_FPTAN_p : grammar **)
  
  let coq_FPTAN_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FPTAN)
  
  (** val coq_FRNDINT_p : grammar **)
  
  let coq_FRNDINT_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FRNDINT)
  
  (** val coq_FRSTOR_p : grammar **)
  
  let coq_FRSTOR_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
      Obj.magic (FRSTOR (Obj.magic x)))
  
  (** val coq_FSCALE_p : grammar **)
  
  let coq_FSCALE_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FSCALE)
  
  (** val coq_FSIN_p : grammar **)
  
  let coq_FSIN_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('1'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FSIN)
  
  (** val coq_FSINCOS_p : grammar **)
  
  let coq_FSINCOS_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FSINCOS)
  
  (** val coq_FSQRT_p : grammar **)
  
  let coq_FSQRT_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FSQRT)
  
  (** val coq_FST_p : grammar **)
  
  let coq_FST_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FST (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('0'::[])))))) (fun x ->
          Obj.magic (FST (Obj.magic x))))
        (map fpu_register_t instruction_t
          (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
              (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('0'::[])))))
                fpu_reg))) (fun x -> Obj.magic (FST (FPS_op (Obj.magic x))))))
  
  (** val coq_FSTENV_p : grammar **)
  
  let coq_FSTENV_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('1'::('0'::[])))))) (fun x ->
      Obj.magic (FSTENV (Obj.magic x)))
  
  (** val coq_FSTP_p : grammar **)
  
  let coq_FSTP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FSTP (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FSTP (Obj.magic x))))
        (alt instruction_t
          (map fp_operand_t instruction_t
            (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
                (ext_op_modrm_FPM80 ('1'::('1'::('1'::[])))))) (fun x ->
            Obj.magic (FSTP (Obj.magic x))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
                (bitsleft fpu_register_t
                  ('1'::('1'::('0'::('1'::('1'::[]))))) fpu_reg))) (fun x ->
            Obj.magic (FSTP (FPS_op (Obj.magic x)))))))
  
  (** val coq_FSUB_p : grammar **)
  
  let coq_FSUB_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FSUB (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FSUB (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('0'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUB (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUB (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FSUBP_p : grammar **)
  
  let coq_FSUBP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FSUBP (FPS_op (Obj.magic x))))
  
  (** val coq_FSUBR_p : grammar **)
  
  let coq_FSUBR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FSUBR (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('0'::('1'::[])))))) (fun x ->
          Obj.magic (FSUBR (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUBR (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('0'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUBR (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FSUBRP_p : grammar **)
  
  let coq_FSUBRP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FSUBRP (FPS_op (Obj.magic x))))
  
  (** val coq_FTST_p : grammar **)
  
  let coq_FTST_p =
    map (bits_n (length0 ('0'::('0'::('1'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FTST)
  
  (** val coq_FUCOM_p : grammar **)
  
  let coq_FUCOM_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOM (FPS_op (Obj.magic x))))
  
  (** val coq_FUCOMP_p : grammar **)
  
  let coq_FUCOMP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOMP (FPS_op (Obj.magic x))))
  
  (** val coq_FUCOMPP_p : grammar **)
  
  let coq_FUCOMPP_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
          ('0'::('1'::('0'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FUCOMPP)
  
  (** val coq_FUCOMI_p : grammar **)
  
  let coq_FUCOMI_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('0'::('1'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOMI (FPS_op (Obj.magic x))))
  
  (** val coq_FUCOMIP_p : grammar **)
  
  let coq_FUCOMIP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOMIP (FPS_op (Obj.magic x))))
  
  (** val coq_FXAM_p : grammar **)
  
  let coq_FXAM_p =
    map (bits_n (length0 ('0'::('0'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FXAM)
  
  (** val coq_FXCH_p : grammar **)
  
  let coq_FXCH_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('0'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FXCH (FPS_op (Obj.magic x))))
  
  (** val coq_FXTRACT_p : grammar **)
  
  let coq_FXTRACT_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
          ('0'::('0'::('1'::[])))
          (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
            ('1'::('1'::('1'::('1'::[]))))
            (bits ('0'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FXTRACT)
  
  (** val coq_FYL2X_p : grammar **)
  
  let coq_FYL2X_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FYL2X)
  
  (** val coq_FYL2XP1_p : grammar **)
  
  let coq_FYL2XP1_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FYL2XP1)
  
  (** val coq_FWAIT_p : grammar **)
  
  let coq_FWAIT_p =
    map
      (bits_n
        (length0 ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('1'::[]))))))))))
      instruction_t
      (bits ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('1'::[])))))))))
      (fun x -> Obj.magic FWAIT)
  
  (** val mmx_gg_p : bool -> bool -> bool -> bool -> grammar **)
  
  let mmx_gg_p byte0 twob fourb eightb =
    let byte_p =
      if byte0
      then map (bits_n (length0 ('0'::('0'::[])))) mmx_granularity_t
             (bits ('0'::('0'::[]))) (fun x -> Obj.magic MMX_8)
      else never mmx_granularity_t
    in
    let twobytes_p =
      if twob
      then map (bits_n (length0 ('0'::('1'::[])))) mmx_granularity_t
             (bits ('0'::('1'::[]))) (fun x -> Obj.magic MMX_16)
      else never mmx_granularity_t
    in
    let fourbytes_p =
      if fourb
      then map (bits_n (length0 ('1'::('0'::[])))) mmx_granularity_t
             (bits ('1'::('0'::[]))) (fun x -> Obj.magic MMX_32)
      else never mmx_granularity_t
    in
    let eightbytes_p =
      if eightb
      then map (bits_n (length0 ('1'::('1'::[])))) mmx_granularity_t
             (bits ('1'::('1'::[]))) (fun x -> Obj.magic MMX_64)
      else never mmx_granularity_t
    in
    alt mmx_granularity_t byte_p
      (alt mmx_granularity_t twobytes_p
        (alt mmx_granularity_t fourbytes_p eightbytes_p))
  
  (** val coq_EMMS_p : grammar **)
  
  let coq_EMMS_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
            ('0'::('1'::('1'::('1'::[]))))
            (bits ('0'::('1'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic EMMS)
  
  (** val coq_MOVD_p : grammar **)
  
  let coq_MOVD_p =
    alt instruction_t
      (map (Pair_t (mmx_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (mmx_register_t, register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_register_t, register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_register_t, register_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (mmx_register_t, register_t))
                ('1'::('1'::('1'::('0'::[]))))
                (bitsleft (Pair_t (mmx_register_t, register_t))
                  ('1'::('1'::[]))
                  (seq mmx_register_t register_t mmx_reg reg)))))) (fun p ->
        let (m, r2) = Obj.magic p in
        Obj.magic (MOVD ((GP_Reg_op r2), (MMX_Reg_op m)))))
      (alt instruction_t
        (map (Pair_t (mmx_register_t, register_t)) instruction_t
          (bitsleft (Pair_t (mmx_register_t, register_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (mmx_register_t, register_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_register_t, register_t))
                ('0'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (mmx_register_t, register_t))
                  ('1'::('1'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (mmx_register_t, register_t))
                    ('1'::('1'::[]))
                    (seq mmx_register_t register_t mmx_reg reg))))))
          (fun p ->
          let (m, r2) = Obj.magic p in
          Obj.magic (MOVD ((GP_Reg_op r2), (MMX_Reg_op m)))))
        (alt instruction_t
          (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                    ('1'::('1'::('1'::('0'::[])))) modrm_mmx)))) (fun p ->
            let (op1, op2) = Obj.magic p in Obj.magic (MOVD (op1, op2))))
          (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                  ('0'::('1'::('1'::('1'::[]))))
                  (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                    ('1'::('1'::('1'::('0'::[])))) modrm_mmx)))) (fun p ->
            let (mem, mmx) = Obj.magic p in Obj.magic (MOVD (mmx, mem))))))
  
  (** val coq_MOVQ_p : grammar **)
  
  let coq_MOVQ_p =
    alt instruction_t
      (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVQ (op1, op2))))
      (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVQ (op2, op1))))
  
  (** val coq_PACKSSDW_p : grammar **)
  
  let coq_PACKSSDW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PACKSSDW (op1, op2)))
  
  (** val coq_PACKSSWB_p : grammar **)
  
  let coq_PACKSSWB_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PACKSSWB (op1, op2)))
  
  (** val coq_PACKUSWB_p : grammar **)
  
  let coq_PACKUSWB_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PACKUSWB (op1, op2)))
  
  (** val coq_PADD_p : grammar **)
  
  let coq_PADD_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PADD (gg, op1, op2)))
  
  (** val coq_PADDS_p : grammar **)
  
  let coq_PADDS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PADDS (gg, op1, op2)))
  
  (** val coq_PADDUS_p : grammar **)
  
  let coq_PADDUS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PADDUS (gg, op1, op2)))
  
  (** val coq_PAND_p : grammar **)
  
  let coq_PAND_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PAND (op1, op2)))
  
  (** val coq_PANDN_p : grammar **)
  
  let coq_PANDN_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PANDN (op1, op2)))
  
  (** val coq_PCMPEQ_p : grammar **)
  
  let coq_PCMPEQ_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('0'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PCMPEQ (gg, op1, op2)))
  
  (** val coq_PCMPGT_p : grammar **)
  
  let coq_PCMPGT_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('0'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PCMPGT (gg, op1, op2)))
  
  (** val coq_PMADDWD_p : grammar **)
  
  let coq_PMADDWD_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMADDWD (op1, op2)))
  
  (** val coq_PMULHUW_p : grammar **)
  
  let coq_PMULHUW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMULHUW (op1, op2)))
  
  (** val coq_PMULHW_p : grammar **)
  
  let coq_PMULHW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMULHW (op1, op2)))
  
  (** val coq_PMULLW_p : grammar **)
  
  let coq_PMULLW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMULLW (op1, op2)))
  
  (** val coq_POR_p : grammar **)
  
  let coq_POR_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (POR (op1, op2)))
  
  (** val coq_PSLL_p : grammar **)
  
  let coq_PSLL_p =
    alt instruction_t
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
                mmx_operand_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_operand_t,
                  mmx_operand_t)) (mmx_gg_p false true true true) modrm_mmx)))))
        (fun p ->
        let (gg, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (PSLL (gg, op1, op2))))
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
          byte_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
            byte_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
                byte_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_register_t, byte_t))
                  (mmx_gg_p false true true true)
                  (bitsleft (Pair_t (mmx_register_t, byte_t))
                    ('1'::('1'::('1'::('1'::('0'::[])))))
                    (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
        let (gg, i) = Obj.magic p in
        let (r2, imm) = i in
        Obj.magic (PSLL (gg, (MMX_Reg_op r2), (MMX_Imm_op
          (zero_extend8_32 imm))))))
  
  (** val coq_PSRA_p : grammar **)
  
  let coq_PSRA_p =
    alt instruction_t
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
                mmx_operand_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_operand_t,
                  mmx_operand_t)) (mmx_gg_p false true true false) modrm_mmx)))))
        (fun p ->
        let (gg, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (PSRA (gg, op1, op2))))
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
          byte_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
            byte_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
                byte_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_register_t, byte_t))
                  (mmx_gg_p false true true false)
                  (bitsleft (Pair_t (mmx_register_t, byte_t))
                    ('1'::('1'::('1'::('0'::('0'::[])))))
                    (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
        let (gg, i) = Obj.magic p in
        let (r2, imm) = i in
        Obj.magic (PSRA (gg, (MMX_Reg_op r2), (MMX_Imm_op
          (zero_extend8_32 imm))))))
  
  (** val coq_PSRL_p : grammar **)
  
  let coq_PSRL_p =
    alt instruction_t
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::('0'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
                mmx_operand_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_operand_t,
                  mmx_operand_t)) (mmx_gg_p false true true true) modrm_mmx)))))
        (fun p ->
        let (gg, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (PSRL (gg, op1, op2))))
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
          byte_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
            byte_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
                byte_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_register_t, byte_t))
                  (mmx_gg_p false true true true)
                  (bitsleft (Pair_t (mmx_register_t, byte_t))
                    ('1'::('1'::('0'::('1'::('0'::[])))))
                    (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
        let (gg, i) = Obj.magic p in
        let (r2, imm) = i in
        Obj.magic (PSRL (gg, (MMX_Reg_op r2), (MMX_Imm_op
          (zero_extend8_32 imm))))))
  
  (** val coq_PSUB_p : grammar **)
  
  let coq_PSUB_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PSUB (gg, op1, op2)))
  
  (** val coq_PSUBS_p : grammar **)
  
  let coq_PSUBS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PSUBS (gg, op1, op2)))
  
  (** val coq_PSUBUS_p : grammar **)
  
  let coq_PSUBUS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PSUBUS (gg, op1, op2)))
  
  (** val coq_PUNPCKH_p : grammar **)
  
  let coq_PUNPCKH_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PUNPCKH (gg, op1, op2)))
  
  (** val coq_PUNPCKL_p : grammar **)
  
  let coq_PUNPCKL_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('0'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PUNPCKL (gg, op1, op2)))
  
  (** val coq_PXOR_p : grammar **)
  
  let coq_PXOR_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PXOR (op1, op2)))
  
  (** val coq_ADDPS_p : grammar **)
  
  let coq_ADDPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ADDPS (op1, op2)))
  
  (** val coq_ADDSS_p : grammar **)
  
  let coq_ADDSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('0'::('0'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ADDSS (op1, op2)))
  
  (** val coq_ANDNPS_p : grammar **)
  
  let coq_ANDNPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ANDNPS (op1, op2)))
  
  (** val coq_ANDPS_p : grammar **)
  
  let coq_ANDPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ANDPS (op1, op2)))
  
  (** val coq_CMPPS_p : grammar **)
  
  let coq_CMPPS_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('0'::('0'::('1'::('0'::[]))))
              (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t modrm_xmm
                byte))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (CMPPS (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_CMPSS_p : grammar **)
  
  let coq_CMPSS_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
                byte_t)) ('1'::('1'::('0'::('0'::[]))))
                (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
                  byte_t)) ('0'::('0'::('1'::('0'::[]))))
                  (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t
                    modrm_xmm byte))))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (CMPSS (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_COMISS_p : grammar **)
  
  let coq_COMISS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (COMISS (op1, op2)))
  
  (** val coq_CVTPI2PS_p : grammar **)
  
  let coq_CVTPI2PS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (CVTPI2PS (op1, op2)))
  
  (** val coq_CVTPS2PI_p : grammar **)
  
  let coq_CVTPS2PI_p =
    alt instruction_t
      (map (Pair_t (sse_register_t, mmx_register_t)) instruction_t
        (bitsleft (Pair_t (sse_register_t, mmx_register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_register_t, mmx_register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, mmx_register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, mmx_register_t))
                ('1'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_register_t, mmx_register_t))
                  ('1'::('1'::[]))
                  (seq sse_register_t mmx_register_t sse_reg mmx_reg))))))
        (fun p ->
        let (sr, mr) = Obj.magic p in
        Obj.magic (CVTPS2PI ((SSE_XMM_Reg_op sr), (SSE_MM_Reg_op mr)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('0'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (xmm, mem) = Obj.magic p in Obj.magic (CVTPS2PI (xmm, mem))))
  
  (** val coq_CVTSI2SS_p : grammar **)
  
  let coq_CVTSI2SS_p =
    alt instruction_t
      (map (Pair_t (sse_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (sse_register_t, register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_register_t, register_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_register_t, register_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_register_t, register_t))
                    ('1'::('0'::('1'::('0'::[]))))
                    (bitsleft (Pair_t (sse_register_t, register_t))
                      ('1'::('1'::[]))
                      (seq sse_register_t register_t sse_reg reg))))))))
        (fun p ->
        let (sr, r2) = Obj.magic p in
        Obj.magic (CVTSI2SS ((SSE_XMM_Reg_op sr), (SSE_GP_Reg_op r2)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('1'::('0'::('1'::('0'::[])))) modrm_xmm_noreg))))))
        (fun p ->
        let (xmm, mem) = Obj.magic p in Obj.magic (CVTSI2SS (xmm, mem))))
  
  (** val coq_CVTSS2SI_p : grammar **)
  
  let coq_CVTSS2SI_p =
    alt instruction_t
      (map (Pair_t (register_t, sse_register_t)) instruction_t
        (bitsleft (Pair_t (register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, sse_register_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, sse_register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, sse_register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, sse_register_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, sse_register_t))
                    ('1'::('1'::('0'::('1'::[]))))
                    (bitsleft (Pair_t (register_t, sse_register_t))
                      ('1'::('1'::[]))
                      (seq register_t sse_register_t reg sse_reg))))))))
        (fun p ->
        let (r2, sr) = Obj.magic p in
        Obj.magic (CVTSS2SI ((SSE_GP_Reg_op r2), (SSE_XMM_Reg_op sr)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('1'::('1'::('0'::('1'::[])))) modrm_xmm_gp_noreg))))))
        (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (CVTSS2SI (op1, mem))))
  
  (** val coq_CVTTPS2PI_p : grammar **)
  
  let coq_CVTTPS2PI_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (CVTTPS2PI (op1, op2)))
  
  (** val coq_CVTTSS2SI_p : grammar **)
  
  let coq_CVTTSS2SI_p =
    alt instruction_t
      (map (Pair_t (register_t, sse_register_t)) instruction_t
        (bitsleft (Pair_t (register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, sse_register_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, sse_register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, sse_register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, sse_register_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, sse_register_t))
                    ('1'::('1'::('0'::('0'::[]))))
                    (bitsleft (Pair_t (register_t, sse_register_t))
                      ('1'::('1'::[]))
                      (seq register_t sse_register_t reg sse_reg))))))))
        (fun p ->
        let (r2, sr) = Obj.magic p in
        Obj.magic (CVTTSS2SI ((SSE_GP_Reg_op r2), (SSE_XMM_Reg_op sr)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('1'::('1'::('0'::('0'::[])))) modrm_xmm_gp_noreg))))))
        (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (CVTTSS2SI (op1, mem))))
  
  (** val coq_DIVPS_p : grammar **)
  
  let coq_DIVPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (DIVPS (op1, op2)))
  
  (** val coq_DIVSS_p : grammar **)
  
  let coq_DIVSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('1'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (DIVSS (op1, op2)))
  
  (** val coq_LDMXCSR_p : grammar **)
  
  let coq_LDMXCSR_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('1'::('0'::('1'::('0'::[]))))
            (bitsleft sse_operand_t ('1'::('1'::('1'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic (LDMXCSR (Obj.magic x)))
  
  (** val coq_MAXPS_p : grammar **)
  
  let coq_MAXPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MAXPS (op1, op2)))
  
  (** val coq_MAXSS_p : grammar **)
  
  let coq_MAXSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('1'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MAXSS (op1, op2)))
  
  (** val coq_MINPS_p : grammar **)
  
  let coq_MINPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MINPS (op1, op2)))
  
  (** val coq_MINSS_p : grammar **)
  
  let coq_MINSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MINSS (op1, op2)))
  
  (** val coq_MOVAPS_p : grammar **)
  
  let coq_MOVAPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('0'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVAPS (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVAPS (op1, op2))))
  
  (** val coq_MOVHLPS_p : grammar **)
  
  let coq_MOVHLPS_p =
    map (Pair_t (sse_register_t, sse_register_t)) instruction_t
      (bitsleft (Pair_t (sse_register_t, sse_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_register_t, sse_register_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, sse_register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, sse_register_t))
                ('1'::('1'::[]))
                (seq sse_register_t sse_register_t sse_reg sse_reg))))))
      (fun p ->
      let (sr1, sr2) = Obj.magic p in
      Obj.magic (MOVHLPS ((SSE_XMM_Reg_op sr1), (SSE_XMM_Reg_op sr2))))
  
  (** val coq_MOVHPS_p : grammar **)
  
  let coq_MOVHPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('1'::('0'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVHPS (op1, mem))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('1'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVHPS (mem, op1))))
  
  (** val coq_MOVLHPS_p : grammar **)
  
  let coq_MOVLHPS_p =
    map (Pair_t (sse_register_t, sse_register_t)) instruction_t
      (bitsleft (Pair_t (sse_register_t, sse_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_register_t, sse_register_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, sse_register_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, sse_register_t))
                ('1'::('1'::[]))
                (seq sse_register_t sse_register_t sse_reg sse_reg))))))
      (fun p ->
      let (sr1, sr2) = Obj.magic p in
      Obj.magic (MOVLHPS ((SSE_XMM_Reg_op sr1), (SSE_XMM_Reg_op sr2))))
  
  (** val coq_MOVLPS_p : grammar **)
  
  let coq_MOVLPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('1'::('0'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVLPS (op1, mem))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('1'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVLPS (mem, op1))))
  
  (** val coq_MOVMSKPS_p : grammar **)
  
  let coq_MOVMSKPS_p =
    map (Pair_t (register_t, sse_register_t)) instruction_t
      (bitsleft (Pair_t (register_t, sse_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, sse_register_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (register_t, sse_register_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (register_t, sse_register_t))
                ('1'::('1'::[])) (seq register_t sse_register_t reg sse_reg))))))
      (fun p ->
      let (r2, sr) = Obj.magic p in
      Obj.magic (MOVMSKPS ((SSE_GP_Reg_op r2), (SSE_XMM_Reg_op sr))))
  
  (** val coq_MOVSS_p : grammar **)
  
  let coq_MOVSS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('0'::('1'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('0'::('0'::('0'::('0'::[])))) modrm_xmm)))))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVSS (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('0'::('1'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVSS (op2, op1))))
  
  (** val coq_MOVUPS_p : grammar **)
  
  let coq_MOVUPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVUPS (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVUPS (op2, op1))))
  
  (** val coq_MULPS_p : grammar **)
  
  let coq_MULPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MULPS (op1, op2)))
  
  (** val coq_MULSS_p : grammar **)
  
  let coq_MULSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('0'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MULSS (op1, op2)))
  
  (** val coq_ORPS_p : grammar **)
  
  let coq_ORPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ORPS (op1, op2)))
  
  (** val coq_RCPPS_p : grammar **)
  
  let coq_RCPPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RCPPS (op1, op2)))
  
  (** val coq_RCPSS_p : grammar **)
  
  let coq_RCPSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RCPSS (op1, op2)))
  
  (** val coq_RSQRTPS_p : grammar **)
  
  let coq_RSQRTPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RSQRTPS (op1, op2)))
  
  (** val coq_RSQRTSS_p : grammar **)
  
  let coq_RSQRTSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RSQRTSS (op1, op2)))
  
  (** val coq_SHUFPS_p : grammar **)
  
  let coq_SHUFPS_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('0'::('1'::('1'::('0'::[]))))
              (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t modrm_xmm
                byte))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (SHUFPS (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_SQRTPS_p : grammar **)
  
  let coq_SQRTPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SQRTPS (op1, op2)))
  
  (** val coq_SQRTSS_p : grammar **)
  
  let coq_SQRTSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SQRTSS (op1, op2)))
  
  (** val coq_STMXCSR_p : grammar **)
  
  let coq_STMXCSR_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('1'::('0'::('1'::('0'::[]))))
            (bitsleft sse_operand_t ('1'::('1'::('1'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (STMXCSR (Obj.magic x)))
  
  (** val coq_SUBPS_p : grammar **)
  
  let coq_SUBPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SUBPS (op1, op2)))
  
  (** val coq_SUBSS_p : grammar **)
  
  let coq_SUBSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('0'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SUBSS (op1, op2)))
  
  (** val coq_UCOMISS_p : grammar **)
  
  let coq_UCOMISS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (UCOMISS (op1, op2)))
  
  (** val coq_UNPCKHPS_p : grammar **)
  
  let coq_UNPCKHPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (UNPCKHPS (op1, op2)))
  
  (** val coq_UNPCKLPS_p : grammar **)
  
  let coq_UNPCKLPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (UNPCKLPS (op1, op2)))
  
  (** val coq_XORPS_p : grammar **)
  
  let coq_XORPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (XORPS (op1, op2)))
  
  (** val coq_PAVGB_p : grammar **)
  
  let coq_PAVGB_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('0'::('0'::[])))) modrm_mm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (PAVGB (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('1'::('1'::[])))) modrm_mm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (PAVGB (op2, op1))))
  
  (** val coq_PEXTRW_p : grammar **)
  
  let coq_PEXTRW_p =
    map (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
      instruction_t
      (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('0'::('1'::[]))))
              (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t,
                byte_t)))) ('1'::('1'::[]))
                (seq register_t (Pair_t (mmx_register_t, byte_t)) reg
                  (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
      let (r32, i) = Obj.magic p in
      let (mmx, imm) = i in
      Obj.magic (PEXTRW ((SSE_GP_Reg_op r32), (SSE_MM_Reg_op mmx),
        (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_PINSRW_p : grammar **)
  
  let coq_PINSRW_p =
    alt instruction_t
      (map (Pair_t (mmx_register_t, (Pair_t (register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t, byte_t))))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t, byte_t))))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t,
              byte_t)))) ('1'::('1'::('0'::('0'::[]))))
              (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t,
                byte_t)))) ('0'::('1'::('0'::('0'::[]))))
                (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t,
                  byte_t)))) ('1'::('1'::[]))
                  (seq mmx_register_t (Pair_t (register_t, byte_t)) mmx_reg
                    (seq register_t byte_t reg byte))))))) (fun p ->
        let (mmx, i) = Obj.magic p in
        let (r32, imm) = i in
        Obj.magic (PINSRW ((SSE_MM_Reg_op mmx), (SSE_GP_Reg_op r32),
          (SSE_Imm_op (zero_extend8_32 imm))))))
      (map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        instruction_t
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('1'::('1'::('0'::('0'::[]))))
              (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
                byte_t)) ('0'::('1'::('0'::('0'::[]))))
                (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t
                  modrm_mm_noreg byte))))) (fun p ->
        let (i, imm) = Obj.magic p in
        let (op1, mem) = i in
        Obj.magic (PINSRW (op1, mem, (SSE_Imm_op (zero_extend8_32 imm))))))
  
  (** val coq_PMAXSW_p : grammar **)
  
  let coq_PMAXSW_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMAXSW (op1, op2)))
  
  (** val coq_PMAXUB_p : grammar **)
  
  let coq_PMAXUB_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMAXUB (op1, op2)))
  
  (** val coq_PMINSW_p : grammar **)
  
  let coq_PMINSW_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMINSW (op1, op2)))
  
  (** val coq_PMINUB_p : grammar **)
  
  let coq_PMINUB_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMINUB (op1, op2)))
  
  (** val coq_PMOVMSKB_p : grammar **)
  
  let coq_PMOVMSKB_p =
    map (Pair_t (register_t, mmx_register_t)) instruction_t
      (bitsleft (Pair_t (register_t, mmx_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (register_t, mmx_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, mmx_register_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (register_t, mmx_register_t))
              ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (register_t, mmx_register_t))
                ('1'::('1'::[])) (seq register_t mmx_register_t reg mmx_reg))))))
      (fun p ->
      let (r2, mr) = Obj.magic p in
      Obj.magic (PMOVMSKB ((SSE_GP_Reg_op r2), (SSE_MM_Reg_op mr))))
  
  (** val coq_PSADBW_p : grammar **)
  
  let coq_PSADBW_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PSADBW (op1, op2)))
  
  (** val coq_PSHUFW_p : grammar **)
  
  let coq_PSHUFW_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('0'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('0'::('0'::('0'::('0'::[]))))
              (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t modrm_mm
                byte))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (PSHUFW (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_MASKMOVQ_p : grammar **)
  
  let coq_MASKMOVQ_p =
    map (Pair_t (mmx_register_t, mmx_register_t)) instruction_t
      (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
              ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
                ('1'::('1'::[]))
                (seq mmx_register_t mmx_register_t mmx_reg mmx_reg))))))
      (fun p ->
      let (mr1, mr2) = Obj.magic p in
      Obj.magic (MASKMOVQ ((SSE_MM_Reg_op mr1), (SSE_MM_Reg_op mr2))))
  
  (** val coq_MOVNTPS_p : grammar **)
  
  let coq_MOVNTPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
      let (op1, mem) = Obj.magic p in Obj.magic (MOVNTPS (mem, op1)))
  
  (** val coq_MOVNTQ_p : grammar **)
  
  let coq_MOVNTQ_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('1'::[])))) modrm_mm_noreg)))) (fun p ->
      let (op1, mem) = Obj.magic p in Obj.magic (MOVNTQ (mem, op1)))
  
  (** val coq_PREFETCHT0_p : grammar **)
  
  let coq_PREFETCHT0_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (PREFETCHT0 (Obj.magic x)))
  
  (** val coq_PREFETCHT1_p : grammar **)
  
  let coq_PREFETCHT1_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic (PREFETCHT1 (Obj.magic x)))
  
  (** val coq_PREFETCHT2_p : grammar **)
  
  let coq_PREFETCHT2_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (PREFETCHT2 (Obj.magic x)))
  
  (** val coq_PREFETCHNTA_p : grammar **)
  
  let coq_PREFETCHNTA_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (PREFETCHNTA (Obj.magic x)))
  
  (** val coq_SFENCE_p : grammar **)
  
  let coq_SFENCE_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
            ('1'::('0'::('1'::('0'::[]))))
            (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
              ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
                ('1'::('1'::('1'::('1'::[]))))
                (bits ('1'::('0'::('0'::('0'::[])))))))))) (fun x ->
      Obj.magic SFENCE)
  
  (** val list2pair_t : type0 list -> type0 **)
  
  let rec list2pair_t = function
  | [] -> Unit_t
  | r2 :: l' ->
    (match l' with
     | [] -> Pair_t (r2, (list2pair_t l'))
     | r' :: l0 ->
       (match l0 with
        | [] -> Pair_t (r2, r')
        | t0 :: l1 -> Pair_t (r2, (list2pair_t l'))))
  
  (** val lock_p : grammar **)
  
  let lock_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) lock_or_rep_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('0'::('0'::('0'::('0'::[]))))))
      (fun x -> Obj.magic Lock)
  
  (** val rep_or_repn_p : grammar **)
  
  let rep_or_repn_p =
    alt lock_or_rep_t
      (map (bits_n (length0 ('0'::('0'::('1'::('0'::[])))))) lock_or_rep_t
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bits ('0'::('0'::('1'::('0'::[])))))) (fun x -> Obj.magic Repn))
      (map (bits_n (length0 ('0'::('0'::('1'::('1'::[])))))) lock_or_rep_t
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bits ('0'::('0'::('1'::('1'::[])))))) (fun x -> Obj.magic Rep))
  
  (** val rep_p : grammar **)
  
  let rep_p =
    map (bits_n (length0 ('0'::('0'::('1'::('1'::[])))))) lock_or_rep_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('0'::('0'::('1'::('1'::[]))))))
      (fun x -> Obj.magic Rep)
  
  (** val lock_or_rep_p : grammar **)
  
  let lock_or_rep_p =
    bitsleft lock_or_rep_t ('1'::('1'::('1'::('1'::[]))))
      (alt lock_or_rep_t
        (map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) lock_or_rep_t
          (bits ('0'::('0'::('0'::('0'::[]))))) (fun x -> Obj.magic Lock))
        (alt lock_or_rep_t
          (map (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
            lock_or_rep_t (bits ('0'::('0'::('1'::('0'::[]))))) (fun x ->
            Obj.magic Repn))
          (map (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
            lock_or_rep_t (bits ('0'::('0'::('1'::('1'::[]))))) (fun x ->
            Obj.magic Rep))))
  
  (** val segment_override_p : grammar **)
  
  let segment_override_p =
    alt segment_register_t
      (map (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
        segment_register_t
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
          ('0'::('0'::('1'::('0'::[]))))
          (bits ('1'::('1'::('1'::('0'::[])))))) (fun x -> Obj.magic CS))
      (alt segment_register_t
        (map (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
          segment_register_t
          (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('1'::('1'::('0'::[])))))) (fun x -> Obj.magic SS))
        (alt segment_register_t
          (map (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
            segment_register_t
            (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
              ('0'::('0'::('1'::('1'::[]))))
              (bits ('1'::('1'::('1'::('0'::[])))))) (fun x -> Obj.magic DS))
          (alt segment_register_t
            (map (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
              segment_register_t
              (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
                ('0'::('0'::('1'::('0'::[]))))
                (bits ('0'::('1'::('1'::('0'::[])))))) (fun x ->
              Obj.magic ES))
            (alt segment_register_t
              (map (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
                segment_register_t
                (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bits ('0'::('1'::('0'::('0'::[])))))) (fun x ->
                Obj.magic FS))
              (map (bits_n (length0 ('0'::('1'::('0'::('1'::[]))))))
                segment_register_t
                (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::[]))))))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bits ('0'::('1'::('0'::('1'::[])))))) (fun x ->
                Obj.magic GS))))))
  
  (** val op_override_p : grammar **)
  
  let op_override_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::[])))))) bool_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
        ('0'::('1'::('1'::('0'::[])))) (bits ('0'::('1'::('1'::('0'::[]))))))
      (fun x -> Obj.magic true)
  
  (** val addr_override_p : grammar **)
  
  let addr_override_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) bool_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('0'::('1'::('1'::('0'::[])))) (bits ('0'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic true)
  
  (** val perm2 : type0 -> type0 -> grammar -> grammar -> grammar **)
  
  let perm2 t1 t2 p1 p2 =
    alt (Pair_t (t1, t2)) (seq t1 t2 p1 p2)
      (map (Pair_t (t2, t1)) (Pair_t (t1, t2)) (seq t2 t1 p2 p1) (fun p ->
        let (a, b) = Obj.magic p in Obj.magic (b, a)))
  
  (** val perm3 :
      type0 -> type0 -> type0 -> grammar -> grammar -> grammar -> grammar **)
  
  let perm3 t1 t2 t3 p1 p2 p3 =
    let r_t = Pair_t (t1, (Pair_t (t2, t3))) in
    alt (Pair_t (t1, (Pair_t (t2, t3))))
      (seq t1 (Pair_t (t2, t3)) p1 (perm2 t2 t3 p2 p3))
      (alt r_t
        (map (Pair_t (t2, (Pair_t (t1, t3)))) r_t
          (seq t2 (Pair_t (t1, t3)) p2 (perm2 t1 t3 p1 p3)) (fun p ->
          let (b, i) = Obj.magic p in let (a, c) = i in Obj.magic (a, (b, c))))
        (map (Pair_t (t3, (Pair_t (t1, t2)))) r_t
          (seq t3 (Pair_t (t1, t2)) p3 (perm2 t1 t2 p1 p2)) (fun p ->
          let (c, i) = Obj.magic p in let (a, b) = i in Obj.magic (a, (b, c)))))
  
  (** val perm4 :
      type0 -> type0 -> type0 -> type0 -> grammar -> grammar -> grammar ->
      grammar -> grammar **)
  
  let perm4 t1 t2 t3 t4 p1 p2 p3 p4 =
    let r_t = Pair_t (t1, (Pair_t (t2, (Pair_t (t3, t4))))) in
    alt (Pair_t (t1, (Pair_t (t2, (Pair_t (t3, t4))))))
      (seq t1 (Pair_t (t2, (Pair_t (t3, t4)))) p1 (perm3 t2 t3 t4 p2 p3 p4))
      (alt r_t
        (map (Pair_t (t2, (Pair_t (t1, (Pair_t (t3, t4)))))) r_t
          (seq t2 (Pair_t (t1, (Pair_t (t3, t4)))) p2
            (perm3 t1 t3 t4 p1 p3 p4)) (fun p ->
          let (b, i) = Obj.magic p in
          let (a, i0) = i in let (c, d) = i0 in Obj.magic (a, (b, (c, d)))))
        (alt r_t
          (map (Pair_t (t3, (Pair_t (t1, (Pair_t (t2, t4)))))) r_t
            (seq t3 (Pair_t (t1, (Pair_t (t2, t4)))) p3
              (perm3 t1 t2 t4 p1 p2 p4)) (fun p ->
            let (c, i) = Obj.magic p in
            let (a, i0) = i in let (b, d) = i0 in Obj.magic (a, (b, (c, d)))))
          (map (Pair_t (t4, (Pair_t (t1, (Pair_t (t2, t3)))))) r_t
            (seq t4 (Pair_t (t1, (Pair_t (t2, t3)))) p4
              (perm3 t1 t2 t3 p1 p2 p3)) (fun p ->
            let (d, i) = Obj.magic p in
            let (a, i0) = i in let (b, c) = i0 in Obj.magic (a, (b, (c, d)))))))
  
  (** val option_perm : X86_PARSER_ARG.user_type -> grammar -> grammar **)
  
  let option_perm t1 p1 =
    let r_t = option_t t1 in
    alt r_t (map Unit_t r_t Eps (fun p -> Obj.magic None))
      (map (User_t t1) r_t p1 (fun p -> Obj.magic (Some p)))
  
  (** val option_perm2 :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type -> grammar ->
      grammar -> grammar **)
  
  let option_perm2 t1 t2 p1 p2 =
    let r_t = Pair_t ((option_t t1), (option_t t2)) in
    alt r_t (map Unit_t r_t Eps (fun p -> Obj.magic (None, None)))
      (alt r_t (map (User_t t1) r_t p1 (fun p -> Obj.magic ((Some p), None)))
        (alt r_t
          (map (User_t t2) r_t p2 (fun p -> Obj.magic (None, (Some p))))
          (map (Pair_t ((User_t t1), (User_t t2))) r_t
            (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
            let (a, b) = Obj.magic p in Obj.magic ((Some a), (Some b))))))
  
  (** val option_perm3 :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type ->
      X86_PARSER_ARG.user_type -> grammar -> grammar -> grammar -> grammar **)
  
  let option_perm3 t1 t2 t3 p1 p2 p3 =
    let r_t = Pair_t ((option_t t1), (Pair_t ((option_t t2), (option_t t3))))
    in
    alt r_t (map Unit_t r_t Eps (fun p -> Obj.magic (None, (None, None))))
      (alt r_t
        (map (User_t t1) r_t p1 (fun p ->
          Obj.magic ((Some p), (None, None))))
        (alt r_t
          (map (User_t t2) r_t p2 (fun p ->
            Obj.magic (None, ((Some p), None))))
          (alt r_t
            (map (User_t t3) r_t p3 (fun p ->
              Obj.magic (None, (None, (Some p)))))
            (alt r_t
              (map (Pair_t ((User_t t1), (User_t t2))) r_t
                (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
                let (a, b) = Obj.magic p in
                Obj.magic ((Some a), ((Some b), None))))
              (alt r_t
                (map (Pair_t ((User_t t1), (User_t t3))) r_t
                  (perm2 (User_t t1) (User_t t3) p1 p3) (fun p ->
                  let (a, c) = Obj.magic p in
                  Obj.magic ((Some a), (None, (Some c)))))
                (alt r_t
                  (map (Pair_t ((User_t t2), (User_t t3))) r_t
                    (perm2 (User_t t2) (User_t t3) p2 p3) (fun p ->
                    let (b, c) = Obj.magic p in
                    Obj.magic (None, ((Some b), (Some c)))))
                  (map (Pair_t ((User_t t1), (Pair_t ((User_t t2), (User_t
                    t3))))) r_t
                    (perm3 (User_t t1) (User_t t2) (User_t t3) p1 p2 p3)
                    (fun p ->
                    let (a, i) = Obj.magic p in
                    let (b, c) = i in
                    Obj.magic ((Some a), ((Some b), (Some c)))))))))))
  
  (** val option_perm2_variation :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type -> grammar ->
      grammar -> grammar **)
  
  let option_perm2_variation t1 t2 p1 p2 =
    let r_t = Pair_t ((option_t t1), (User_t t2)) in
    alt r_t (map (User_t t2) r_t p2 (fun p -> Obj.magic (None, p)))
      (map (Pair_t ((User_t t1), (User_t t2))) r_t
        (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
        let (a, b) = Obj.magic p in Obj.magic ((Some a), b)))
  
  (** val option_perm3_variation :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type ->
      X86_PARSER_ARG.user_type -> grammar -> grammar -> grammar -> grammar **)
  
  let option_perm3_variation t1 t2 t3 p1 p2 p3 =
    let r_t = Pair_t ((option_t t1), (Pair_t ((option_t t2), (User_t t3))))
    in
    alt r_t (map (User_t t3) r_t p3 (fun p -> Obj.magic (None, (None, p))))
      (alt r_t
        (map (Pair_t ((User_t t1), (User_t t3))) r_t
          (perm2 (User_t t1) (User_t t3) p1 p3) (fun p ->
          let (a, c) = Obj.magic p in Obj.magic ((Some a), (None, c))))
        (alt r_t
          (map (Pair_t ((User_t t2), (User_t t3))) r_t
            (perm2 (User_t t2) (User_t t3) p2 p3) (fun p ->
            let (b, c) = Obj.magic p in Obj.magic (None, ((Some b), c))))
          (map (Pair_t ((User_t t1), (Pair_t ((User_t t2), (User_t t3)))))
            r_t (perm3 (User_t t1) (User_t t2) (User_t t3) p1 p2 p3)
            (fun p ->
            let (a, i) = Obj.magic p in
            let (b, c) = i in Obj.magic ((Some a), ((Some b), c))))))
  
  (** val option_perm4 :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type ->
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type -> grammar ->
      grammar -> grammar -> grammar -> grammar **)
  
  let option_perm4 t1 t2 t3 t4 p1 p2 p3 p4 =
    let r_t = Pair_t ((option_t t1), (Pair_t ((option_t t2), (Pair_t
      ((option_t t3), (option_t t4))))))
    in
    alt r_t
      (map Unit_t r_t Eps (fun p -> Obj.magic (None, (None, (None, None)))))
      (alt r_t
        (map (User_t t1) r_t p1 (fun p ->
          Obj.magic ((Some p), (None, (None, None)))))
        (alt r_t
          (map (User_t t2) r_t p2 (fun p ->
            Obj.magic (None, ((Some p), (None, None)))))
          (alt r_t
            (map (User_t t3) r_t p3 (fun p ->
              Obj.magic (None, (None, ((Some p), None)))))
            (alt r_t
              (map (User_t t4) r_t p4 (fun p ->
                Obj.magic (None, (None, (None, (Some p))))))
              (alt r_t
                (map (Pair_t ((User_t t1), (User_t t2))) r_t
                  (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
                  let (a, b) = Obj.magic p in
                  Obj.magic ((Some a), ((Some b), (None, None)))))
                (alt r_t
                  (map (Pair_t ((User_t t1), (User_t t3))) r_t
                    (perm2 (User_t t1) (User_t t3) p1 p3) (fun p ->
                    let (a, c) = Obj.magic p in
                    Obj.magic ((Some a), (None, ((Some c), None)))))
                  (alt r_t
                    (map (Pair_t ((User_t t1), (User_t t4))) r_t
                      (perm2 (User_t t1) (User_t t4) p1 p4) (fun p ->
                      let (a, d) = Obj.magic p in
                      Obj.magic ((Some a), (None, (None, (Some d))))))
                    (alt r_t
                      (map (Pair_t ((User_t t2), (User_t t3))) r_t
                        (perm2 (User_t t2) (User_t t3) p2 p3) (fun p ->
                        let (b, c) = Obj.magic p in
                        Obj.magic (None, ((Some b), ((Some c), None)))))
                      (alt r_t
                        (map (Pair_t ((User_t t2), (User_t t4))) r_t
                          (perm2 (User_t t2) (User_t t4) p2 p4) (fun p ->
                          let (b, d) = Obj.magic p in
                          Obj.magic (None, ((Some b), (None, (Some d))))))
                        (alt r_t
                          (map (Pair_t ((User_t t3), (User_t t4))) r_t
                            (perm2 (User_t t3) (User_t t4) p3 p4) (fun p ->
                            let (c, d) = Obj.magic p in
                            Obj.magic (None, (None, ((Some c), (Some d))))))
                          (alt r_t
                            (map (Pair_t ((User_t t1), (Pair_t ((User_t t2),
                              (User_t t3))))) r_t
                              (perm3 (User_t t1) (User_t t2) (User_t t3) p1
                                p2 p3) (fun p ->
                              let (a, i) = Obj.magic p in
                              let (b, c) = i in
                              Obj.magic ((Some a), ((Some b), ((Some c),
                                None)))))
                            (alt r_t
                              (map (Pair_t ((User_t t1), (Pair_t ((User_t
                                t3), (User_t t4))))) r_t
                                (perm3 (User_t t1) (User_t t3) (User_t t4) p1
                                  p3 p4) (fun p ->
                                let (a, i) = Obj.magic p in
                                let (c, d) = i in
                                Obj.magic ((Some a), (None, ((Some c), (Some
                                  d))))))
                              (alt r_t
                                (map (Pair_t ((User_t t1), (Pair_t ((User_t
                                  t2), (User_t t4))))) r_t
                                  (perm3 (User_t t1) (User_t t2) (User_t t4)
                                    p1 p2 p4) (fun p ->
                                  let (a, i) = Obj.magic p in
                                  let (b, d) = i in
                                  Obj.magic ((Some a), ((Some b), (None,
                                    (Some d))))))
                                (alt r_t
                                  (map (Pair_t ((User_t t2), (Pair_t ((User_t
                                    t3), (User_t t4))))) r_t
                                    (perm3 (User_t t2) (User_t t3) (User_t
                                      t4) p2 p3 p4) (fun p ->
                                    let (b, i) = Obj.magic p in
                                    let (c, d) = i in
                                    Obj.magic (None, ((Some b), ((Some c),
                                      (Some d))))))
                                  (map (Pair_t ((User_t t1), (Pair_t ((User_t
                                    t2), (Pair_t ((User_t t3), (User_t
                                    t4))))))) r_t
                                    (perm4 (User_t t1) (User_t t2) (User_t
                                      t3) (User_t t4) p1 p2 p3 p4) (fun p ->
                                    let (a, i) = Obj.magic p in
                                    let (b, i0) = i in
                                    let (c, d) = i0 in
                                    Obj.magic ((Some a), ((Some b), ((Some
                                      c), (Some d))))))))))))))))))))
  
  (** val opt2b : bool option -> bool -> bool **)
  
  let opt2b a default =
    match a with
    | Some b ->
      b
    | None ->
      default
  
  (** val prefix_grammar_rep :
      grammar **)
  
  let prefix_grammar_rep =
    map
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Lock_or_Rep_t),
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Segment_Register_t),
      (option_t
        X86_PARSER_ARG.Bool_t)))))
      prefix_t
      (option_perm3
        X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t
        X86_PARSER_ARG.Bool_t
        rep_p
        segment_override_p
        op_override_p)
      (fun p ->
      let (l,
           i) =
        Obj.magic
          p
      in
      let (s,
           op) =
        i
      in
      Obj.magic
        { lock_rep =
        l;
        seg_override =
        s;
        op_override =
        (opt2b
          op
          false);
        addr_override =
        false })
  
  (** val instr_grammars_rep :
      grammar
      list **)
  
  let instr_grammars_rep =
    coq_INS_p :: (coq_OUTS_p :: (coq_MOVS_p :: (coq_LODS_p :: (coq_STOS_p :: (coq_RET_p :: [])))))
  
  (** val prefix_grammar_rep_or_repn :
      grammar **)
  
  let prefix_grammar_rep_or_repn =
    map
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Lock_or_Rep_t),
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Segment_Register_t),
      (option_t
        X86_PARSER_ARG.Bool_t)))))
      prefix_t
      (option_perm3
        X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t
        X86_PARSER_ARG.Bool_t
        rep_or_repn_p
        segment_override_p
        op_override_p)
      (fun p ->
      let (l,
           i) =
        Obj.magic
          p
      in
      let (s,
           op) =
        i
      in
      Obj.magic
        { lock_rep =
        l;
        seg_override =
        s;
        op_override =
        (opt2b
          op
          false);
        addr_override =
        false })
  
  (** val instr_grammars_rep_or_repn :
      grammar
      list **)
  
  let instr_grammars_rep_or_repn =
    coq_CMPS_p :: (coq_SCAS_p :: [])
  
  (** val prefix_grammar_lock_with_op_override :
      grammar **)
  
  let prefix_grammar_lock_with_op_override =
    map
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Lock_or_Rep_t),
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Segment_Register_t),
      (User_t
      X86_PARSER_ARG.Bool_t)))))
      prefix_t
      (option_perm3_variation
        X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t
        X86_PARSER_ARG.Bool_t
        lock_p
        segment_override_p
        op_override_p)
      (fun p ->
      let (l,
           i) =
        Obj.magic
          p
      in
      let (s,
           op) =
        i
      in
      Obj.magic
        { lock_rep =
        l;
        seg_override =
        s;
        op_override =
        op;
        addr_override =
        false })
  
  (** val instr_grammars_lock_with_op_override :
      grammar
      list **)
  
  let instr_grammars_lock_with_op_override =
    (coq_ADD_p
      true) :: ((coq_ADC_p
                  true) :: ((coq_AND_p
                              true) :: (coq_NEG_p :: (coq_NOT_p :: ((coq_OR_p
                                                                    true) :: (
      (coq_SBB_p
        true) :: ((coq_SUB_p
                    true) :: ((coq_XOR_p
                                true) :: (coq_XCHG_p :: [])))))))))
  
  (** val prefix_grammar_lock_no_op_override :
      grammar **)
  
  let prefix_grammar_lock_no_op_override =
    map
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Lock_or_Rep_t),
      (option_t
        X86_PARSER_ARG.Segment_Register_t)))
      prefix_t
      (option_perm2
        X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t
        lock_p
        segment_override_p)
      (fun p ->
      let (l,
           s) =
        Obj.magic
          p
      in
      Obj.magic
        { lock_rep =
        l;
        seg_override =
        s;
        op_override =
        false;
        addr_override =
        false })
  
  (** val instr_grammars_lock_no_op_override :
      grammar
      list **)
  
  let instr_grammars_lock_no_op_override =
    (coq_ADD_p
      false) :: ((coq_ADC_p
                   false) :: ((coq_AND_p
                                false) :: (coq_BTC_p :: (coq_BTR_p :: (coq_BTS_p :: (coq_CMPXCHG_p :: (coq_DEC_p :: (coq_INC_p :: (coq_NEG_p :: (coq_NOT_p :: (
      (coq_OR_p
        false) :: ((coq_SBB_p
                     false) :: ((coq_SUB_p
                                  false) :: ((coq_XOR_p
                                               false) :: (coq_XADD_p :: (coq_XCHG_p :: []))))))))))))))))
  
  (** val prefix_grammar_seg_with_op_override :
      grammar **)
  
  let prefix_grammar_seg_with_op_override =
    map
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Segment_Register_t),
      (User_t
      X86_PARSER_ARG.Bool_t)))
      prefix_t
      (option_perm2_variation
        X86_PARSER_ARG.Segment_Register_t
        X86_PARSER_ARG.Bool_t
        segment_override_p
        op_override_p)
      (fun p ->
      let (s,
           op) =
        Obj.magic
          p
      in
      Obj.magic
        { lock_rep =
        None;
        seg_override =
        s;
        op_override =
        op;
        addr_override =
        false })
  
  (** val instr_grammars_seg_with_op_override :
      grammar
      list **)
  
  let instr_grammars_seg_with_op_override =
    (coq_CMP_p
      true) :: ((coq_IMUL_p
                  true) :: ((coq_MOV_p
                              true) :: ((coq_TEST_p
                                          true) :: [])))
  
  (** val prefix_grammar_seg_op_override :
      grammar **)
  
  let prefix_grammar_seg_op_override =
    map
      (Pair_t
      ((option_t
         X86_PARSER_ARG.Segment_Register_t),
      (option_t
        X86_PARSER_ARG.Bool_t)))
      prefix_t
      (option_perm2
        X86_PARSER_ARG.Segment_Register_t
        X86_PARSER_ARG.Bool_t
        segment_override_p
        op_override_p)
      (fun p ->
      let (s,
           op) =
        Obj.magic
          p
      in
      Obj.magic
        { lock_rep =
        None;
        seg_override =
        s;
        op_override =
        (opt2b
          op
          false);
        addr_override =
        false })
  
  (** val instr_grammars_seg_op_override :
      grammar
      list **)
  
  let instr_grammars_seg_op_override =
    coq_CDQ_p :: (coq_CMOVcc_p :: (coq_CWDE_p :: (coq_DIV_p :: (coq_IDIV_p :: (coq_MOVSX_p :: (coq_MOVZX_p :: (coq_MUL_p :: (coq_NOP_p :: (coq_ROL_p :: (coq_ROR_p :: (coq_SAR_p :: (coq_SHL_p :: (coq_SHLD_p :: (coq_SHR_p :: (coq_SHRD_p :: [])))))))))))))))
  
  (** val prefix_grammar_seg_override :
      grammar **)
  
  let prefix_grammar_seg_override =
    map
      (option_t
        X86_PARSER_ARG.Segment_Register_t)
      prefix_t
      (option_perm
        X86_PARSER_ARG.Segment_Register_t
        segment_override_p)
      (fun s ->
      Obj.magic
        { lock_rep =
        None;
        seg_override =
        (Obj.magic
          s);
        op_override =
        false;
        addr_override =
        false })
  
  (** val instr_grammars_seg_override :
      grammar
      list **)
  
  let instr_grammars_seg_override =
    coq_AAA_p :: (coq_AAD_p :: (coq_AAM_p :: (coq_AAS_p :: ((coq_CMP_p
                                                              false) :: (coq_ARPL_p :: (coq_BOUND_p :: (coq_BSF_p :: (coq_BSR_p :: (coq_BSWAP_p :: (coq_BT_p :: (coq_CALL_p :: (coq_CLC_p :: (coq_CLD_p :: (coq_CLI_p :: (coq_CLTS_p :: (coq_CMC_p :: (coq_CPUID_p :: (coq_DAA_p :: (coq_DAS_p :: (coq_HLT_p :: (
      (coq_IMUL_p
        false) :: (coq_IN_p :: (coq_INTn_p :: (coq_INT_p :: (coq_INTO_p :: (coq_INVD_p :: (coq_INVLPG_p :: (coq_IRET_p :: (coq_Jcc_p :: (coq_JCXZ_p :: (coq_JMP_p :: (coq_LAHF_p :: (coq_LAR_p :: (coq_LDS_p :: (coq_LEA_p :: (coq_LEAVE_p :: (coq_LES_p :: (coq_LFS_p :: (coq_LGDT_p :: (coq_LGS_p :: (coq_LIDT_p :: (coq_LLDT_p :: (coq_LMSW_p :: (coq_LOOP_p :: (coq_LOOPZ_p :: (coq_LOOPNZ_p :: (coq_LSL_p :: (coq_LSS_p :: (coq_LTR_p :: (
      (coq_MOV_p
        false) :: (coq_MOVCR_p :: (coq_MOVDR_p :: (coq_MOVSR_p :: (coq_MOVBE_p :: (coq_OUT_p :: (coq_POP_p :: (coq_POPSR_p :: (coq_POPA_p :: (coq_POPF_p :: (coq_PUSH_p :: (coq_PUSHSR_p :: (coq_PUSHA_p :: (coq_PUSHF_p :: (coq_RCL_p :: (coq_RCR_p :: (coq_RDMSR_p :: (coq_RDPMC_p :: (coq_RDTSC_p :: (coq_RDTSCP_p :: (coq_RSM_p :: (coq_SAHF_p :: (coq_SETcc_p :: (coq_SGDT_p :: (coq_SIDT_p :: (coq_SLDT_p :: (coq_SMSW_p :: (coq_STC_p :: (coq_STD_p :: (coq_STI_p :: (coq_STR_p :: (
      (coq_TEST_p
        false) :: (coq_UD2_p :: (coq_VERR_p :: (coq_VERW_p :: (coq_WBINVD_p :: (coq_WRMSR_p :: (coq_XLAT_p :: (coq_F2XM1_p :: (coq_FABS_p :: (coq_FADD_p :: (coq_FADDP_p :: (coq_FBLD_p :: (coq_FBSTP_p :: (coq_FCHS_p :: (coq_FCMOVcc_p :: (coq_FCOM_p :: (coq_FCOMP_p :: (coq_FCOMPP_p :: (coq_FCOMIP_p :: (coq_FCOS_p :: (coq_FDECSTP_p :: (coq_FDIV_p :: (coq_FDIVP_p :: (coq_FDIVR_p :: (coq_FDIVRP_p :: (coq_FFREE_p :: (coq_FIADD_p :: (coq_FICOM_p :: (coq_FICOMP_p :: (coq_FIDIV_p :: (coq_FIDIVR_p :: (coq_FILD_p :: (coq_FIMUL_p :: (coq_FINCSTP_p :: (coq_FIST_p :: (coq_FISTP_p :: (coq_FISUB_p :: (coq_FISUBR_p :: (coq_FLD_p :: (coq_FLD1_p :: (coq_FLDCW_p :: (coq_FLDENV_p :: (coq_FLDL2E_p :: (coq_FLDL2T_p :: (coq_FLDLG2_p :: (coq_FLDLN2_p :: (coq_FLDPI_p :: (coq_FLDZ_p :: (coq_FMUL_p :: (coq_FMULP_p :: (coq_FNCLEX_p :: (coq_FNINIT_p :: (coq_FNOP_p :: (coq_FNSAVE_p :: (coq_FNSTCW_p :: (coq_FNSTSW_p :: (coq_FPATAN_p :: (coq_FPREM_p :: (coq_FPREM1_p :: (coq_FPTAN_p :: (coq_FRNDINT_p :: (coq_FRSTOR_p :: (coq_FSCALE_p :: (coq_FSIN_p :: (coq_FSINCOS_p :: (coq_FSQRT_p :: (coq_FST_p :: (coq_FSTENV_p :: (coq_FSTP_p :: (coq_FSUB_p :: (coq_FSUBP_p :: (coq_FSUBR_p :: (coq_FSUBRP_p :: (coq_FTST_p :: (coq_FUCOM_p :: (coq_FUCOMP_p :: (coq_FUCOMPP_p :: (coq_FUCOMI_p :: (coq_FUCOMIP_p :: (coq_FXAM_p :: (coq_FXCH_p :: (coq_FXTRACT_p :: (coq_FYL2X_p :: (coq_FYL2XP1_p :: (coq_FWAIT_p :: (coq_EMMS_p :: (coq_MOVD_p :: (coq_MOVQ_p :: (coq_PACKSSDW_p :: (coq_PACKSSWB_p :: (coq_PACKUSWB_p :: (coq_PADD_p :: (coq_PADDS_p :: (coq_PADDUS_p :: (coq_PAND_p :: (coq_PANDN_p :: (coq_PCMPEQ_p :: (coq_PCMPGT_p :: (coq_PMADDWD_p :: (coq_PMULHUW_p :: (coq_PMULHW_p :: (coq_PMULLW_p :: (coq_POR_p :: (coq_PSLL_p :: (coq_PSRA_p :: (coq_PSRL_p :: (coq_PSUB_p :: (coq_PSUBS_p :: (coq_PSUBUS_p :: (coq_PUNPCKH_p :: (coq_PUNPCKL_p :: (coq_PXOR_p :: (coq_ADDPS_p :: (coq_ADDSS_p :: (coq_ANDNPS_p :: (coq_ANDPS_p :: (coq_CMPPS_p :: (coq_CMPSS_p :: (coq_COMISS_p :: (coq_CVTPI2PS_p :: (coq_CVTPS2PI_p :: (coq_CVTSI2SS_p :: (coq_CVTSS2SI_p :: (coq_CVTTPS2PI_p :: (coq_CVTTSS2SI_p :: (coq_DIVPS_p :: (coq_DIVSS_p :: (coq_LDMXCSR_p :: (coq_MAXPS_p :: (coq_MAXSS_p :: (coq_MINPS_p :: (coq_MINSS_p :: (coq_MOVAPS_p :: (coq_MOVHLPS_p :: (coq_MOVLPS_p :: (coq_MOVMSKPS_p :: (coq_MOVSS_p :: (coq_MOVUPS_p :: (coq_MULPS_p :: (coq_MULSS_p :: (coq_ORPS_p :: (coq_RCPPS_p :: (coq_RCPSS_p :: (coq_RSQRTPS_p :: (coq_RSQRTSS_p :: (coq_SHUFPS_p :: (coq_SQRTPS_p :: (coq_SQRTSS_p :: (coq_STMXCSR_p :: (coq_SUBPS_p :: (coq_SUBSS_p :: (coq_UCOMISS_p :: (coq_UNPCKHPS_p :: (coq_UNPCKLPS_p :: (coq_XORPS_p :: (coq_PAVGB_p :: (coq_PEXTRW_p :: (coq_PINSRW_p :: (coq_PMAXSW_p :: (coq_PMAXUB_p :: (coq_PMINSW_p :: (coq_PMINUB_p :: (coq_PMOVMSKB_p :: (coq_PSADBW_p :: (coq_PSHUFW_p :: (coq_MASKMOVQ_p :: (coq_MOVNTPS_p :: (coq_MOVNTQ_p :: (coq_PREFETCHT0_p :: (coq_PREFETCHT1_p :: (coq_PREFETCHT2_p :: (coq_PREFETCHNTA_p :: (coq_SFENCE_p :: [])))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  
  (** val instruction_grammar_list :
      grammar
      list **)
  
  let instruction_grammar_list =
    app
      (Coq__1.map
        (fun p ->
        seq
          prefix_t
          instruction_t
          prefix_grammar_rep
          p)
        instr_grammars_rep)
      (app
        (Coq__1.map
          (fun p ->
          seq
            prefix_t
            instruction_t
            prefix_grammar_rep_or_repn
            p)
          instr_grammars_rep_or_repn)
        (app
          (Coq__1.map
            (fun p ->
            seq
              prefix_t
              instruction_t
              prefix_grammar_lock_with_op_override
              p)
            instr_grammars_lock_with_op_override)
          (app
            (Coq__1.map
              (fun p ->
              seq
                prefix_t
                instruction_t
                prefix_grammar_lock_no_op_override
                p)
              instr_grammars_lock_no_op_override)
            (app
              (Coq__1.map
                (fun p ->
                seq
                  prefix_t
                  instruction_t
                  prefix_grammar_seg_with_op_override
                  p)
                instr_grammars_seg_with_op_override)
              (app
                (Coq__1.map
                  (fun p ->
                  seq
                    prefix_t
                    instruction_t
                    prefix_grammar_seg_op_override
                    p)
                  instr_grammars_seg_op_override)
                (Coq__1.map
                  (fun p ->
                  seq
                    prefix_t
                    instruction_t
                    prefix_grammar_seg_override
                    p)
                  instr_grammars_seg_override))))))
  
  (** val instruction_grammar :
      grammar **)
  
  let instruction_grammar =
    alts
      (Pair_t
      (prefix_t,
      instruction_t))
      instruction_grammar_list
  
  (** val opt_initial_decoder_state :
      Big.big_int
      ->
      instParserState
      option **)
  
  let opt_initial_decoder_state n =
    opt_initial_parser_state
      n
      instruction_grammar
  
  (** val parse_byte :
      instParserState
      ->
      int8
      ->
      instParserState * (prefix * instr)
      list **)
  
  let parse_byte ps byte0 =
    Obj.magic
      (parse_token
        ps
        (Z.to_nat
          (Word.intval
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))
            byte0)))
 end

type 'm monad = { return : (__
                           ->
                           __
                           ->
                           'm);
                  bind : (__
                         ->
                         __
                         ->
                         'm
                         ->
                         (__
                         ->
                         'm)
                         ->
                         'm) }

(** val return :
    'a1
    monad
    ->
    'a2
    ->
    'a1 **)

let return monad0 x =
  let { return =
    return0;
    bind =
    bind0 } =
    monad0
  in
  Obj.magic
    return0
    __
    x

(** val bind :
    'a1
    monad
    ->
    'a1
    ->
    ('a2
    ->
    'a1)
    ->
    'a1 **)

let bind monad0 x x0 =
  let { return =
    return0;
    bind =
    bind0 } =
    monad0
  in
  Obj.magic
    bind0
    __
    __
    x
    x0

type r
  =
  unit

(** val r0 :
    r **)

let r0 = ()

(** val r1 :
    r **)

let r1 = ()

(** val rplus :
    r
    ->
    r
    ->
    r **)

let rplus = let rec loop x y = loop x y in loop

(** val rmult :
    r
    ->
    r
    ->
    r **)

let rmult = let rec loop x y = loop x y in loop

(** val ropp :
    r
    ->
    r **)

let ropp = let rec loop x = loop x in loop

(** val rinv :
    r
    ->
    r **)

let rinv = let rec loop x = loop x in loop

(** val total_order_T :
    r
    ->
    r
    ->
    bool
    option **)

let total_order_T = let rec loop x y = loop x y in loop

(** val zeven :
    Big.big_int
    ->
    bool **)

let zeven n =
  Big.z_case
    (fun _ ->
    true)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      false)
      (fun p0 ->
      true)
      (fun _ ->
      false)
      p)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      false)
      (fun p0 ->
      true)
      (fun _ ->
      false)
      p)
    n

type radix =
  Big.big_int
  (* singleton inductive, whose constructor was Build_radix *)

(** val radix_val :
    radix
    ->
    Big.big_int **)

let radix_val r2 =
  r2

(** val cond_Zopp :
    bool
    ->
    Big.big_int
    ->
    Big.big_int **)

let cond_Zopp b m =
  if b
  then Z.opp
         m
  else m

(** val p2R :
    Big.big_int
    ->
    r **)

let rec p2R p =
  Big.positive_case
    (fun t0 ->
    Big.positive_case
      (fun p0 ->
      rplus
        r1
        (rmult
          (rplus
            r1
            r1)
          (p2R
            t0)))
      (fun p0 ->
      rplus
        r1
        (rmult
          (rplus
            r1
            r1)
          (p2R
            t0)))
      (fun _ ->
      rplus
        r1
        (rplus
          r1
          r1))
      t0)
    (fun t0 ->
    Big.positive_case
      (fun p0 ->
      rmult
        (rplus
          r1
          r1)
        (p2R
          t0))
      (fun p0 ->
      rmult
        (rplus
          r1
          r1)
        (p2R
          t0))
      (fun _ ->
      rplus
        r1
        r1)
      t0)
    (fun _ ->
    r1)
    p

(** val z2R :
    Big.big_int
    ->
    r **)

let z2R n =
  Big.z_case
    (fun _ ->
    r0)
    (fun p ->
    p2R
      p)
    (fun p ->
    ropp
      (p2R
        p))
    n

(** val rcompare :
    r
    ->
    r
    ->
    comparison **)

let rcompare x y =
  match total_order_T
          x
          y with
  | Some s ->
    if s
    then Lt
    else Eq
  | None ->
    Gt

(** val bpow :
    radix
    ->
    Big.big_int
    ->
    r **)

let bpow r2 e =
  Big.z_case
    (fun _ ->
    r1)
    (fun p ->
    z2R
      (Z.pow_pos
        (radix_val
          r2)
        p))
    (fun p ->
    rinv
      (z2R
        (Z.pow_pos
          (radix_val
            r2)
          p)))
    e

type float = { fnum : Big.big_int;
               fexp : Big.big_int }

(** val fnum :
    radix
    ->
    float
    ->
    Big.big_int **)

let fnum _ x = x.fnum

(** val fexp :
    radix
    ->
    float
    ->
    Big.big_int **)

let fexp _ x = x.fexp

(** val f2R :
    radix
    ->
    float
    ->
    r **)

let f2R beta f =
  rmult
    (z2R
      f.fnum)
    (bpow
      beta
      f.fexp)

(** val fLT_exp :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int **)

let fLT_exp emin prec e =
  Z.max
    (Z.sub
      e
      prec)
    emin

(** val digits2_Pnat :
    Big.big_int
    ->
    Big.big_int **)

let rec digits2_Pnat n =
  Big.positive_case
    (fun p ->
    Big.succ
    (digits2_Pnat
      p))
    (fun p ->
    Big.succ
    (digits2_Pnat
      p))
    (fun _ ->
    Big.zero)
    n

type location =
| Loc_Exact
| Loc_Inexact of comparison

(** val new_location_even :
    Big.big_int
    ->
    Big.big_int
    ->
    location
    ->
    location **)

let new_location_even nb_steps k l =
  if zeq_bool
       k
       Big.zero
  then (match l with
        | Loc_Exact ->
          l
        | Loc_Inexact c ->
          Loc_Inexact
            Lt)
  else Loc_Inexact
         (match Z.compare
                  (Z.mul
                    (Big.double
                    Big.one)
                    k)
                  nb_steps with
          | Eq ->
            (match l with
             | Loc_Exact ->
               Eq
             | Loc_Inexact c ->
               Gt)
          | x ->
            x)

(** val new_location_odd :
    Big.big_int
    ->
    Big.big_int
    ->
    location
    ->
    location **)

let new_location_odd nb_steps k l =
  if zeq_bool
       k
       Big.zero
  then (match l with
        | Loc_Exact ->
          l
        | Loc_Inexact c ->
          Loc_Inexact
            Lt)
  else Loc_Inexact
         (match Z.compare
                  (Z.add
                    (Z.mul
                      (Big.double
                      Big.one)
                      k)
                    Big.one)
                  nb_steps with
          | Eq ->
            (match l with
             | Loc_Exact ->
               Lt
             | Loc_Inexact l0 ->
               l0)
          | x ->
            x)

(** val new_location :
    Big.big_int
    ->
    Big.big_int
    ->
    location
    ->
    location **)

let new_location nb_steps =
  if zeven
       nb_steps
  then new_location_even
         nb_steps
  else new_location_odd
         nb_steps

(** val cond_incr :
    bool
    ->
    Big.big_int
    ->
    Big.big_int **)

let cond_incr b m =
  if b
  then Z.add
         m
         Big.one
  else m

(** val round_sign_DN :
    bool
    ->
    location
    ->
    bool **)

let round_sign_DN s = function
| Loc_Exact ->
  false
| Loc_Inexact c ->
  s

(** val round_sign_UP :
    bool
    ->
    location
    ->
    bool **)

let round_sign_UP s = function
| Loc_Exact ->
  false
| Loc_Inexact c ->
  negb
    s

(** val round_N :
    bool
    ->
    location
    ->
    bool **)

let round_N p = function
| Loc_Exact ->
  false
| Loc_Inexact c ->
  (match c with
   | Eq ->
     p
   | Lt ->
     false
   | Gt ->
     true)

type full_float =
| F754_zero of bool
| F754_infinity of bool
| F754_nan
| F754_finite of bool
   * Big.big_int
   * Big.big_int

type binary_float =
| B754_zero of bool
| B754_infinity of bool
| B754_nan
| B754_finite of bool
   * Big.big_int
   * Big.big_int

(** val fF2B :
    Big.big_int
    ->
    Big.big_int
    ->
    full_float
    ->
    binary_float **)

let fF2B prec emax = function
| F754_zero s ->
  B754_zero
    s
| F754_infinity s ->
  B754_infinity
    s
| F754_nan ->
  B754_nan
| F754_finite (s,
               m,
               e) ->
  B754_finite
    (s,
    m,
    e)

(** val radix2 :
    radix **)

let radix2 =
  (Big.double
    Big.one)

(** val b2R :
    Big.big_int
    ->
    Big.big_int
    ->
    binary_float
    ->
    r **)

let b2R prec emax = function
| B754_finite (s,
               m,
               e) ->
  f2R
    radix2
    { fnum =
    (cond_Zopp
      s
      m);
    fexp =
    e }
| _ ->
  r0

(** val bopp :
    Big.big_int
    ->
    Big.big_int
    ->
    binary_float
    ->
    binary_float **)

let bopp prec emax x = match x with
| B754_zero sx ->
  B754_zero
    (negb
      sx)
| B754_infinity sx ->
  B754_infinity
    (negb
      sx)
| B754_nan ->
  x
| B754_finite (sx,
               mx,
               ex) ->
  B754_finite
    ((negb
       sx),
    mx,
    ex)

type shr_record = { shr_m : Big.big_int;
                    shr_r : bool;
                    shr_s : bool }

(** val shr_m :
    shr_record
    ->
    Big.big_int **)

let shr_m x = x.shr_m

(** val shr_1 :
    shr_record
    ->
    shr_record **)

let shr_1 mrs =
  let { shr_m =
    m;
    shr_r =
    r2;
    shr_s =
    s } =
    mrs
  in
  let s0 =
    (||)
      r2
      s
  in
  (Big.z_case
     (fun _ ->
     { shr_m =
     Big.zero;
     shr_r =
     false;
     shr_s =
     s0 })
     (fun p0 ->
     Big.positive_case
       (fun p ->
       { shr_m =
       p;
       shr_r =
       true;
       shr_s =
       s0 })
       (fun p ->
       { shr_m =
       p;
       shr_r =
       false;
       shr_s =
       s0 })
       (fun _ ->
       { shr_m =
       Big.zero;
       shr_r =
       true;
       shr_s =
       s0 })
       p0)
     (fun p0 ->
     Big.positive_case
       (fun p ->
       { shr_m =
       (Big.opp
       p);
       shr_r =
       true;
       shr_s =
       s0 })
       (fun p ->
       { shr_m =
       (Big.opp
       p);
       shr_r =
       false;
       shr_s =
       s0 })
       (fun _ ->
       { shr_m =
       Big.zero;
       shr_r =
       true;
       shr_s =
       s0 })
       p0)
     m)

(** val loc_of_shr_record :
    shr_record
    ->
    location **)

let loc_of_shr_record mrs =
  let { shr_m =
    shr_m0;
    shr_r =
    shr_r0;
    shr_s =
    shr_s0 } =
    mrs
  in
  if shr_r0
  then if shr_s0
       then Loc_Inexact
              Gt
       else Loc_Inexact
              Eq
  else if shr_s0
       then Loc_Inexact
              Lt
       else Loc_Exact

(** val shr_record_of_loc :
    Big.big_int
    ->
    location
    ->
    shr_record **)

let shr_record_of_loc m = function
| Loc_Exact ->
  { shr_m =
    m;
    shr_r =
    false;
    shr_s =
    false }
| Loc_Inexact c ->
  (match c with
   | Eq ->
     { shr_m =
       m;
       shr_r =
       true;
       shr_s =
       false }
   | Lt ->
     { shr_m =
       m;
       shr_r =
       false;
       shr_s =
       true }
   | Gt ->
     { shr_m =
       m;
       shr_r =
       true;
       shr_s =
       true })

(** val shr0 :
    shr_record
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    shr_record * Big.big_int **)

let shr0 mrs e n =
  Big.z_case
    (fun _ ->
    (mrs,
    e))
    (fun p ->
    ((Coq_Pos.iter
       p
       shr_1
       mrs),
    (Z.add
      e
      n)))
    (fun p ->
    (mrs,
    e))
    n

(** val zdigits2 :
    Big.big_int
    ->
    Big.big_int **)

let zdigits2 m =
  Big.z_case
    (fun _ ->
    m)
    (fun p ->
    Z.of_nat
      (Big.succ
      (digits2_Pnat
        p)))
    (fun p ->
    Z.of_nat
      (Big.succ
      (digits2_Pnat
        p)))
    m

(** val shr_fexp :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    location
    ->
    shr_record * Big.big_int **)

let shr_fexp prec emax =
  let emin =
    Z.sub
      (Z.sub
        (Big.doubleplusone
        Big.one)
        emax)
      prec
  in
  let fexp0 =
    fLT_exp
      emin
      prec
  in
  (fun m e l ->
  shr0
    (shr_record_of_loc
      m
      l)
    e
    (Z.sub
      (fexp0
        (Z.add
          (zdigits2
            m)
          e))
      e))

type mode =
| Mode_NE
| Mode_ZR
| Mode_DN
| Mode_UP
| Mode_NA

(** val choice_mode :
    mode
    ->
    bool
    ->
    Big.big_int
    ->
    location
    ->
    Big.big_int **)

let choice_mode m sx mx lx =
  match m with
  | Mode_NE ->
    cond_incr
      (round_N
        (negb
          (zeven
            mx))
        lx)
      mx
  | Mode_ZR ->
    mx
  | Mode_DN ->
    cond_incr
      (round_sign_DN
        sx
        lx)
      mx
  | Mode_UP ->
    cond_incr
      (round_sign_UP
        sx
        lx)
      mx
  | Mode_NA ->
    cond_incr
      (round_N
        true
        lx)
      mx

(** val overflow_to_inf :
    mode
    ->
    bool
    ->
    bool **)

let overflow_to_inf m s =
  match m with
  | Mode_ZR ->
    false
  | Mode_DN ->
    s
  | Mode_UP ->
    negb
      s
  | _ ->
    true

(** val binary_overflow :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    bool
    ->
    full_float **)

let binary_overflow prec emax m s =
  if overflow_to_inf
       m
       s
  then F754_infinity
         s
  else F754_finite
         (s,
         (Big.z_case
            (fun _ ->
            Big.one)
            (fun p ->
            p)
            (fun p ->
            Big.one)
            (Z.sub
              (Z.pow
                (Big.double
                Big.one)
                prec)
              Big.one)),
         (Z.sub
           emax
           prec))

(** val binary_round_aux :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    bool
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    location
    ->
    full_float **)

let binary_round_aux prec emax mode0 sx mx ex lx =
  let (mrs',
       e') =
    shr_fexp
      prec
      emax
      mx
      ex
      lx
  in
  let (mrs'',
       e'') =
    shr_fexp
      prec
      emax
      (choice_mode
        mode0
        sx
        mrs'.shr_m
        (loc_of_shr_record
          mrs'))
      e'
      Loc_Exact
  in
  (Big.z_case
     (fun _ ->
     F754_zero
     sx)
     (fun m ->
     if Z.leb
          e''
          (Z.sub
            emax
            prec)
     then F754_finite
            (sx,
            m,
            e'')
     else binary_overflow
            prec
            emax
            mode0
            sx)
     (fun p ->
     F754_nan)
     mrs''.shr_m)

(** val bmult :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    binary_float
    ->
    binary_float
    ->
    binary_float **)

let bmult prec emax m x y =
  match x with
  | B754_zero sx ->
    (match y with
     | B754_zero sy ->
       B754_zero
         (xorb
           sx
           sy)
     | B754_infinity b ->
       B754_nan
     | B754_nan ->
       y
     | B754_finite (sy,
                    m0,
                    e) ->
       B754_zero
         (xorb
           sx
           sy))
  | B754_infinity sx ->
    (match y with
     | B754_zero b ->
       B754_nan
     | B754_infinity sy ->
       B754_infinity
         (xorb
           sx
           sy)
     | B754_nan ->
       y
     | B754_finite (sy,
                    m0,
                    e) ->
       B754_infinity
         (xorb
           sx
           sy))
  | B754_nan ->
    x
  | B754_finite (sx,
                 mx,
                 ex) ->
    (match y with
     | B754_zero sy ->
       B754_zero
         (xorb
           sx
           sy)
     | B754_infinity sy ->
       B754_infinity
         (xorb
           sx
           sy)
     | B754_nan ->
       y
     | B754_finite (sy,
                    my,
                    ey) ->
       fF2B
         prec
         emax
         (binary_round_aux
           prec
           emax
           m
           (xorb
             sx
             sy)
           (Coq_Pos.mul
             mx
             my)
           (Z.add
             ex
             ey)
           Loc_Exact))

(** val shl_align :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int * Big.big_int **)

let shl_align mx ex ex' =
  Big.z_case
    (fun _ ->
    (mx,
    ex))
    (fun p ->
    (mx,
    ex))
    (fun d ->
    ((shift_pos
       d
       mx),
    ex'))
    (Z.sub
      ex'
      ex)

(** val shl_align_fexp :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int * Big.big_int **)

let shl_align_fexp prec emax =
  let emin =
    Z.sub
      (Z.sub
        (Big.doubleplusone
        Big.one)
        emax)
      prec
  in
  let fexp0 =
    fLT_exp
      emin
      prec
  in
  (fun mx ex ->
  shl_align
    mx
    ex
    (fexp0
      (Z.add
        (Z.of_nat
          (Big.succ
          (digits2_Pnat
            mx)))
        ex)))

(** val binary_round :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    bool
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    full_float **)

let binary_round prec emax m sx mx ex =
  let (mz,
       ez) =
    shl_align_fexp
      prec
      emax
      mx
      ex
  in
  binary_round_aux
    prec
    emax
    m
    sx
    mz
    ez
    Loc_Exact

(** val binary_normalize :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    bool
    ->
    binary_float **)

let binary_normalize prec emax mode0 m e szero =
  Big.z_case
    (fun _ ->
    B754_zero
    szero)
    (fun m0 ->
    fF2B
      prec
      emax
      (binary_round
        prec
        emax
        mode0
        false
        m0
        e))
    (fun m0 ->
    fF2B
      prec
      emax
      (binary_round
        prec
        emax
        mode0
        true
        m0
        e))
    m

(** val bplus :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    binary_float
    ->
    binary_float
    ->
    binary_float **)

let bplus prec emax m x y =
  match x with
  | B754_zero sx ->
    (match y with
     | B754_zero sy ->
       if eqb
            sx
            sy
       then x
       else (match m with
             | Mode_DN ->
               B754_zero
                 true
             | _ ->
               B754_zero
                 false)
     | _ ->
       y)
  | B754_infinity sx ->
    (match y with
     | B754_infinity sy ->
       if eqb
            sx
            sy
       then x
       else B754_nan
     | B754_nan ->
       y
     | _ ->
       x)
  | B754_nan ->
    x
  | B754_finite (sx,
                 mx,
                 ex) ->
    (match y with
     | B754_zero b ->
       x
     | B754_finite (sy,
                    my,
                    ey) ->
       let ez =
         Z.min
           ex
           ey
       in
       binary_normalize
         prec
         emax
         m
         (Z.add
           (cond_Zopp
             sx
             (fst
               (shl_align
                 mx
                 ex
                 ez)))
           (cond_Zopp
             sy
             (fst
               (shl_align
                 my
                 ey
                 ez))))
         ez
         (match m with
          | Mode_DN ->
            true
          | _ ->
            false)
     | _ ->
       y)

(** val bminus :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    binary_float
    ->
    binary_float
    ->
    binary_float **)

let bminus prec emax m x y =
  bplus
    prec
    emax
    m
    x
    (bopp
      prec
      emax
      y)

(** val fdiv_core_binary :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    (Big.big_int * Big.big_int) * location **)

let fdiv_core_binary prec m1 e1 m2 e2 =
  let d1 =
    zdigits2
      m1
  in
  let d2 =
    zdigits2
      m2
  in
  let e =
    Z.sub
      e1
      e2
  in
  (Big.z_case
     (fun _ ->
     let (q,
          r2) =
       Z.div_eucl
         m1
         m2
     in
     ((q,
     e),
     (new_location
       m2
       r2
       Loc_Exact)))
     (fun p ->
     let m =
       Z.mul
         m1
         (Z.pow_pos
           (Big.double
           Big.one)
           p)
     in
     let e' =
       Z.add
         e
         (Big.opp
         p)
     in
     let (q,
          r2) =
       Z.div_eucl
         m
         m2
     in
     ((q,
     e'),
     (new_location
       m2
       r2
       Loc_Exact)))
     (fun p ->
     let (q,
          r2) =
       Z.div_eucl
         m1
         m2
     in
     ((q,
     e),
     (new_location
       m2
       r2
       Loc_Exact)))
     (Z.sub
       (Z.add
         d2
         prec)
       d1))

(** val bdiv :
    Big.big_int
    ->
    Big.big_int
    ->
    mode
    ->
    binary_float
    ->
    binary_float
    ->
    binary_float **)

let bdiv prec emax m x y =
  match x with
  | B754_zero sx ->
    (match y with
     | B754_zero sy ->
       B754_nan
     | B754_infinity sy ->
       B754_zero
         (xorb
           sx
           sy)
     | B754_nan ->
       y
     | B754_finite (sy,
                    m0,
                    e) ->
       B754_zero
         (xorb
           sx
           sy))
  | B754_infinity sx ->
    (match y with
     | B754_zero sy ->
       B754_infinity
         (xorb
           sx
           sy)
     | B754_infinity sy ->
       B754_nan
     | B754_nan ->
       y
     | B754_finite (sy,
                    m0,
                    e) ->
       B754_infinity
         (xorb
           sx
           sy))
  | B754_nan ->
    x
  | B754_finite (sx,
                 mx,
                 ex) ->
    (match y with
     | B754_zero sy ->
       B754_infinity
         (xorb
           sx
           sy)
     | B754_infinity sy ->
       B754_infinity
         (xorb
           sx
           sy)
     | B754_nan ->
       y
     | B754_finite (sy,
                    my,
                    ey) ->
       fF2B
         prec
         emax
         (let (p,
               lz) =
            fdiv_core_binary
              prec
              mx
              ex
              my
              ey
          in
          let (mz,
               ez) =
            p
          in
          (Big.z_case
             (fun _ ->
             F754_nan)
             (fun mz0 ->
             binary_round_aux
               prec
               emax
               m
               (xorb
                 sx
                 sy)
               mz0
               ez
               lz)
             (fun p0 ->
             F754_nan)
             mz)))

(** val join_bits :
    Big.big_int
    ->
    Big.big_int
    ->
    bool
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int **)

let join_bits mw ew s m e =
  Z.add
    (Z.mul
      (Z.add
        (if s
         then Z.pow
                (Big.double
                Big.one)
                ew
         else Big.zero)
        e)
      (Z.pow
        (Big.double
        Big.one)
        mw))
    m

(** val split_bits :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    (bool * Big.big_int) * Big.big_int **)

let split_bits mw ew x =
  let mm =
    Z.pow
      (Big.double
      Big.one)
      mw
  in
  let em =
    Z.pow
      (Big.double
      Big.one)
      ew
  in
  (((Z.leb
      (Z.mul
        mm
        em)
      x),
  (Z.modulo
    x
    mm)),
  (Z.modulo
    (Z.div
      x
      mm)
    em))

(** val bits_of_binary_float :
    Big.big_int
    ->
    Big.big_int
    ->
    binary_float
    ->
    Big.big_int **)

let bits_of_binary_float mw ew =
  let emax =
    Z.pow
      (Big.double
      Big.one)
      (Z.sub
        ew
        Big.one)
  in
  let prec =
    Z.add
      mw
      Big.one
  in
  let emin =
    Z.sub
      (Z.sub
        (Big.doubleplusone
        Big.one)
        emax)
      prec
  in
  (fun x ->
  match x with
  | B754_zero sx ->
    join_bits
      mw
      ew
      sx
      Big.zero
      Big.zero
  | B754_infinity sx ->
    join_bits
      mw
      ew
      sx
      Big.zero
      (Z.sub
        (Z.pow
          (Big.double
          Big.one)
          ew)
        Big.one)
  | B754_nan ->
    join_bits
      mw
      ew
      false
      (Z.sub
        (Z.pow
          (Big.double
          Big.one)
          mw)
        Big.one)
      (Z.sub
        (Z.pow
          (Big.double
          Big.one)
          ew)
        Big.one)
  | B754_finite (sx,
                 mx,
                 ex) ->
    if Z.leb
         (Z.pow
           (Big.double
           Big.one)
           mw)
         mx
    then join_bits
           mw
           ew
           sx
           (Z.sub
             mx
             (Z.pow
               (Big.double
               Big.one)
               mw))
           (Z.add
             (Z.sub
               ex
               emin)
             Big.one)
    else join_bits
           mw
           ew
           sx
           mx
           Big.zero)

(** val binary_float_of_bits_aux :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    full_float **)

let binary_float_of_bits_aux mw ew =
  let emax =
    Z.pow
      (Big.double
      Big.one)
      (Z.sub
        ew
        Big.one)
  in
  let prec =
    Z.add
      mw
      Big.one
  in
  let emin =
    Z.sub
      (Z.sub
        (Big.doubleplusone
        Big.one)
        emax)
      prec
  in
  (fun x ->
  let (p,
       ex) =
    split_bits
      mw
      ew
      x
  in
  let (sx,
       mx) =
    p
  in
  if zeq_bool
       ex
       Big.zero
  then (Big.z_case
          (fun _ ->
          F754_zero
          sx)
          (fun px ->
          F754_finite
          (sx,
          px,
          emin))
          (fun p0 ->
          F754_nan)
          mx)
  else if zeq_bool
            ex
            (Z.sub
              (Z.pow
                (Big.double
                Big.one)
                ew)
              Big.one)
       then if zeq_bool
                 mx
                 Big.zero
            then F754_infinity
                   sx
            else F754_nan
       else (Big.z_case
               (fun _ ->
               F754_nan)
               (fun px ->
               F754_finite
               (sx,
               px,
               (Z.sub
                 (Z.add
                   ex
                   emin)
                 Big.one)))
               (fun p0 ->
               F754_nan)
               (Z.add
                 mx
                 (Z.pow
                   (Big.double
                   Big.one)
                   mw))))

(** val binary_float_of_bits :
    Big.big_int
    ->
    Big.big_int
    ->
    Big.big_int
    ->
    binary_float **)

let binary_float_of_bits mw ew x =
  let emax =
    Z.pow
      (Big.double
      Big.one)
      (Z.sub
        ew
        Big.one)
  in
  let prec =
    Z.add
      mw
      Big.one
  in
  fF2B
    prec
    emax
    (binary_float_of_bits_aux
      mw
      ew
      x)

type binary32
  =
  binary_float

(** val b32_of_bits :
    Big.big_int
    ->
    binary32 **)

let b32_of_bits =
  binary_float_of_bits
    (Big.doubleplusone
    (Big.doubleplusone
    (Big.doubleplusone
    (Big.double
    Big.one))))
    (Big.double
    (Big.double
    (Big.double
    Big.one)))

(** val bits_of_b32 :
    binary32
    ->
    Big.big_int **)

let bits_of_b32 =
  bits_of_binary_float
    (Big.doubleplusone
    (Big.doubleplusone
    (Big.doubleplusone
    (Big.double
    Big.one))))
    (Big.double
    (Big.double
    (Big.double
    Big.one)))

type binary64
  =
  binary_float

(** val b64_of_bits :
    Big.big_int
    ->
    binary64 **)

let b64_of_bits =
  binary_float_of_bits
    (Big.double
    (Big.double
    (Big.doubleplusone
    (Big.double
    (Big.doubleplusone
    Big.one)))))
    (Big.doubleplusone
    (Big.doubleplusone
    (Big.double
    Big.one)))

(** val bits_of_b64 :
    binary64
    ->
    Big.big_int **)

let bits_of_b64 =
  bits_of_binary_float
    (Big.double
    (Big.double
    (Big.doubleplusone
    (Big.double
    (Big.doubleplusone
    Big.one)))))
    (Big.doubleplusone
    (Big.doubleplusone
    (Big.double
    Big.one)))

(** val size1 :
    Big.big_int **)

let size1 =
  Big.zero

(** val size2 :
    Big.big_int **)

let size2 =
  Big.succ
    Big.zero

(** val size3 :
    Big.big_int **)

let size3 =
  Big.succ
    (Big.succ
    Big.zero)

(** val size4 :
    Big.big_int **)

let size4 =
  Big.succ
    (Big.succ
    (Big.succ
    Big.zero))

(** val size8 :
    Big.big_int **)

let size8 =
  Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero))))))

(** val size16 :
    Big.big_int **)

let size16 =
  Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero))))))))))))))

(** val size32 :
    Big.big_int **)

let size32 =
  Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero))))))))))))))))))))))))))))))

(** val size64 :
    Big.big_int **)

let size64 =
  Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val size79 :
    Big.big_int **)

let size79 =
  Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val size80 :
    Big.big_int **)

let size80 =
  Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    (Big.succ
    Big.zero))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

type int0
  =
  Word.int

module type MACHINE_SIG = 
 sig 
  type location 
  
  type array 
  
  val size_addr :
    Big.big_int
  
  type mach_state 
  
  val get_location :
    Big.big_int
    ->
    location
    ->
    mach_state
    ->
    Word.int
  
  val set_location :
    Big.big_int
    ->
    location
    ->
    Word.int
    ->
    mach_state
    ->
    mach_state
  
  val array_sub :
    Big.big_int
    ->
    Big.big_int
    ->
    array
    ->
    Word.int
    ->
    mach_state
    ->
    Word.int
  
  val array_upd :
    Big.big_int
    ->
    Big.big_int
    ->
    array
    ->
    Word.int
    ->
    Word.int
    ->
    mach_state
    ->
    mach_state
 end

module RTL = 
 functor (M:MACHINE_SIG) ->
 struct 
  module AddrIndexed = 
   struct 
    type t
      =
      int0
    
    (** val index :
        int0
        ->
        Big.big_int **)
    
    let index i =
      ZIndexed.index
        (Word.unsigned
          M.size_addr
          i)
    
    (** val eq :
        Word.int
        ->
        Word.int
        ->
        bool **)
    
    let eq =
      Word.eq_dec
        M.size_addr
   end
  
  module AddrMap = IMap(AddrIndexed)
  
  type bit_vector_op =
  | Coq_add_op
  | Coq_sub_op
  | Coq_mul_op
  | Coq_divs_op
  | Coq_divu_op
  | Coq_modu_op
  | Coq_mods_op
  | Coq_and_op
  | Coq_or_op
  | Coq_xor_op
  | Coq_shl_op
  | Coq_shr_op
  | Coq_shru_op
  | Coq_ror_op
  | Coq_rol_op
  
  (** val bit_vector_op_rect :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      bit_vector_op
      ->
      'a1 **)
  
  let bit_vector_op_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 = function
  | Coq_add_op ->
    f
  | Coq_sub_op ->
    f0
  | Coq_mul_op ->
    f1
  | Coq_divs_op ->
    f2
  | Coq_divu_op ->
    f3
  | Coq_modu_op ->
    f4
  | Coq_mods_op ->
    f5
  | Coq_and_op ->
    f6
  | Coq_or_op ->
    f7
  | Coq_xor_op ->
    f8
  | Coq_shl_op ->
    f9
  | Coq_shr_op ->
    f10
  | Coq_shru_op ->
    f11
  | Coq_ror_op ->
    f12
  | Coq_rol_op ->
    f13
  
  (** val bit_vector_op_rec :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      bit_vector_op
      ->
      'a1 **)
  
  let bit_vector_op_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 = function
  | Coq_add_op ->
    f
  | Coq_sub_op ->
    f0
  | Coq_mul_op ->
    f1
  | Coq_divs_op ->
    f2
  | Coq_divu_op ->
    f3
  | Coq_modu_op ->
    f4
  | Coq_mods_op ->
    f5
  | Coq_and_op ->
    f6
  | Coq_or_op ->
    f7
  | Coq_xor_op ->
    f8
  | Coq_shl_op ->
    f9
  | Coq_shr_op ->
    f10
  | Coq_shru_op ->
    f11
  | Coq_ror_op ->
    f12
  | Coq_rol_op ->
    f13
  
  type float_arith_op =
  | Coq_fadd_op
  | Coq_fsub_op
  | Coq_fmul_op
  | Coq_fdiv_op
  
  (** val float_arith_op_rect :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      float_arith_op
      ->
      'a1 **)
  
  let float_arith_op_rect f f0 f1 f2 = function
  | Coq_fadd_op ->
    f
  | Coq_fsub_op ->
    f0
  | Coq_fmul_op ->
    f1
  | Coq_fdiv_op ->
    f2
  
  (** val float_arith_op_rec :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      float_arith_op
      ->
      'a1 **)
  
  let float_arith_op_rec f f0 f1 f2 = function
  | Coq_fadd_op ->
    f
  | Coq_fsub_op ->
    f0
  | Coq_fmul_op ->
    f1
  | Coq_fdiv_op ->
    f2
  
  type test_op =
  | Coq_eq_op
  | Coq_lt_op
  | Coq_ltu_op
  
  (** val test_op_rect :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      test_op
      ->
      'a1 **)
  
  let test_op_rect f f0 f1 = function
  | Coq_eq_op ->
    f
  | Coq_lt_op ->
    f0
  | Coq_ltu_op ->
    f1
  
  (** val test_op_rec :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      test_op
      ->
      'a1 **)
  
  let test_op_rec f f0 f1 = function
  | Coq_eq_op ->
    f
  | Coq_lt_op ->
    f0
  | Coq_ltu_op ->
    f1
  
  type rounding_mode
    =
    mode
  
  type rtl_exp =
  | Coq_arith_rtl_exp of Big.big_int
     * bit_vector_op
     * rtl_exp
     * rtl_exp
  | Coq_test_rtl_exp of Big.big_int
     * test_op
     * rtl_exp
     * rtl_exp
  | Coq_if_rtl_exp of Big.big_int
     * rtl_exp
     * rtl_exp
     * rtl_exp
  | Coq_cast_s_rtl_exp of Big.big_int
     * Big.big_int
     * rtl_exp
  | Coq_cast_u_rtl_exp of Big.big_int
     * Big.big_int
     * rtl_exp
  | Coq_imm_rtl_exp of Big.big_int
     * int0
  | Coq_get_loc_rtl_exp of Big.big_int
     * M.location
  | Coq_get_array_rtl_exp of Big.big_int
     * Big.big_int
     * M.array
     * rtl_exp
  | Coq_get_byte_rtl_exp of rtl_exp
  | Coq_choose_rtl_exp of Big.big_int
  | Coq_farith_rtl_exp of Big.big_int
     * Big.big_int
     * float_arith_op
     * rtl_exp
     * rtl_exp
     * rtl_exp
  | Coq_fcast_rtl_exp of Big.big_int
     * Big.big_int
     * Big.big_int
     * Big.big_int
     * rtl_exp
     * rtl_exp
  
  (** val rtl_exp_rect :
      (Big.big_int
      ->
      bit_vector_op
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      test_op
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      int0
      ->
      'a1)
      ->
      (Big.big_int
      ->
      M.location
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      M.array
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      __
      ->
      float_arith_op
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      __
      ->
      __
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      rtl_exp
      ->
      'a1 **)
  
  let rec rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 n = function
  | Coq_arith_rtl_exp (s,
                       b,
                       e1,
                       e2) ->
    f
      s
      b
      e1
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e1)
      e2
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e2)
  | Coq_test_rtl_exp (s,
                      top,
                      e1,
                      e2) ->
    f0
      s
      top
      e1
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e1)
      e2
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e2)
  | Coq_if_rtl_exp (s,
                    cond,
                    e1,
                    e2) ->
    f1
      s
      cond
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        size1
        cond)
      e1
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e1)
      e2
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e2)
  | Coq_cast_s_rtl_exp (s1,
                        s2,
                        e) ->
    f2
      s1
      s2
      e
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s1
        e)
  | Coq_cast_u_rtl_exp (s1,
                        s2,
                        e) ->
    f3
      s1
      s2
      e
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s1
        e)
  | Coq_imm_rtl_exp (s,
                     i) ->
    f4
      s
      i
  | Coq_get_loc_rtl_exp (s,
                         l) ->
    f5
      s
      l
  | Coq_get_array_rtl_exp (l,
                           s,
                           a,
                           r3) ->
    f6
      l
      s
      a
      r3
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        l
        r3)
  | Coq_get_byte_rtl_exp addr ->
    f7
      addr
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        M.size_addr
        addr)
  | Coq_choose_rtl_exp s ->
    f8
      s
  | Coq_farith_rtl_exp (ew,
                        mw,
                        x,
                        x0,
                        x1,
                        x2) ->
    let len =
      plus
        (Coq_Pos.to_nat
          ew)
        (Coq_Pos.to_nat
          mw)
    in
    f9
      ew
      mw
      __
      x
      x0
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        size2
        x0)
      x1
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        len
        x1)
      x2
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        len
        x2)
  | Coq_fcast_rtl_exp (ew1,
                       mw1,
                       ew2,
                       mw2,
                       r3,
                       r4) ->
    f10
      ew1
      mw1
      ew2
      mw2
      __
      __
      r3
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        size2
        r3)
      r4
      (rtl_exp_rect
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        (plus
          (Coq_Pos.to_nat
            ew1)
          (Coq_Pos.to_nat
            mw1))
        r4)
  
  (** val rtl_exp_rec :
      (Big.big_int
      ->
      bit_vector_op
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      test_op
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      int0
      ->
      'a1)
      ->
      (Big.big_int
      ->
      M.location
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      M.array
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      __
      ->
      float_arith_op
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      __
      ->
      __
      ->
      rtl_exp
      ->
      'a1
      ->
      rtl_exp
      ->
      'a1
      ->
      'a1)
      ->
      Big.big_int
      ->
      rtl_exp
      ->
      'a1 **)
  
  let rec rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 n = function
  | Coq_arith_rtl_exp (s,
                       b,
                       e1,
                       e2) ->
    f
      s
      b
      e1
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e1)
      e2
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e2)
  | Coq_test_rtl_exp (s,
                      top,
                      e1,
                      e2) ->
    f0
      s
      top
      e1
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e1)
      e2
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e2)
  | Coq_if_rtl_exp (s,
                    cond,
                    e1,
                    e2) ->
    f1
      s
      cond
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        size1
        cond)
      e1
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e1)
      e2
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s
        e2)
  | Coq_cast_s_rtl_exp (s1,
                        s2,
                        e) ->
    f2
      s1
      s2
      e
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s1
        e)
  | Coq_cast_u_rtl_exp (s1,
                        s2,
                        e) ->
    f3
      s1
      s2
      e
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        s1
        e)
  | Coq_imm_rtl_exp (s,
                     i) ->
    f4
      s
      i
  | Coq_get_loc_rtl_exp (s,
                         l) ->
    f5
      s
      l
  | Coq_get_array_rtl_exp (l,
                           s,
                           a,
                           r3) ->
    f6
      l
      s
      a
      r3
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        l
        r3)
  | Coq_get_byte_rtl_exp addr ->
    f7
      addr
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        M.size_addr
        addr)
  | Coq_choose_rtl_exp s ->
    f8
      s
  | Coq_farith_rtl_exp (ew,
                        mw,
                        x,
                        x0,
                        x1,
                        x2) ->
    let len =
      plus
        (Coq_Pos.to_nat
          ew)
        (Coq_Pos.to_nat
          mw)
    in
    f9
      ew
      mw
      __
      x
      x0
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        size2
        x0)
      x1
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        len
        x1)
      x2
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        len
        x2)
  | Coq_fcast_rtl_exp (ew1,
                       mw1,
                       ew2,
                       mw2,
                       r3,
                       r4) ->
    f10
      ew1
      mw1
      ew2
      mw2
      __
      __
      r3
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        size2
        r3)
      r4
      (rtl_exp_rec
        f
        f0
        f1
        f2
        f3
        f4
        f5
        f6
        f7
        f8
        f9
        f10
        (plus
          (Coq_Pos.to_nat
            ew1)
          (Coq_Pos.to_nat
            mw1))
        r4)
  
  type rtl_instr =
  | Coq_set_loc_rtl of Big.big_int
     * rtl_exp
     * M.location
  | Coq_set_array_rtl of Big.big_int
     * Big.big_int
     * M.array
     * rtl_exp
     * rtl_exp
  | Coq_set_byte_rtl of rtl_exp
     * rtl_exp
  | Coq_if_rtl of rtl_exp
     * rtl_instr
  | Coq_error_rtl
  | Coq_trap_rtl
  
  (** val rtl_instr_rect :
      (Big.big_int
      ->
      rtl_exp
      ->
      M.location
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      M.array
      ->
      rtl_exp
      ->
      rtl_exp
      ->
      'a1)
      ->
      (rtl_exp
      ->
      rtl_exp
      ->
      'a1)
      ->
      (rtl_exp
      ->
      rtl_instr
      ->
      'a1
      ->
      'a1)
      ->
      'a1
      ->
      'a1
      ->
      rtl_instr
      ->
      'a1 **)
  
  let rec rtl_instr_rect f f0 f1 f2 f3 f4 = function
  | Coq_set_loc_rtl (s,
                     e,
                     l) ->
    f
      s
      e
      l
  | Coq_set_array_rtl (l,
                       s,
                       a,
                       r3,
                       r4) ->
    f0
      l
      s
      a
      r3
      r4
  | Coq_set_byte_rtl (e,
                      addr) ->
    f1
      e
      addr
  | Coq_if_rtl (r3,
                r4) ->
    f2
      r3
      r4
      (rtl_instr_rect
        f
        f0
        f1
        f2
        f3
        f4
        r4)
  | Coq_error_rtl ->
    f3
  | Coq_trap_rtl ->
    f4
  
  (** val rtl_instr_rec :
      (Big.big_int
      ->
      rtl_exp
      ->
      M.location
      ->
      'a1)
      ->
      (Big.big_int
      ->
      Big.big_int
      ->
      M.array
      ->
      rtl_exp
      ->
      rtl_exp
      ->
      'a1)
      ->
      (rtl_exp
      ->
      rtl_exp
      ->
      'a1)
      ->
      (rtl_exp
      ->
      rtl_instr
      ->
      'a1
      ->
      'a1)
      ->
      'a1
      ->
      'a1
      ->
      rtl_instr
      ->
      'a1 **)
  
  let rec rtl_instr_rec f f0 f1 f2 f3 f4 = function
  | Coq_set_loc_rtl (s,
                     e,
                     l) ->
    f
      s
      e
      l
  | Coq_set_array_rtl (l,
                       s,
                       a,
                       r3,
                       r4) ->
    f0
      l
      s
      a
      r3
      r4
  | Coq_set_byte_rtl (e,
                      addr) ->
    f1
      e
      addr
  | Coq_if_rtl (r3,
                r4) ->
    f2
      r3
      r4
      (rtl_instr_rec
        f
        f0
        f1
        f2
        f3
        f4
        r4)
  | Coq_error_rtl ->
    f3
  | Coq_trap_rtl ->
    f4
  
  type oracle = { oracle_bits : (Big.big_int
                                ->
                                Big.big_int
                                ->
                                int0);
                  oracle_offset : Big.big_int }
  
  (** val oracle_rect :
      ((Big.big_int
      ->
      Big.big_int
      ->
      int0)
      ->
      Big.big_int
      ->
      'a1)
      ->
      oracle
      ->
      'a1 **)
  
  let oracle_rect f o =
    let { oracle_bits =
      x;
      oracle_offset =
      x0 } =
      o
    in
    f
      x
      x0
  
  (** val oracle_rec :
      ((Big.big_int
      ->
      Big.big_int
      ->
      int0)
      ->
      Big.big_int
      ->
      'a1)
      ->
      oracle
      ->
      'a1 **)
  
  let oracle_rec f o =
    let { oracle_bits =
      x;
      oracle_offset =
      x0 } =
      o
    in
    f
      x
      x0
  
  (** val oracle_bits :
      oracle
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      int0 **)
  
  let oracle_bits o =
    o.oracle_bits
  
  (** val oracle_offset :
      oracle
      ->
      Big.big_int **)
  
  let oracle_offset o =
    o.oracle_offset
  
  type rtl_state = { rtl_oracle : oracle;
                     rtl_mach_state : M.mach_state;
                     rtl_memory : int8
                                  AddrMap.t }
  
  (** val rtl_state_rect :
      (oracle
      ->
      M.mach_state
      ->
      int8
      AddrMap.t
      ->
      'a1)
      ->
      rtl_state
      ->
      'a1 **)
  
  let rtl_state_rect f r2 =
    let { rtl_oracle =
      x;
      rtl_mach_state =
      x0;
      rtl_memory =
      x1 } =
      r2
    in
    f
      x
      x0
      x1
  
  (** val rtl_state_rec :
      (oracle
      ->
      M.mach_state
      ->
      int8
      AddrMap.t
      ->
      'a1)
      ->
      rtl_state
      ->
      'a1 **)
  
  let rtl_state_rec f r2 =
    let { rtl_oracle =
      x;
      rtl_mach_state =
      x0;
      rtl_memory =
      x1 } =
      r2
    in
    f
      x
      x0
      x1
  
  (** val rtl_oracle :
      rtl_state
      ->
      oracle **)
  
  let rtl_oracle r2 =
    r2.rtl_oracle
  
  (** val rtl_mach_state :
      rtl_state
      ->
      M.mach_state **)
  
  let rtl_mach_state r2 =
    r2.rtl_mach_state
  
  (** val rtl_memory :
      rtl_state
      ->
      int8
      AddrMap.t **)
  
  let rtl_memory r2 =
    r2.rtl_memory
  
  type 'a coq_RTL_ans =
  | Fail_ans
  | Trap_ans
  | Okay_ans of 'a
  
  (** val coq_RTL_ans_rect :
      'a2
      ->
      'a2
      ->
      ('a1
      ->
      'a2)
      ->
      'a1
      coq_RTL_ans
      ->
      'a2 **)
  
  let coq_RTL_ans_rect f f0 f1 = function
  | Fail_ans ->
    f
  | Trap_ans ->
    f0
  | Okay_ans x ->
    f1
      x
  
  (** val coq_RTL_ans_rec :
      'a2
      ->
      'a2
      ->
      ('a1
      ->
      'a2)
      ->
      'a1
      coq_RTL_ans
      ->
      'a2 **)
  
  let coq_RTL_ans_rec f f0 f1 = function
  | Fail_ans ->
    f
  | Trap_ans ->
    f0
  | Okay_ans x ->
    f1
      x
  
  type 't coq_RTL
    =
    rtl_state
    ->
    't
    coq_RTL_ans * rtl_state
  
  (** val coq_RTL_monad :
      __
      coq_RTL
      monad **)
  
  let coq_RTL_monad =
    { return =
      (fun _ x rs ->
      ((Okay_ans
      x),
      rs));
      bind =
      (fun _ _ c f rs ->
      let (safeFail_ans,
           rs') =
        c
          rs
      in
      (match safeFail_ans with
       | Okay_ans v ->
         f
           v
           rs'
       | x ->
         (x,
           rs'))) }
  
  (** val coq_Fail :
      'a1
      coq_RTL **)
  
  let coq_Fail rs =
    (Fail_ans,
      rs)
  
  (** val coq_Trap :
      'a1
      coq_RTL **)
  
  let coq_Trap rs =
    (Trap_ans,
      rs)
  
  (** val set_loc :
      Big.big_int
      ->
      M.location
      ->
      int0
      ->
      unit
      coq_RTL **)
  
  let set_loc s l v rs =
    ((Okay_ans
      ()),
      { rtl_oracle =
      (rtl_oracle
        rs);
      rtl_mach_state =
      (M.set_location
        s
        l
        v
        (rtl_mach_state
          rs));
      rtl_memory =
      (rtl_memory
        rs) })
  
  (** val set_array :
      Big.big_int
      ->
      Big.big_int
      ->
      M.array
      ->
      int0
      ->
      int0
      ->
      unit
      coq_RTL **)
  
  let set_array l s a i v rs =
    ((Okay_ans
      ()),
      { rtl_oracle =
      (rtl_oracle
        rs);
      rtl_mach_state =
      (M.array_upd
        l
        s
        a
        i
        v
        (rtl_mach_state
          rs));
      rtl_memory =
      (rtl_memory
        rs) })
  
  (** val set_byte :
      int0
      ->
      int0
      ->
      unit
      coq_RTL **)
  
  let set_byte addr v rs =
    ((Okay_ans
      ()),
      { rtl_oracle =
      (rtl_oracle
        rs);
      rtl_mach_state =
      (rtl_mach_state
        rs);
      rtl_memory =
      (AddrMap.set
        addr
        v
        (rtl_memory
          rs)) })
  
  (** val get_loc :
      Big.big_int
      ->
      M.location
      ->
      int0
      coq_RTL **)
  
  let get_loc s l rs =
    ((Okay_ans
      (M.get_location
        s
        l
        (rtl_mach_state
          rs))),
      rs)
  
  (** val get_array :
      Big.big_int
      ->
      Big.big_int
      ->
      M.array
      ->
      int0
      ->
      int0
      coq_RTL **)
  
  let get_array l s a i rs =
    ((Okay_ans
      (M.array_sub
        l
        s
        a
        i
        (rtl_mach_state
          rs))),
      rs)
  
  (** val get_byte :
      int0
      ->
      int0
      coq_RTL **)
  
  let get_byte addr rs =
    ((Okay_ans
      (AddrMap.get
        addr
        (rtl_memory
          rs))),
      rs)
  
  (** val choose_bits :
      Big.big_int
      ->
      int0
      coq_RTL **)
  
  let choose_bits s rs =
    let o =
      rtl_oracle
        rs
    in
    let o' =
      { oracle_bits =
      (oracle_bits
        o);
      oracle_offset =
      (Z.add
        (oracle_offset
          o)
        Big.one) }
    in
    ((Okay_ans
    (oracle_bits
      o
      s
      (oracle_offset
        o))),
    { rtl_oracle =
    o';
    rtl_mach_state =
    (rtl_mach_state
      rs);
    rtl_memory =
    (rtl_memory
      rs) })
  
  (** val interp_arith :
      Big.big_int
      ->
      bit_vector_op
      ->
      int0
      ->
      int0
      ->
      int0 **)
  
  let interp_arith s b v1 v2 =
    match b with
    | Coq_add_op ->
      Word.add
        s
        v1
        v2
    | Coq_sub_op ->
      Word.sub
        s
        v1
        v2
    | Coq_mul_op ->
      Word.mul
        s
        v1
        v2
    | Coq_divs_op ->
      Word.divs
        s
        v1
        v2
    | Coq_divu_op ->
      Word.divu
        s
        v1
        v2
    | Coq_modu_op ->
      Word.modu
        s
        v1
        v2
    | Coq_mods_op ->
      Word.mods
        s
        v1
        v2
    | Coq_and_op ->
      Word.coq_and
        s
        v1
        v2
    | Coq_or_op ->
      Word.coq_or
        s
        v1
        v2
    | Coq_xor_op ->
      Word.xor
        s
        v1
        v2
    | Coq_shl_op ->
      Word.shl
        s
        v1
        v2
    | Coq_shr_op ->
      Word.shr
        s
        v1
        v2
    | Coq_shru_op ->
      Word.shru
        s
        v1
        v2
    | Coq_ror_op ->
      Word.ror
        s
        v1
        v2
    | Coq_rol_op ->
      Word.rol
        s
        v1
        v2
  
  (** val interp_test :
      Big.big_int
      ->
      test_op
      ->
      int0
      ->
      int0
      ->
      int0 **)
  
  let interp_test s t0 v1 v2 =
    if match t0 with
       | Coq_eq_op ->
         Word.eq
           s
           v1
           v2
       | Coq_lt_op ->
         Word.lt
           s
           v1
           v2
       | Coq_ltu_op ->
         Word.ltu
           s
           v1
           v2
    then Word.one
           size1
    else Word.zero
           size1
  
  (** val dec_rounding_mode :
      int0
      ->
      rounding_mode **)
  
  let dec_rounding_mode rm =
    if Word.eq
         size2
         rm
         (Word.repr
           size2
           Big.zero)
    then Mode_NE
    else if Word.eq
              size2
              rm
              (Word.repr
                size2
                Big.one)
         then Mode_DN
         else if Word.eq
                   size2
                   rm
                   (Word.repr
                     size2
                     (Big.double
                     Big.one))
              then Mode_UP
              else Mode_ZR
  
  (** val interp_farith :
      Big.big_int
      ->
      Big.big_int
      ->
      float_arith_op
      ->
      int0
      ->
      int0
      ->
      int0
      ->
      int0 **)
  
  let interp_farith ew mw fop rm v1 v2 =
    let prec =
      Z.add
        mw
        Big.one
    in
    let emax =
      Z.pow
        (Big.double
        Big.one)
        (Z.sub
          ew
          Big.one)
    in
    let bf_of_bits =
      binary_float_of_bits
        mw
        ew
    in
    let bf1 =
      bf_of_bits
        (Word.unsigned
          (plus
            (Coq_Pos.to_nat
              ew)
            (Coq_Pos.to_nat
              mw))
          v1)
    in
    let bf2 =
      bf_of_bits
        (Word.unsigned
          (plus
            (Coq_Pos.to_nat
              ew)
            (Coq_Pos.to_nat
              mw))
          v2)
    in
    let md =
      dec_rounding_mode
        rm
    in
    let res =
      match fop with
      | Coq_fadd_op ->
        bplus
          prec
          emax
          md
          bf1
          bf2
      | Coq_fsub_op ->
        bminus
          prec
          emax
          md
          bf1
          bf2
      | Coq_fmul_op ->
        bmult
          prec
          emax
          md
          bf1
          bf2
      | Coq_fdiv_op ->
        bdiv
          prec
          emax
          md
          bf1
          bf2
    in
    Word.repr
      (plus
        (Coq_Pos.to_nat
          ew)
        (Coq_Pos.to_nat
          mw))
      (bits_of_binary_float
        mw
        ew
        res)
  
  (** val cond_Zopp :
      bool
      ->
      Big.big_int
      ->
      Big.big_int **)
  
  let cond_Zopp b m =
    if b
    then Z.opp
           m
    else m
  
  (** val binary_float_cast :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      int0
      ->
      binary_float
      ->
      binary_float **)
  
  let binary_float_cast prec1 emax1 prec2 emax2 rm bf =
    let md =
      dec_rounding_mode
        rm
    in
    (match bf with
     | B754_finite (sign,
                    mant,
                    ep) ->
       binary_normalize
         prec2
         emax2
         md
         (cond_Zopp
           sign
           mant)
         ep
         true
     | x ->
       x)
  
  (** val interp_fcast :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      int0
      ->
      int0
      ->
      int0 **)
  
  let interp_fcast ew1 mw1 ew2 mw2 rm v =
    let bf_of_bits =
      binary_float_of_bits
        mw1
        ew1
    in
    let bf =
      bf_of_bits
        (Word.unsigned
          (plus
            (Coq_Pos.to_nat
              ew1)
            (Coq_Pos.to_nat
              mw1))
          v)
    in
    let bf' =
      binary_float_cast
        (Z.add
          mw1
          Big.one)
        (Z.pow
          (Big.double
          Big.one)
          (Z.sub
            ew1
            Big.one))
        (Z.add
          mw2
          Big.one)
        (Z.pow
          (Big.double
          Big.one)
          (Z.sub
            ew2
            Big.one))
        rm
        bf
    in
    Word.repr
      (plus
        (Coq_Pos.to_nat
          ew2)
        (Coq_Pos.to_nat
          mw2))
      (bits_of_binary_float
        mw2
        ew2
        bf')
  
  (** val interp_rtl_exp :
      Big.big_int
      ->
      rtl_exp
      ->
      int0
      coq_RTL **)
  
  let rec interp_rtl_exp s = function
  | Coq_arith_rtl_exp (s0,
                       b,
                       e1,
                       e2) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        s0
        e1)
      (fun v1 ->
      bind
        (Obj.magic
          coq_RTL_monad)
        (interp_rtl_exp
          s0
          e2)
        (fun v2 ->
        return
          (Obj.magic
            coq_RTL_monad)
          (interp_arith
            s0
            b
            v1
            v2)))
  | Coq_test_rtl_exp (s0,
                      t0,
                      e1,
                      e2) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        s0
        e1)
      (fun v1 ->
      bind
        (Obj.magic
          coq_RTL_monad)
        (interp_rtl_exp
          s0
          e2)
        (fun v2 ->
        return
          (Obj.magic
            coq_RTL_monad)
          (interp_test
            s0
            t0
            v1
            v2)))
  | Coq_if_rtl_exp (s0,
                    cd,
                    e1,
                    e2) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        size1
        cd)
      (fun v ->
      if Word.eq
           size1
           v
           (Word.one
             size1)
      then interp_rtl_exp
             s0
             e1
      else interp_rtl_exp
             s0
             e2)
  | Coq_cast_s_rtl_exp (s1,
                        s2,
                        e0) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        s1
        e0)
      (fun v ->
      return
        (Obj.magic
          coq_RTL_monad)
        (Word.repr
          s2
          (Word.signed
            s1
            v)))
  | Coq_cast_u_rtl_exp (s1,
                        s2,
                        e0) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        s1
        e0)
      (fun v ->
      return
        (Obj.magic
          coq_RTL_monad)
        (Word.repr
          s2
          (Word.unsigned
            s1
            v)))
  | Coq_imm_rtl_exp (s0,
                     v) ->
    return
      (Obj.magic
        coq_RTL_monad)
      v
  | Coq_get_loc_rtl_exp (s0,
                         l) ->
    get_loc
      s0
      l
  | Coq_get_array_rtl_exp (l,
                           s0,
                           a,
                           e0) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        l
        e0)
      (fun i ->
      get_array
        l
        s0
        a
        i)
  | Coq_get_byte_rtl_exp addr ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        M.size_addr
        addr)
      (fun v ->
      get_byte
        v)
  | Coq_choose_rtl_exp s0 ->
    choose_bits
      s0
  | Coq_farith_rtl_exp (ew,
                        mw,
                        x,
                        x0,
                        x1,
                        x2) ->
    let len =
      plus
        (Coq_Pos.to_nat
          ew)
        (Coq_Pos.to_nat
          mw)
    in
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        len
        x1)
      (fun v1 ->
      bind
        (Obj.magic
          coq_RTL_monad)
        (interp_rtl_exp
          len
          x2)
        (fun v2 ->
        bind
          (Obj.magic
            coq_RTL_monad)
          (interp_rtl_exp
            size2
            x0)
          (fun vrm ->
          return
            (Obj.magic
              coq_RTL_monad)
            (interp_farith
              ew
              mw
              x
              vrm
              v1
              v2))))
  | Coq_fcast_rtl_exp (ew1,
                       mw1,
                       ew2,
                       mw2,
                       rm,
                       e0) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (interp_rtl_exp
        (plus
          (Coq_Pos.to_nat
            ew1)
          (Coq_Pos.to_nat
            mw1))
        e0)
      (fun v ->
      bind
        (Obj.magic
          coq_RTL_monad)
        (interp_rtl_exp
          size2
          rm)
        (fun vrm ->
        return
          (Obj.magic
            coq_RTL_monad)
          (interp_fcast
            ew1
            mw1
            ew2
            mw2
            vrm
            v)))
  
  (** val interp_rtl :
      rtl_instr
      ->
      unit
      coq_RTL **)
  
  let rec interp_rtl = function
  | Coq_set_loc_rtl (s,
                     e,
                     l) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (Obj.magic
        (interp_rtl_exp
          s
          e))
      (fun v ->
      set_loc
        s
        l
        v)
  | Coq_set_array_rtl (l,
                       s,
                       a,
                       e1,
                       e2) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (Obj.magic
        (interp_rtl_exp
          l
          e1))
      (fun i ->
      bind
        (Obj.magic
          coq_RTL_monad)
        (Obj.magic
          (interp_rtl_exp
            s
            e2))
        (fun v ->
        set_array
          l
          s
          a
          i
          v))
  | Coq_set_byte_rtl (e,
                      addr) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (Obj.magic
        (interp_rtl_exp
          size8
          e))
      (fun v ->
      bind
        (Obj.magic
          coq_RTL_monad)
        (Obj.magic
          (interp_rtl_exp
            M.size_addr
            addr))
        (fun a ->
        set_byte
          a
          v))
  | Coq_if_rtl (r2,
                i) ->
    bind
      (Obj.magic
        coq_RTL_monad)
      (Obj.magic
        (interp_rtl_exp
          size1
          r2))
      (fun v ->
      if Word.eq
           size1
           v
           (Word.one
             size1)
      then interp_rtl
             i
      else return
             (Obj.magic
               coq_RTL_monad)
             ())
  | Coq_error_rtl -> coq_Fail
  | Coq_trap_rtl -> coq_Trap
  
  type instruction = { instr_assembly : char list; instr_rtl : rtl_instr list }
  
  (** val instruction_rect :
      (char list -> rtl_instr list -> 'a1) -> instruction -> 'a1 **)
  
  let instruction_rect f i =
    let { instr_assembly = x; instr_rtl = x0 } = i in f x x0
  
  (** val instruction_rec :
      (char list -> rtl_instr list -> 'a1) -> instruction -> 'a1 **)
  
  let instruction_rec f i =
    let { instr_assembly = x; instr_rtl = x0 } = i in f x x0
  
  (** val instr_assembly : instruction -> char list **)
  
  let instr_assembly i =
    i.instr_assembly
  
  (** val instr_rtl : instruction -> rtl_instr list **)
  
  let instr_rtl i =
    i.instr_rtl
 end

type binary79 = binary_float

(** val b79_of_bits : Big.big_int -> binary79 **)

let b79_of_bits =
  binary_float_of_bits (Big.doubleplusone (Big.doubleplusone
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))))
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))

(** val bits_of_b79 : binary79 -> Big.big_int **)

let bits_of_b79 =
  bits_of_binary_float (Big.doubleplusone (Big.doubleplusone
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))))
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))

type de_float = binary79

(** val de_float_of_bits : Big.big_int -> de_float **)

let de_float_of_bits x =
  let (p, ex) =
    split_bits (Big.double (Big.double (Big.double (Big.double (Big.double
      (Big.double Big.one)))))) (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone Big.one))) x
  in
  let (sx, mx) = p in
  let mx' =
    Z.modulo mx
      (Z.pow (Big.double Big.one) (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        Big.one))))))
  in
  b79_of_bits
    (join_bits (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))))) (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))) sx mx' ex)

(** val bits_of_de_float : de_float -> Big.big_int **)

let bits_of_de_float f =
  let x = bits_of_b79 f in
  let (p, ex) =
    split_bits (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))))) (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))) x
  in
  let (sx, mx) = p in
  if zeq_bool ex Big.zero
  then join_bits (Big.double (Big.double (Big.double (Big.double (Big.double
         (Big.double Big.one)))))) (Big.doubleplusone (Big.doubleplusone
         (Big.doubleplusone Big.one))) sx mx ex
  else if zeq_bool ex
            (Z.sub
              (Z.pow (Big.double Big.one) (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone Big.one)))) Big.one)
       then join_bits (Big.double (Big.double (Big.double (Big.double
              (Big.double (Big.double Big.one)))))) (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone Big.one))) sx mx ex
       else join_bits (Big.double (Big.double (Big.double (Big.double
              (Big.double (Big.double Big.one)))))) (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone Big.one))) sx
              (Z.add
                (Z.pow (Big.double Big.one) (Big.doubleplusone
                  (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
                  (Big.doubleplusone Big.one)))))) mx) ex

module X86_MACHINE = 
 struct 
  (** val size_addr : Big.big_int **)
  
  let size_addr =
    size32
  
  type flag =
  | ID
  | VIP
  | VIF
  | AC
  | VM
  | RF
  | NT
  | IOPL
  | OF
  | DF
  | IF_flag
  | TF
  | SF
  | ZF
  | AF
  | PF
  | CF
  
  (** val flag_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> flag -> 'a1 **)
  
  let flag_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 = function
  | ID -> f
  | VIP -> f0
  | VIF -> f1
  | AC -> f2
  | VM -> f3
  | RF -> f4
  | NT -> f5
  | IOPL -> f6
  | OF -> f7
  | DF -> f8
  | IF_flag -> f9
  | TF -> f10
  | SF -> f11
  | ZF -> f12
  | AF -> f13
  | PF -> f14
  | CF -> f15
  
  (** val flag_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> flag -> 'a1 **)
  
  let flag_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 = function
  | ID -> f
  | VIP -> f0
  | VIF -> f1
  | AC -> f2
  | VM -> f3
  | RF -> f4
  | NT -> f5
  | IOPL -> f6
  | OF -> f7
  | DF -> f8
  | IF_flag -> f9
  | TF -> f10
  | SF -> f11
  | ZF -> f12
  | AF -> f13
  | PF -> f14
  | CF -> f15
  
  (** val flag_eq_dec : flag -> flag -> bool **)
  
  let flag_eq_dec f1 f2 =
    match f1 with
    | ID ->
      (match f2 with
       | ID -> true
       | _ -> false)
    | VIP ->
      (match f2 with
       | VIP -> true
       | _ -> false)
    | VIF ->
      (match f2 with
       | VIF -> true
       | _ -> false)
    | AC ->
      (match f2 with
       | AC -> true
       | _ -> false)
    | VM ->
      (match f2 with
       | VM -> true
       | _ -> false)
    | RF ->
      (match f2 with
       | RF -> true
       | _ -> false)
    | NT ->
      (match f2 with
       | NT -> true
       | _ -> false)
    | IOPL ->
      (match f2 with
       | IOPL -> true
       | _ -> false)
    | OF ->
      (match f2 with
       | OF -> true
       | _ -> false)
    | DF ->
      (match f2 with
       | DF -> true
       | _ -> false)
    | IF_flag ->
      (match f2 with
       | IF_flag -> true
       | _ -> false)
    | TF ->
      (match f2 with
       | TF -> true
       | _ -> false)
    | SF ->
      (match f2 with
       | SF -> true
       | _ -> false)
    | ZF ->
      (match f2 with
       | ZF -> true
       | _ -> false)
    | AF ->
      (match f2 with
       | AF -> true
       | _ -> false)
    | PF ->
      (match f2 with
       | PF -> true
       | _ -> false)
    | CF ->
      (match f2 with
       | CF -> true
       | _ -> false)
  
  type fpu_flag =
  | F_Busy
  | F_C3
  | F_C2
  | F_C1
  | F_C0
  | F_ES
  | F_SF
  | F_PE
  | F_UE
  | F_OE
  | F_ZE
  | F_DE
  | F_IE
  
  (** val fpu_flag_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> fpu_flag -> 'a1 **)
  
  let fpu_flag_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 = function
  | F_Busy -> f
  | F_C3 -> f0
  | F_C2 -> f1
  | F_C1 -> f2
  | F_C0 -> f3
  | F_ES -> f4
  | F_SF -> f5
  | F_PE -> f6
  | F_UE -> f7
  | F_OE -> f8
  | F_ZE -> f9
  | F_DE -> f10
  | F_IE -> f11
  
  (** val fpu_flag_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> fpu_flag -> 'a1 **)
  
  let fpu_flag_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 = function
  | F_Busy -> f
  | F_C3 -> f0
  | F_C2 -> f1
  | F_C1 -> f2
  | F_C0 -> f3
  | F_ES -> f4
  | F_SF -> f5
  | F_PE -> f6
  | F_UE -> f7
  | F_OE -> f8
  | F_ZE -> f9
  | F_DE -> f10
  | F_IE -> f11
  
  type fpu_ctrl_flag =
  | F_Res15
  | F_Res14
  | F_Res13
  | F_Res7
  | F_Res6
  | F_IC
  | F_PM
  | F_UM
  | F_OM
  | F_ZM
  | F_DM
  | F_IM
  
  (** val fpu_ctrl_flag_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> fpu_ctrl_flag -> 'a1 **)
  
  let fpu_ctrl_flag_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 = function
  | F_Res15 -> f
  | F_Res14 -> f0
  | F_Res13 -> f1
  | F_Res7 -> f2
  | F_Res6 -> f3
  | F_IC -> f4
  | F_PM -> f5
  | F_UM -> f6
  | F_OM -> f7
  | F_ZM -> f8
  | F_DM -> f9
  | F_IM -> f10
  
  (** val fpu_ctrl_flag_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> fpu_ctrl_flag -> 'a1 **)
  
  let fpu_ctrl_flag_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 = function
  | F_Res15 -> f
  | F_Res14 -> f0
  | F_Res13 -> f1
  | F_Res7 -> f2
  | F_Res6 -> f3
  | F_IC -> f4
  | F_PM -> f5
  | F_UM -> f6
  | F_OM -> f7
  | F_ZM -> f8
  | F_DM -> f9
  | F_IM -> f10
  
  (** val size11 : Big.big_int **)
  
  let size11 =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ Big.zero)))))))))
  
  (** val size48 : Big.big_int **)
  
  let size48 =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero))))))))))))))))))))))))))))))))))))))))))))))
  
  type int48 = Word.int
  
  type loc =
  | Coq_reg_loc of register
  | Coq_seg_reg_start_loc of segment_register
  | Coq_seg_reg_limit_loc of segment_register
  | Coq_flag_loc of flag
  | Coq_control_register_loc of control_register
  | Coq_debug_register_loc of debug_register
  | Coq_pc_loc
  | Coq_fpu_stktop_loc
  | Coq_fpu_flag_loc of fpu_flag
  | Coq_fpu_rctrl_loc
  | Coq_fpu_pctrl_loc
  | Coq_fpu_ctrl_flag_loc of fpu_ctrl_flag
  | Coq_fpu_lastInstrPtr_loc
  | Coq_fpu_lastDataPtr_loc
  | Coq_fpu_lastOpcode_loc
  
  (** val loc_rect :
      (register -> 'a1) -> (segment_register -> 'a1) -> (segment_register ->
      'a1) -> (flag -> 'a1) -> (control_register -> 'a1) -> (debug_register
      -> 'a1) -> 'a1 -> 'a1 -> (fpu_flag -> 'a1) -> 'a1 -> 'a1 ->
      (fpu_ctrl_flag -> 'a1) -> 'a1 -> 'a1 -> 'a1 -> Big.big_int -> loc ->
      'a1 **)
  
  let loc_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 n = function
  | Coq_reg_loc x -> f x
  | Coq_seg_reg_start_loc x -> f0 x
  | Coq_seg_reg_limit_loc x -> f1 x
  | Coq_flag_loc x -> f2 x
  | Coq_control_register_loc x -> f3 x
  | Coq_debug_register_loc x -> f4 x
  | Coq_pc_loc -> f5
  | Coq_fpu_stktop_loc -> f6
  | Coq_fpu_flag_loc x -> f7 x
  | Coq_fpu_rctrl_loc -> f8
  | Coq_fpu_pctrl_loc -> f9
  | Coq_fpu_ctrl_flag_loc x -> f10 x
  | Coq_fpu_lastInstrPtr_loc -> f11
  | Coq_fpu_lastDataPtr_loc -> f12
  | Coq_fpu_lastOpcode_loc -> f13
  
  (** val loc_rec :
      (register -> 'a1) -> (segment_register -> 'a1) -> (segment_register ->
      'a1) -> (flag -> 'a1) -> (control_register -> 'a1) -> (debug_register
      -> 'a1) -> 'a1 -> 'a1 -> (fpu_flag -> 'a1) -> 'a1 -> 'a1 ->
      (fpu_ctrl_flag -> 'a1) -> 'a1 -> 'a1 -> 'a1 -> Big.big_int -> loc ->
      'a1 **)
  
  let loc_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 n = function
  | Coq_reg_loc x -> f x
  | Coq_seg_reg_start_loc x -> f0 x
  | Coq_seg_reg_limit_loc x -> f1 x
  | Coq_flag_loc x -> f2 x
  | Coq_control_register_loc x -> f3 x
  | Coq_debug_register_loc x -> f4 x
  | Coq_pc_loc -> f5
  | Coq_fpu_stktop_loc -> f6
  | Coq_fpu_flag_loc x -> f7 x
  | Coq_fpu_rctrl_loc -> f8
  | Coq_fpu_pctrl_loc -> f9
  | Coq_fpu_ctrl_flag_loc x -> f10 x
  | Coq_fpu_lastInstrPtr_loc -> f11
  | Coq_fpu_lastDataPtr_loc -> f12
  | Coq_fpu_lastOpcode_loc -> f13
  
  type location = loc
  
  type arr =
  | Coq_fpu_datareg
  | Coq_fpu_tag
  
  (** val arr_rect :
      'a1 -> 'a1 -> Big.big_int -> Big.big_int -> arr -> 'a1 **)
  
  let arr_rect f f0 n n0 = function
  | Coq_fpu_datareg -> f
  | Coq_fpu_tag -> f0
  
  (** val arr_rec :
      'a1 -> 'a1 -> Big.big_int -> Big.big_int -> arr -> 'a1 **)
  
  let arr_rec f f0 n n0 = function
  | Coq_fpu_datareg -> f
  | Coq_fpu_tag -> f0
  
  type array = arr
  
  type ('a, 'b) fmap = 'a -> 'b
  
  (** val upd :
      ('a1 -> 'a1 -> bool) -> ('a1, 'a2) fmap -> 'a1 -> 'a2 -> ('a1, 'a2)
      fmap **)
  
  let upd eq_dec0 f x v y =
    if eq_dec0 x y then v else f y
  
  (** val look : ('a1, 'a2) fmap -> 'a1 -> 'a2 **)
  
  let look f x =
    f x
  
  type core_state = { gp_regs : (register, int32) fmap;
                      seg_regs_starts : (segment_register, int32) fmap;
                      seg_regs_limits : (segment_register, int32) fmap;
                      flags_reg : (flag, int1) fmap;
                      control_regs : (control_register, int32) fmap;
                      debug_regs : (debug_register, int32) fmap;
                      pc_reg : int0 }
  
  (** val core_state_rect :
      ((register, int32) fmap -> (segment_register, int32) fmap ->
      (segment_register, int32) fmap -> (flag, int1) fmap ->
      (control_register, int32) fmap -> (debug_register, int32) fmap -> int0
      -> 'a1) -> core_state -> 'a1 **)
  
  let core_state_rect f c =
    let { gp_regs = x; seg_regs_starts = x0; seg_regs_limits = x1;
      flags_reg = x2; control_regs = x3; debug_regs = x4; pc_reg = x5 } = c
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val core_state_rec :
      ((register, int32) fmap -> (segment_register, int32) fmap ->
      (segment_register, int32) fmap -> (flag, int1) fmap ->
      (control_register, int32) fmap -> (debug_register, int32) fmap -> int0
      -> 'a1) -> core_state -> 'a1 **)
  
  let core_state_rec f c =
    let { gp_regs = x; seg_regs_starts = x0; seg_regs_limits = x1;
      flags_reg = x2; control_regs = x3; debug_regs = x4; pc_reg = x5 } = c
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val gp_regs : core_state -> (register, int32) fmap **)
  
  let gp_regs x = x.gp_regs
  
  (** val seg_regs_starts : core_state -> (segment_register, int32) fmap **)
  
  let seg_regs_starts x = x.seg_regs_starts
  
  (** val seg_regs_limits : core_state -> (segment_register, int32) fmap **)
  
  let seg_regs_limits x = x.seg_regs_limits
  
  (** val flags_reg : core_state -> (flag, int1) fmap **)
  
  let flags_reg x = x.flags_reg
  
  (** val control_regs : core_state -> (control_register, int32) fmap **)
  
  let control_regs x = x.control_regs
  
  (** val debug_regs : core_state -> (debug_register, int32) fmap **)
  
  let debug_regs x = x.debug_regs
  
  (** val pc_reg : core_state -> int0 **)
  
  let pc_reg x = x.pc_reg
  
  type fpu_state = { fpu_data_regs : (int3, int80) fmap; fpu_status : 
                     int16; fpu_control : int16;
                     fpu_tags : (int3, int2) fmap; fpu_lastInstrPtr : 
                     int48; fpu_lastDataPtr : int48; fpu_lastOpcode : 
                     int0 }
  
  (** val fpu_state_rect :
      ((int3, int80) fmap -> int16 -> int16 -> (int3, int2) fmap -> int48 ->
      int48 -> int0 -> 'a1) -> fpu_state -> 'a1 **)
  
  let fpu_state_rect f f0 =
    let { fpu_data_regs = x; fpu_status = x0; fpu_control = x1; fpu_tags =
      x2; fpu_lastInstrPtr = x3; fpu_lastDataPtr = x4; fpu_lastOpcode =
      x5 } = f0
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val fpu_state_rec :
      ((int3, int80) fmap -> int16 -> int16 -> (int3, int2) fmap -> int48 ->
      int48 -> int0 -> 'a1) -> fpu_state -> 'a1 **)
  
  let fpu_state_rec f f0 =
    let { fpu_data_regs = x; fpu_status = x0; fpu_control = x1; fpu_tags =
      x2; fpu_lastInstrPtr = x3; fpu_lastDataPtr = x4; fpu_lastOpcode =
      x5 } = f0
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val fpu_data_regs : fpu_state -> (int3, int80) fmap **)
  
  let fpu_data_regs x = x.fpu_data_regs
  
  (** val fpu_status : fpu_state -> int16 **)
  
  let fpu_status x = x.fpu_status
  
  (** val fpu_control : fpu_state -> int16 **)
  
  let fpu_control x = x.fpu_control
  
  (** val fpu_tags : fpu_state -> (int3, int2) fmap **)
  
  let fpu_tags x = x.fpu_tags
  
  (** val fpu_lastInstrPtr : fpu_state -> int48 **)
  
  let fpu_lastInstrPtr x = x.fpu_lastInstrPtr
  
  (** val fpu_lastDataPtr : fpu_state -> int48 **)
  
  let fpu_lastDataPtr x = x.fpu_lastDataPtr
  
  (** val fpu_lastOpcode : fpu_state -> int0 **)
  
  let fpu_lastOpcode x = x.fpu_lastOpcode
  
  type mach = { core : core_state; fpu : fpu_state }
  
  (** val mach_rect : (core_state -> fpu_state -> 'a1) -> mach -> 'a1 **)
  
  let mach_rect f m =
    let { core = x; fpu = x0 } = m in f x x0
  
  (** val mach_rec : (core_state -> fpu_state -> 'a1) -> mach -> 'a1 **)
  
  let mach_rec f m =
    let { core = x; fpu = x0 } = m in f x x0
  
  (** val core : mach -> core_state **)
  
  let core x = x.core
  
  (** val fpu : mach -> fpu_state **)
  
  let fpu x = x.fpu
  
  type mach_state = mach
  
  (** val get_bits_rng :
      Big.big_int -> int0 -> Big.big_int -> Big.big_int -> int0 **)
  
  let get_bits_rng s i n m =
    Word.repr (minus m n)
      (Word.unsigned s (Word.shru s i (Word.repr s (Z.of_nat n))))
  
  (** val set_bits_rng :
      Big.big_int -> int0 -> Big.big_int -> Big.big_int -> int0 -> int0 **)
  
  let set_bits_rng s i n m v =
    let highbits =
      Word.unsigned s
        (Word.shru s i (Word.repr s (Z.add (Z.of_nat m) Big.one)))
    in
    let lowbits = Z.modulo (Word.unsigned s i) (two_power_nat n) in
    Word.repr s
      (Z.add
        (Z.add lowbits
          (Z.mul (Word.unsigned (minus m n) v) (two_power_nat n)))
        (Z.mul highbits (two_power_nat (plus m (Big.succ Big.zero)))))
  
  (** val get_bit : Big.big_int -> int0 -> Big.big_int -> int1 **)
  
  let get_bit s i n =
    let wordsize0 = Big.succ s in
    if Word.bits_of_Z wordsize0 (Word.unsigned s i) n
    then Word.one Big.zero
    else Word.zero Big.zero
  
  (** val set_bit : Big.big_int -> int0 -> Big.big_int -> bool -> int0 **)
  
  let set_bit s i n v =
    set_bits_rng s i n n (Word.bool_to_int (minus n n) v)
  
  (** val get_fpu_flag_reg : fpu_flag -> fpu_state -> int1 **)
  
  let get_fpu_flag_reg f fs =
    match f with
    | F_Busy ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_C3 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_C2 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.doubleplusone (Big.double Big.one)))
    | F_C1 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.double (Big.double Big.one)))
    | F_C0 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.double (Big.double Big.one)))
    | F_ES ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.doubleplusone Big.one))
    | F_SF ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.doubleplusone Big.one))
    | F_PE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.double Big.one))
    | F_UE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.double Big.one))
    | F_OE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone Big.one)
    | F_ZE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        Big.one)
    | F_DE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status Big.one
    | F_IE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status Big.zero
  
  (** val get_stktop_reg : fpu_state -> int3 **)
  
  let get_stktop_reg fs =
    get_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ Big.zero))))))))))) (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))
  
  (** val get_fpu_ctrl_flag_reg : fpu_ctrl_flag -> fpu_state -> int1 **)
  
  let get_fpu_ctrl_flag_reg f fs =
    match f with
    | F_Res15 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_Res14 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_Res13 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.double (Big.doubleplusone Big.one)))
    | F_Res7 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.doubleplusone Big.one))
    | F_Res6 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.doubleplusone Big.one))
    | F_IC ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.double (Big.doubleplusone Big.one)))
    | F_PM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.double Big.one))
    | F_UM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.double Big.one))
    | F_OM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone Big.one)
    | F_ZM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double Big.one)
    | F_DM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control Big.one
    | F_IM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control Big.zero
  
  (** val get_rctrl_reg : fpu_state -> int2 **)
  
  let get_rctrl_reg fs =
    get_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero)))))))))) (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ Big.zero)))))))))))
  
  (** val get_pctrl_reg : fpu_state -> int2 **)
  
  let get_pctrl_reg fs =
    get_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))) (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))
  
  (** val get_location : Big.big_int -> loc -> mach_state -> int0 **)
  
  let get_location s l m =
    match l with
    | Coq_reg_loc r2 -> look m.core.gp_regs r2
    | Coq_seg_reg_start_loc r2 -> look m.core.seg_regs_starts r2
    | Coq_seg_reg_limit_loc r2 -> look m.core.seg_regs_limits r2
    | Coq_flag_loc f -> look m.core.flags_reg f
    | Coq_control_register_loc r2 -> look m.core.control_regs r2
    | Coq_debug_register_loc r2 -> look m.core.debug_regs r2
    | Coq_pc_loc -> m.core.pc_reg
    | Coq_fpu_stktop_loc -> get_stktop_reg m.fpu
    | Coq_fpu_flag_loc f -> get_fpu_flag_reg f m.fpu
    | Coq_fpu_ctrl_flag_loc f -> get_fpu_ctrl_flag_reg f m.fpu
    | Coq_fpu_lastInstrPtr_loc -> m.fpu.fpu_lastInstrPtr
    | Coq_fpu_lastDataPtr_loc -> m.fpu.fpu_lastDataPtr
    | Coq_fpu_lastOpcode_loc -> m.fpu.fpu_lastOpcode
    | _ -> get_rctrl_reg m.fpu
  
  (** val set_gp_reg : register -> int32 -> mach -> mach **)
  
  let set_gp_reg r2 v m =
    { core = { gp_regs = (upd register_eq_dec m.core.gp_regs r2 v);
      seg_regs_starts = m.core.seg_regs_starts; seg_regs_limits =
      m.core.seg_regs_limits; flags_reg = m.core.flags_reg; control_regs =
      m.core.control_regs; debug_regs = m.core.debug_regs; pc_reg =
      m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_seg_reg_start : segment_register -> int32 -> mach -> mach **)
  
  let set_seg_reg_start r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      (upd segment_register_eq_dec m.core.seg_regs_starts r2 v);
      seg_regs_limits = m.core.seg_regs_limits; flags_reg = m.core.flags_reg;
      control_regs = m.core.control_regs; debug_regs = m.core.debug_regs;
      pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_seg_reg_limit : segment_register -> int32 -> mach -> mach **)
  
  let set_seg_reg_limit r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits =
      (upd segment_register_eq_dec m.core.seg_regs_limits r2 v); flags_reg =
      m.core.flags_reg; control_regs = m.core.control_regs; debug_regs =
      m.core.debug_regs; pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_flags_reg : flag -> int1 -> mach -> mach **)
  
  let set_flags_reg r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = (upd flag_eq_dec m.core.flags_reg r2 v); control_regs =
      m.core.control_regs; debug_regs = m.core.debug_regs; pc_reg =
      m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_control_reg : control_register -> int32 -> mach -> mach **)
  
  let set_control_reg r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = m.core.flags_reg; control_regs =
      (upd control_register_eq_dec m.core.control_regs r2 v); debug_regs =
      m.core.debug_regs; pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_debug_reg : debug_register -> int32 -> mach -> mach **)
  
  let set_debug_reg r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = m.core.flags_reg; control_regs = m.core.control_regs;
      debug_regs = (upd debug_register_eq_dec m.core.debug_regs r2 v);
      pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_pc : int0 -> mach -> mach **)
  
  let set_pc v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = m.core.flags_reg; control_regs = m.core.control_regs;
      debug_regs = m.core.debug_regs; pc_reg = v }; fpu = m.fpu }
  
  (** val set_fpu_stktop_reg : int3 -> mach -> mach **)
  
  let set_fpu_stktop_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status =
      (set_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
        m.fpu.fpu_status (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))) (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ Big.zero))))))))))))) v); fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_flags_reg : fpu_flag -> int1 -> mach -> mach **)
  
  let set_fpu_flags_reg f v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status =
      (let old_status = m.fpu.fpu_status in
       let b = negb (Word.eq Big.zero v (Word.zero Big.zero)) in
       (match f with
        | F_Busy ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) b
        | F_C3 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))) b
        | F_C2 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))) b
        | F_C1 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))) b
        | F_C0 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))) b
        | F_ES ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ Big.zero))))))) b
        | F_SF ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            Big.zero)))))) b
        | F_PE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))) b
        | F_UE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))) b
        | F_OE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ Big.zero))) b
        | F_ZE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ Big.zero)) b
        | F_DE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ Big.zero) b
        | F_IE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            Big.zero b)); fpu_control = m.fpu.fpu_control; fpu_tags =
      m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_rctrl_reg : int2 -> mach -> mach **)
  
  let set_fpu_rctrl_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control =
      (set_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
        m.fpu.fpu_control (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))))))))
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))))))))) v);
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_pctrl_reg : int2 -> mach -> mach **)
  
  let set_fpu_pctrl_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control =
      (set_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
        m.fpu.fpu_control (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))) (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))) v); fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr =
      m.fpu.fpu_lastInstrPtr; fpu_lastDataPtr = m.fpu.fpu_lastDataPtr;
      fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_ctrl_reg : fpu_ctrl_flag -> int1 -> mach -> mach **)
  
  let set_fpu_ctrl_reg f v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control =
      (let old_ctrl = m.fpu.fpu_control in
       let b = negb (Word.eq Big.zero v (Word.zero Big.zero)) in
       (match f with
        | F_Res15 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) b
        | F_Res14 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))) b
        | F_Res13 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ Big.zero))))))))))))) b
        | F_Res7 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ Big.zero))))))) b
        | F_Res6 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            Big.zero)))))) b
        | F_IC ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            Big.zero)))))))))))) b
        | F_PM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))) b
        | F_UM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))) b
        | F_OM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ Big.zero))) b
        | F_ZM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ Big.zero)) b
        | F_DM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ Big.zero) b
        | F_IM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            Big.zero b)); fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr =
      m.fpu.fpu_lastInstrPtr; fpu_lastDataPtr = m.fpu.fpu_lastDataPtr;
      fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_lastInstrPtr_reg : int48 -> mach -> mach **)
  
  let set_fpu_lastInstrPtr_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = v; fpu_lastDataPtr =
      m.fpu.fpu_lastDataPtr; fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_lastDataPtr_reg : int48 -> mach -> mach **)
  
  let set_fpu_lastDataPtr_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = v; fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_lastOpcode_reg : int0 -> mach -> mach **)
  
  let set_lastOpcode_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode = v } }
  
  (** val set_location : Big.big_int -> loc -> int0 -> mach -> mach_state **)
  
  let set_location s l v m =
    match l with
    | Coq_reg_loc r2 -> set_gp_reg r2 v m
    | Coq_seg_reg_start_loc r2 -> set_seg_reg_start r2 v m
    | Coq_seg_reg_limit_loc r2 -> set_seg_reg_limit r2 v m
    | Coq_flag_loc f -> set_flags_reg f v m
    | Coq_control_register_loc r2 -> set_control_reg r2 v m
    | Coq_debug_register_loc r2 -> set_debug_reg r2 v m
    | Coq_pc_loc -> set_pc v m
    | Coq_fpu_stktop_loc -> set_fpu_stktop_reg v m
    | Coq_fpu_flag_loc f -> set_fpu_flags_reg f v m
    | Coq_fpu_rctrl_loc -> set_fpu_rctrl_reg v m
    | Coq_fpu_pctrl_loc -> set_fpu_pctrl_reg v m
    | Coq_fpu_ctrl_flag_loc f -> set_fpu_ctrl_reg f v m
    | Coq_fpu_lastInstrPtr_loc -> set_fpu_lastInstrPtr_reg v m
    | Coq_fpu_lastDataPtr_loc -> set_fpu_lastDataPtr_reg v m
    | Coq_fpu_lastOpcode_loc -> set_lastOpcode_reg v m
  
  (** val array_sub :
      Big.big_int -> Big.big_int -> array -> int0 -> mach_state -> int0 **)
  
  let array_sub l s a i m =
    match a with
    | Coq_fpu_datareg -> look m.fpu.fpu_data_regs i
    | Coq_fpu_tag -> look m.fpu.fpu_tags i
  
  (** val set_fpu_datareg : int3 -> int80 -> mach -> mach **)
  
  let set_fpu_datareg r2 v m =
    { core = m.core; fpu = { fpu_data_regs =
      (upd (Word.eq_dec size3) m.fpu.fpu_data_regs r2 v); fpu_status =
      m.fpu.fpu_status; fpu_control = m.fpu.fpu_control; fpu_tags =
      m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_tags_reg : Word.int -> int2 -> mach -> mach **)
  
  let set_fpu_tags_reg r2 v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = (upd (Word.eq_dec size3) m.fpu.fpu_tags r2 v);
      fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr; fpu_lastDataPtr =
      m.fpu.fpu_lastDataPtr; fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val array_upd :
      Big.big_int -> Big.big_int -> array -> int0 -> int0 -> mach ->
      mach_state **)
  
  let array_upd l s a i v m =
    match a with
    | Coq_fpu_datareg -> set_fpu_datareg i v m
    | Coq_fpu_tag -> set_fpu_tags_reg i v m
 end

module X86_RTL = RTL(X86_MACHINE)

module X86_Compile = 
 struct 
  type conv_state =
    X86_RTL.rtl_instr list
    (* singleton inductive, whose constructor was Build_conv_state *)
  
  (** val conv_state_rect :
      (X86_RTL.rtl_instr list -> 'a1) -> conv_state -> 'a1 **)
  
  let conv_state_rect f c =
    f c
  
  (** val conv_state_rec :
      (X86_RTL.rtl_instr list -> 'a1) -> conv_state -> 'a1 **)
  
  let conv_state_rec f c =
    f c
  
  (** val c_rev_i : conv_state -> X86_RTL.rtl_instr list **)
  
  let c_rev_i c =
    c
  
  type 't coq_Conv = conv_state -> 't * conv_state
  
  (** val coq_Conv_monad : __ coq_Conv monad **)
  
  let coq_Conv_monad =
    { return = (fun _ x s -> (x, s)); bind = (fun _ _ c f s ->
      let (v, s') = c s in f v s') }
  
  (** val runConv : unit coq_Conv -> X86_RTL.rtl_instr list **)
  
  let runConv c =
    let (u, c') = c [] in rev (c_rev_i c')
  
  (** val coq_EMIT : X86_RTL.rtl_instr -> unit coq_Conv **)
  
  let coq_EMIT i s =
    ((), (i :: (c_rev_i s)))
  
  (** val load_Z : Big.big_int -> Big.big_int -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_Z s i =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_imm_rtl_exp (s,
      (Word.repr s i)))
  
  (** val load_int : Big.big_int -> int0 -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_int s i =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_imm_rtl_exp (s, i))
  
  (** val arith :
      Big.big_int -> X86_RTL.bit_vector_op -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let arith s b e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_arith_rtl_exp (s, b, e1,
      e2))
  
  (** val test :
      Big.big_int -> X86_RTL.test_op -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let test s t0 e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_test_rtl_exp (s, t0, e1,
      e2))
  
  (** val load_reg : register -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_reg r2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      (X86_MACHINE.Coq_reg_loc r2)))
  
  (** val set_reg : X86_RTL.rtl_exp -> register -> unit coq_Conv **)
  
  let set_reg p r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size32, p, (X86_MACHINE.Coq_reg_loc
      r2)))
  
  (** val cast_u :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let cast_u s1 s2 e =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_cast_u_rtl_exp (s1, s2,
      e))
  
  (** val cast_s :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let cast_s s1 s2 e =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_cast_s_rtl_exp (s1, s2,
      e))
  
  (** val get_seg_start : segment_register -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_seg_start s =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      (X86_MACHINE.Coq_seg_reg_start_loc s)))
  
  (** val get_seg_limit : segment_register -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_seg_limit s =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      (X86_MACHINE.Coq_seg_reg_limit_loc s)))
  
  (** val read_byte : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let read_byte a =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_byte_rtl_exp a)
  
  (** val write_byte :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let write_byte v a =
    coq_EMIT (X86_RTL.Coq_set_byte_rtl (v, a))
  
  (** val get_flag : X86_MACHINE.flag -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_flag fl =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size1,
      (X86_MACHINE.Coq_flag_loc fl)))
  
  (** val set_flag : X86_MACHINE.flag -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_flag fl r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size1, r2, (X86_MACHINE.Coq_flag_loc
      fl)))
  
  (** val get_pc : X86_RTL.rtl_exp coq_Conv **)
  
  let get_pc =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      X86_MACHINE.Coq_pc_loc))
  
  (** val set_pc : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_pc v =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size32, v, X86_MACHINE.Coq_pc_loc))
  
  (** val if_exp :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let if_exp s g e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_if_rtl_exp (s, g, e1, e2))
  
  (** val if_test : X86_RTL.rtl_exp -> X86_RTL.rtl_instr -> unit coq_Conv **)
  
  let if_test g i =
    coq_EMIT (X86_RTL.Coq_if_rtl (g, i))
  
  (** val choose : Big.big_int -> X86_RTL.rtl_exp coq_Conv **)
  
  let choose s =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_choose_rtl_exp s)
  
  (** val not :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let not s p =
    bind (Obj.magic coq_Conv_monad) (load_Z s (Word.max_unsigned s))
      (fun mask0 -> arith s X86_RTL.Coq_xor_op p mask0)
  
  (** val undef_flag : X86_MACHINE.flag -> unit coq_Conv **)
  
  let undef_flag f =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (choose size1)) (fun v ->
      set_flag f v)
  
  (** val first_bits :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let first_bits s1 s2 x =
    bind (Obj.magic coq_Conv_monad) (load_Z s2 (Z.of_nat (minus s2 s1)))
      (fun c ->
      bind (Obj.magic coq_Conv_monad) (arith s2 X86_RTL.Coq_shru_op x c)
        (fun r2 -> cast_u s2 s1 r2))
  
  (** val last_bits :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let last_bits s1 s2 x =
    bind (Obj.magic coq_Conv_monad)
      (load_Z s2 (two_power_nat (plus s1 (Big.succ Big.zero)))) (fun c ->
      bind (Obj.magic coq_Conv_monad) (arith s2 X86_RTL.Coq_modu_op x c)
        (fun r2 -> cast_u s2 s1 r2))
  
  (** val concat_bits :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let concat_bits s1 s2 x y =
    bind (Obj.magic coq_Conv_monad)
      (cast_u s1 (plus (plus s1 s2) (Big.succ Big.zero)) x) (fun x' ->
      bind (Obj.magic coq_Conv_monad)
        (load_Z (plus (plus s1 s2) (Big.succ Big.zero))
          (Z.of_nat (plus s2 (Big.succ Big.zero)))) (fun c ->
        bind (Obj.magic coq_Conv_monad)
          (arith (plus (plus s1 s2) (Big.succ Big.zero)) X86_RTL.Coq_shl_op
            x' c) (fun raised_x ->
          bind (Obj.magic coq_Conv_monad)
            (cast_u s2 (plus (plus s1 s2) (Big.succ Big.zero)) y) (fun y' ->
            arith (plus (plus s1 s2) (Big.succ Big.zero)) X86_RTL.Coq_add_op
              raised_x y'))))
  
  (** val copy_ps :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let copy_ps s rs =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_cast_u_rtl_exp (s, s, rs))
  
  (** val scale_to_int32 : scale -> int32 **)
  
  let scale_to_int32 s =
    Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))))))))))))))))))))))))))
      (match s with
       | Scale1 -> Big.one
       | Scale2 -> (Big.double Big.one)
       | Scale4 -> (Big.double (Big.double Big.one))
       | Scale8 -> (Big.double (Big.double (Big.double Big.one))))
  
  (** val compute_addr : address -> X86_RTL.rtl_exp coq_Conv **)
  
  let compute_addr a =
    let disp = a.addrDisp in
    (match a.addrBase with
     | Some r2 ->
       (match a.addrIndex with
        | Some p ->
          let (s, r3) = p in
          bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun b ->
            bind (Obj.magic coq_Conv_monad) (load_reg r3) (fun i ->
              bind (Obj.magic coq_Conv_monad)
                (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                  (scale_to_int32 s)) (fun s0 ->
                bind (Obj.magic coq_Conv_monad)
                  (arith size32 X86_RTL.Coq_mul_op i s0) (fun p0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (arith size32 X86_RTL.Coq_add_op b p0) (fun p1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (load_int (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ
                        Big.zero))))))))))))))))))))))))))))))) disp)
                      (fun disp0 -> arith size32 X86_RTL.Coq_add_op p1 disp0))))))
        | None ->
          bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun p1 ->
            bind (Obj.magic coq_Conv_monad)
              (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                disp) (fun p2 -> arith size32 X86_RTL.Coq_add_op p1 p2)))
     | None ->
       (match a.addrIndex with
        | Some p ->
          let (s, r2) = p in
          bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun i ->
            bind (Obj.magic coq_Conv_monad)
              (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                (scale_to_int32 s)) (fun s0 ->
              bind (Obj.magic coq_Conv_monad)
                (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                  disp) (fun disp0 ->
                bind (Obj.magic coq_Conv_monad)
                  (arith size32 X86_RTL.Coq_mul_op i s0) (fun p0 ->
                  arith (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ Big.zero)))))))))))))))))))))))))))))))
                    X86_RTL.Coq_add_op disp0 p0))))
        | None ->
          load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) disp))
  
  (** val add_and_check_segment :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let add_and_check_segment seg a =
    bind (Obj.magic coq_Conv_monad) (get_seg_start seg) (fun p1 ->
      bind (Obj.magic coq_Conv_monad) (arith size32 X86_RTL.Coq_add_op p1 a)
        (fun p2 ->
        bind (Obj.magic coq_Conv_monad) (get_seg_limit seg) (fun p3 ->
          bind (Obj.magic coq_Conv_monad)
            (test size32 X86_RTL.Coq_ltu_op p3 a) (fun guard ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (coq_EMIT (X86_RTL.Coq_if_rtl (guard, X86_RTL.Coq_trap_rtl))))
              (fun x -> return (Obj.magic coq_Conv_monad) p2)))))
  
  (** val lmem :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let lmem seg a =
    bind (Obj.magic coq_Conv_monad) (add_and_check_segment seg a) (fun p ->
      read_byte p)
  
  (** val smem :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let smem seg v a =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (add_and_check_segment seg a))
      (fun p -> write_byte v p)
  
  (** val load_mem_n :
      segment_register -> X86_RTL.rtl_exp -> Big.big_int -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let rec load_mem_n seg addr nbytes_minus_one =
    Big.nat_case
      (fun _ ->
      lmem seg addr)
      (fun n ->
      bind (Obj.magic coq_Conv_monad) (load_mem_n seg addr n) (fun rec0 ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z size32 (Z.of_nat (Big.succ n))) (fun count ->
          bind (Obj.magic coq_Conv_monad)
            (arith size32 X86_RTL.Coq_add_op addr count) (fun p3 ->
            bind (Obj.magic coq_Conv_monad) (lmem seg p3) (fun nb ->
              bind (Obj.magic coq_Conv_monad)
                (cast_u
                  (minus
                    (mult (plus n (Big.succ Big.zero)) (Big.succ (Big.succ
                      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                      (Big.succ Big.zero))))))))) (Big.succ Big.zero))
                  (minus
                    (mult (plus nbytes_minus_one (Big.succ Big.zero))
                      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                      (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                    (Big.succ Big.zero)) rec0) (fun p5 ->
                bind (Obj.magic coq_Conv_monad)
                  (cast_u size8
                    (minus
                      (mult (plus nbytes_minus_one (Big.succ Big.zero))
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                      (Big.succ Big.zero)) nb) (fun p6 ->
                  bind (Obj.magic coq_Conv_monad)
                    (load_Z
                      (minus
                        (mult (plus nbytes_minus_one (Big.succ Big.zero))
                          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                          (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                        (Big.succ Big.zero))
                      (Z.mul (Z.of_nat (Big.succ n)) (Big.double (Big.double
                        (Big.double Big.one))))) (fun p7 ->
                    bind (Obj.magic coq_Conv_monad)
                      (arith
                        (minus
                          (mult (plus nbytes_minus_one (Big.succ Big.zero))
                            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                          (Big.succ Big.zero)) X86_RTL.Coq_shl_op p6 p7)
                      (fun p8 ->
                      arith
                        (minus
                          (mult (plus (Big.succ n) (Big.succ Big.zero))
                            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                          (Big.succ Big.zero)) X86_RTL.Coq_or_op p5 p8)))))))))
      nbytes_minus_one
  
  (** val load_mem80 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem80 seg addr =
    load_mem_n seg addr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))
  
  (** val load_mem64 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem64 seg addr =
    load_mem_n seg addr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero)))))))
  
  (** val load_mem32 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem32 seg addr =
    load_mem_n seg addr (Big.succ (Big.succ (Big.succ Big.zero)))
  
  (** val load_mem16 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem16 seg addr =
    load_mem_n seg addr (Big.succ Big.zero)
  
  (** val load_mem8 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem8 seg addr =
    load_mem_n seg addr Big.zero
  
  (** val opsize : bool -> bool -> Big.big_int **)
  
  let opsize override w =
    if override
    then if w then size16 else size8
    else if w then size32 else size8
  
  (** val load_mem :
      prefix -> bool -> segment_register -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem p w seg op =
    if p.op_override
    then if w then load_mem16 seg op else load_mem8 seg op
    else if w then load_mem32 seg op else load_mem8 seg op
  
  (** val iload_op32 :
      segment_register -> operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let iload_op32 seg = function
  | Imm_op i ->
    load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero))))))))))))))))))))))))))))))) i
  | Reg_op r2 -> load_reg r2
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun p1 ->
      load_mem32 seg p1)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) off) (fun p1 ->
      load_mem32 seg p1)
  
  (** val iload_op16 :
      segment_register -> operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let iload_op16 seg = function
  | Imm_op i ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) i) (fun tmp ->
      cast_u (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) size16 tmp)
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun tmp ->
      cast_u size32 size16 tmp)
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun p1 ->
      load_mem16 seg p1)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) off) (fun p1 ->
      load_mem16 seg p1)
  
  (** val iload_op8 :
      segment_register -> operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let iload_op8 seg = function
  | Imm_op i ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) i) (fun tmp ->
      cast_u (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) size8 tmp)
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad)
      (load_reg
        (match r2 with
         | ESP -> EAX
         | EBP -> ECX
         | ESI -> EDX
         | EDI -> EBX
         | x -> x)) (fun tmp ->
      match r2 with
      | EAX -> cast_u size32 size8 tmp
      | ECX -> cast_u size32 size8 tmp
      | EDX -> cast_u size32 size8 tmp
      | EBX -> cast_u size32 size8 tmp
      | _ ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z size32 (Big.double (Big.double (Big.double Big.one))))
          (fun eight ->
          bind (Obj.magic coq_Conv_monad)
            (arith size32 X86_RTL.Coq_shru_op tmp eight) (fun tmp2 ->
            cast_u size32 size8 tmp2)))
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun p1 ->
      load_mem8 seg p1)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) off) (fun p1 ->
      load_mem8 seg p1)
  
  (** val set_mem_n :
      Big.big_int -> segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      -> unit coq_Conv **)
  
  let rec set_mem_n t0 seg v addr =
    Big.nat_case
      (fun _ ->
      smem seg v addr)
      (fun u ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (cast_u
            (minus
              (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ Big.zero))))))))
                (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
            (minus
              (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ Big.zero))))))))
                (plus u (Big.succ Big.zero))) (Big.succ Big.zero)) v))
        (fun p1 ->
        bind (Obj.magic coq_Conv_monad) (set_mem_n u seg p1 addr) (fun x ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic
              (load_Z
                (minus
                  (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ Big.zero))))))))
                    (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
                (Z.of_nat
                  (mult (Big.succ u) (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))))))))))
            (fun p2 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (arith
                  (minus
                    (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                      (Big.succ (Big.succ (Big.succ Big.zero))))))))
                      (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
                  X86_RTL.Coq_shru_op v p2)) (fun p3 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (cast_u
                    (minus
                      (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ Big.zero))))))))
                        (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
                    size8 p3)) (fun p4 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (load_Z size32 (Z.of_nat (Big.succ u))))
                  (fun p5 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (arith size32 X86_RTL.Coq_add_op p5 addr))
                    (fun p6 -> smem seg p4 p6))))))))
      t0
  
  (** val set_mem80 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem80 seg v a =
    set_mem_n (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ Big.zero))))))))) seg v a
  
  (** val set_mem64 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem64 seg v a =
    set_mem_n (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ Big.zero))))))) seg v a
  
  (** val set_mem32 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem32 seg v a =
    set_mem_n (Big.succ (Big.succ (Big.succ Big.zero))) seg v a
  
  (** val set_mem16 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem16 seg v a =
    set_mem_n (Big.succ Big.zero) seg v a
  
  (** val set_mem8 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem8 seg v a =
    set_mem_n Big.zero seg v a
  
  (** val set_mem :
      prefix -> bool -> segment_register -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem p w seg =
    if p.op_override
    then if w then set_mem16 seg else set_mem8 seg
    else if w then set_mem32 seg else set_mem8 seg
  
  (** val iset_op80 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op80 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size80 size32 p))
      (fun tmp -> set_reg tmp r2)
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size80 size32 p))
        (fun tmp -> set_mem32 seg tmp addr))
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size80 size32 p))
        (fun tmp -> set_mem32 seg tmp addr))
  
  (** val iset_op32 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op32 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 -> set_reg p r2
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      set_mem32 seg p addr)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr -> set_mem32 seg p addr)
  
  (** val iset_op16 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op16 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg r2)) (fun tmp ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_int size32 (Word.mone size32))) (fun mask0 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size32 (Big.double (Big.double (Big.double (Big.double
              Big.one)))))) (fun sixteen ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_shl_op mask0 sixteen))
            (fun mask2 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size32 X86_RTL.Coq_and_op mask2 tmp))
              (fun tmp2 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (cast_u size16 size32 p)) (fun p32 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size32 X86_RTL.Coq_or_op tmp2 p32))
                  (fun tmp3 -> set_reg tmp3 r2)))))))
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      set_mem16 seg p addr)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr -> set_mem16 seg p addr)
  
  (** val iset_op8 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op8 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_reg
          (match r2 with
           | ESP -> EAX
           | EBP -> ECX
           | ESI -> EDX
           | EDI -> EBX
           | x -> x))) (fun tmp0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z size32
            (match r2 with
             | ESP -> (Big.double (Big.double (Big.double Big.one)))
             | EBP -> (Big.double (Big.double (Big.double Big.one)))
             | ESI -> (Big.double (Big.double (Big.double Big.one)))
             | EDI -> (Big.double (Big.double (Big.double Big.one)))
             | _ -> Big.zero))) (fun shift ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (load_int size32 (Word.mone size32))) (fun mone0 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic
              (load_Z size32 (Big.doubleplusone (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone Big.one)))))))))
            (fun mask0 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size32 X86_RTL.Coq_shl_op mask0 shift))
              (fun mask1 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (arith size32 X86_RTL.Coq_xor_op mask1 mone0))
                (fun mask2 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size32 X86_RTL.Coq_and_op tmp0 mask2))
                  (fun tmp1 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (cast_u size8 size32 p)) (fun pext ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (arith size32 X86_RTL.Coq_shl_op pext shift))
                      (fun pext_shift ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith size32 X86_RTL.Coq_or_op tmp1 pext_shift))
                        (fun res ->
                        set_reg res
                          (match r2 with
                           | ESP -> EAX
                           | EBP -> ECX
                           | ESI -> EDX
                           | EDI -> EBX
                           | x -> x)))))))))))
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      set_mem8 seg p addr)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr -> set_mem8 seg p addr)
  
  (** val load_op :
      prefix -> bool -> segment_register -> operand -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let load_op p w seg op =
    if p.op_override
    then if w then iload_op16 seg op else iload_op8 seg op
    else if w then iload_op32 seg op else iload_op8 seg op
  
  (** val set_op :
      prefix -> bool -> segment_register -> X86_RTL.rtl_exp -> operand ->
      unit coq_Conv **)
  
  let set_op p w seg =
    if p.op_override
    then if w then iset_op16 seg else iset_op8 seg
    else if w then iset_op32 seg else iset_op8 seg
  
  (** val get_segment :
      prefix
      ->
      segment_register
      ->
      segment_register **)
  
  let get_segment p def =
    match p.seg_override with
    | Some s ->
      s
    | None ->
      def
  
  (** val op_contains_stack :
      operand
      ->
      bool **)
  
  let op_contains_stack = function
  | Address_op a ->
    (match a.addrBase with
     | Some r2 ->
       (match r2 with
        | ESP ->
          true
        | EBP ->
          true
        | _ ->
          false)
     | None ->
       false)
  | _ ->
    false
  
  (** val get_segment_op :
      prefix
      ->
      segment_register
      ->
      operand
      ->
      segment_register **)
  
  let get_segment_op p def op =
    match p.seg_override with
    | Some s ->
      s
    | None ->
      if op_contains_stack
           op
      then SS
      else def
  
  (** val get_segment_op2 :
      prefix
      ->
      segment_register
      ->
      operand
      ->
      operand
      ->
      segment_register **)
  
  let get_segment_op2 p def op1 op2 =
    match p.seg_override with
    | Some s ->
      s
    | None ->
      let b =
        op_contains_stack
          op1
      in
      let b0 =
        op_contains_stack
          op2
      in
      if b
      then SS
      else if b0
           then SS
           else def
  
  (** val compute_cc :
      condition_type
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let compute_cc = function
  | O_ct ->
    get_flag
      X86_MACHINE.OF
  | NO_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.OF)
      (fun p ->
      not
        size1
        p)
  | B_ct ->
    get_flag
      X86_MACHINE.CF
  | NB_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.CF)
      (fun p ->
      not
        size1
        p)
  | E_ct ->
    get_flag
      X86_MACHINE.ZF
  | NE_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.ZF)
      (fun p ->
      not
        size1
        p)
  | BE_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.CF)
      (fun cf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (get_flag
          X86_MACHINE.ZF)
        (fun zf ->
        arith
          size1
          X86_RTL.Coq_or_op
          cf
          zf))
  | NBE_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.CF)
      (fun cf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (get_flag
          X86_MACHINE.ZF)
        (fun zf ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (arith
            size1
            X86_RTL.Coq_or_op
            cf
            zf)
          (fun p ->
          not
            size1
            p)))
  | S_ct ->
    get_flag
      X86_MACHINE.SF
  | NS_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.SF)
      (fun p ->
      not
        size1
        p)
  | P_ct ->
    get_flag
      X86_MACHINE.PF
  | NP_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.PF)
      (fun p ->
      not
        size1
        p)
  | L_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.SF)
      (fun sf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (get_flag
          X86_MACHINE.OF)
        (fun of0 ->
        arith
          size1
          X86_RTL.Coq_xor_op
          sf
          of0))
  | NL_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.SF)
      (fun sf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (get_flag
          X86_MACHINE.OF)
        (fun of0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (arith
            size1
            X86_RTL.Coq_xor_op
            sf
            of0)
          (fun p ->
          not
            size1
            p)))
  | LE_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.ZF)
      (fun zf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (get_flag
          X86_MACHINE.OF)
        (fun of0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (get_flag
            X86_MACHINE.SF)
          (fun sf ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              size1
              X86_RTL.Coq_xor_op
              of0
              sf)
            (fun p ->
            arith
              size1
              X86_RTL.Coq_or_op
              zf
              p))))
  | NLE_ct ->
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        X86_MACHINE.ZF)
      (fun zf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (get_flag
          X86_MACHINE.OF)
        (fun of0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (get_flag
            X86_MACHINE.SF)
          (fun sf ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              size1
              X86_RTL.Coq_xor_op
              of0
              sf)
            (fun p0 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (arith
                size1
                X86_RTL.Coq_or_op
                zf
                p0)
              (fun p1 ->
              not
                size1
                p1)))))
  
  (** val compute_parity_aux :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let rec compute_parity_aux s op1 op2 n =
    Big.nat_case
      (fun _ ->
      load_Z
        size1
        Big.zero)
      (fun m ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (compute_parity_aux
          s
          op1
          op2
          m)
        (fun op3 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (load_Z
            s
            Big.one)
          (fun one0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              s
              X86_RTL.Coq_shru_op
              op1
              one0)
            (fun op4 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (cast_u
                s
                size1
                op4)
              (fun r2 ->
              arith
                size1
                X86_RTL.Coq_xor_op
                r2
                op3)))))
      n
  
  (** val compute_parity :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let compute_parity s op =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        size1
        Big.zero)
      (fun r2 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (load_Z
          size1
          Big.one)
        (fun one0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (compute_parity_aux
            s
            op
            r2
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero)))))))))
          (fun p ->
          arith
            size1
            X86_RTL.Coq_xor_op
            p
            one0)))
  
  (** val conv_INC :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_INC pre w op =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op)
      (fun p0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            (opsize
              pre.op_override
              w)
            Big.one))
        (fun p1 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              (opsize
                pre.op_override
                w)
              X86_RTL.Coq_add_op
              p0
              p1))
          (fun p2 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (set0
              seg
              p2
              op)
            (fun x ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (load_Z
                  (opsize
                    pre.op_override
                    w)
                  Big.zero))
              (fun zero0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (test
                    (opsize
                      pre.op_override
                      w)
                    X86_RTL.Coq_lt_op
                    p2
                    p0))
                (fun ofp ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_flag
                    X86_MACHINE.OF
                    ofp)
                  (fun x0 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (test
                        (opsize
                          pre.op_override
                          w)
                        X86_RTL.Coq_eq_op
                        p2
                        zero0))
                    (fun zfp ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_flag
                        X86_MACHINE.ZF
                        zfp)
                      (fun x1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (test
                            (opsize
                              pre.op_override
                              w)
                            X86_RTL.Coq_lt_op
                            p2
                            zero0))
                        (fun sfp ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (set_flag
                            X86_MACHINE.SF
                            sfp)
                          (fun x2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (compute_parity
                                (opsize
                                  pre.op_override
                                  w)
                                p2))
                            (fun pfp ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (set_flag
                                X86_MACHINE.PF
                                pfp)
                              (fun x3 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (opsize
                                      pre.op_override
                                      w)
                                    size4
                                    p0))
                                (fun n0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      size4
                                      Big.one))
                                  (fun n1 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size4
                                        X86_RTL.Coq_add_op
                                        n0
                                        n1))
                                    (fun n2 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (test
                                          size4
                                          X86_RTL.Coq_ltu_op
                                          n2
                                          n0))
                                      (fun afp ->
                                      set_flag
                                        X86_MACHINE.AF
                                        afp)))))))))))))))))
  
  (** val conv_DEC :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_DEC pre w op =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op)
      (fun p0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            (opsize
              pre.op_override
              w)
            Big.one))
        (fun p1 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              (opsize
                pre.op_override
                w)
              X86_RTL.Coq_sub_op
              p0
              p1))
          (fun p2 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (set0
              seg
              p2
              op)
            (fun x ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (load_Z
                  (opsize
                    pre.op_override
                    w)
                  Big.zero))
              (fun zero0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (test
                    (opsize
                      pre.op_override
                      w)
                    X86_RTL.Coq_lt_op
                    p0
                    p2))
                (fun ofp ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_flag
                    X86_MACHINE.OF
                    ofp)
                  (fun x0 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (test
                        (opsize
                          pre.op_override
                          w)
                        X86_RTL.Coq_eq_op
                        p2
                        zero0))
                    (fun zfp ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_flag
                        X86_MACHINE.ZF
                        zfp)
                      (fun x1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (test
                            (opsize
                              pre.op_override
                              w)
                            X86_RTL.Coq_lt_op
                            p2
                            zero0))
                        (fun sfp ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (set_flag
                            X86_MACHINE.SF
                            sfp)
                          (fun x2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (compute_parity
                                (opsize
                                  pre.op_override
                                  w)
                                p2))
                            (fun pfp ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (set_flag
                                X86_MACHINE.PF
                                pfp)
                              (fun x3 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (opsize
                                      pre.op_override
                                      w)
                                    size4
                                    p0))
                                (fun n0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      size4
                                      Big.one))
                                  (fun n1 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size4
                                        X86_RTL.Coq_sub_op
                                        n0
                                        n1))
                                    (fun n2 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (test
                                          size4
                                          X86_RTL.Coq_ltu_op
                                          n0
                                          n2))
                                      (fun afp ->
                                      set_flag
                                        X86_MACHINE.AF
                                        afp)))))))))))))))))
  
  (** val conv_ADC :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_ADC pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          (opsize
            pre.op_override
            w)
          Big.zero))
      (fun zero0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size1
            Big.one))
        (fun up ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            load
            seg
            op1)
          (fun p0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              load
              seg
              op2)
            (fun p1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (get_flag
                  X86_MACHINE.CF))
              (fun cf1 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (cast_u
                    size1
                    (opsize
                      pre.op_override
                      w)
                    cf1))
                (fun cfext ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (arith
                      (opsize
                        pre.op_override
                        w)
                      X86_RTL.Coq_add_op
                      p0
                      p1))
                  (fun p2 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (arith
                        (opsize
                          pre.op_override
                          w)
                        X86_RTL.Coq_add_op
                        p2
                        cfext))
                    (fun p3 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set0
                        seg
                        p3
                        op1)
                      (fun x ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (test
                            (opsize
                              pre.op_override
                              w)
                            X86_RTL.Coq_lt_op
                            zero0
                            p0))
                        (fun b0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (test
                              (opsize
                                pre.op_override
                                w)
                              X86_RTL.Coq_lt_op
                              zero0
                              p1))
                          (fun b1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (test
                                (opsize
                                  pre.op_override
                                  w)
                                X86_RTL.Coq_lt_op
                                zero0
                                p3))
                            (fun b2 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  size1
                                  X86_RTL.Coq_xor_op
                                  b0
                                  b1))
                              (fun b3 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size1
                                    X86_RTL.Coq_xor_op
                                    up
                                    b3))
                                (fun b4 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      size1
                                      X86_RTL.Coq_xor_op
                                      b0
                                      b2))
                                  (fun b5 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size1
                                        X86_RTL.Coq_and_op
                                        b4
                                        b5))
                                    (fun b6 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (set_flag
                                        X86_MACHINE.OF
                                        b6)
                                      (fun x0 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (test
                                            (opsize
                                              pre.op_override
                                              w)
                                            X86_RTL.Coq_ltu_op
                                            p3
                                            p0))
                                        (fun b7 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (test
                                              (opsize
                                                pre.op_override
                                                w)
                                              X86_RTL.Coq_ltu_op
                                              p3
                                              p1))
                                          (fun b8 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (arith
                                                size1
                                                X86_RTL.Coq_or_op
                                                b7
                                                b8))
                                            (fun b9 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (set_flag
                                                X86_MACHINE.CF
                                                b9)
                                              (fun x1 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    (opsize
                                                      pre.op_override
                                                      w)
                                                    X86_RTL.Coq_eq_op
                                                    p3
                                                    zero0))
                                                (fun b10 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (set_flag
                                                    X86_MACHINE.ZF
                                                    b10)
                                                  (fun x2 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (test
                                                        (opsize
                                                          pre.op_override
                                                          w)
                                                        X86_RTL.Coq_lt_op
                                                        p3
                                                        zero0))
                                                    (fun b11 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (set_flag
                                                        X86_MACHINE.SF
                                                        b11)
                                                      (fun x3 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (compute_parity
                                                            (opsize
                                                              pre.op_override
                                                              w)
                                                            p3))
                                                        (fun b12 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (set_flag
                                                            X86_MACHINE.PF
                                                            b12)
                                                          (fun x4 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (cast_u
                                                                (opsize
                                                                  pre.op_override
                                                                  w)
                                                                size4
                                                                p0))
                                                            (fun n0 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  (opsize
                                                                    pre.op_override
                                                                    w)
                                                                  size4
                                                                  p1))
                                                              (fun n1 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (cast_u
                                                                    size1
                                                                    size4
                                                                    cf1))
                                                                (fun cf4 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    size4
                                                                    X86_RTL.Coq_add_op
                                                                    n0
                                                                    n1))
                                                                  (fun n2 ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (arith
                                                                    size4
                                                                    X86_RTL.Coq_add_op
                                                                    n2
                                                                    cf4))
                                                                    (fun n3 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (test
                                                                    size4
                                                                    X86_RTL.Coq_ltu_op
                                                                    n3
                                                                    n0))
                                                                    (fun b13 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (test
                                                                    size4
                                                                    X86_RTL.Coq_ltu_op
                                                                    n3
                                                                    n1))
                                                                    (fun b14 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (arith
                                                                    size1
                                                                    X86_RTL.Coq_or_op
                                                                    b13
                                                                    b14))
                                                                    (fun b15 ->
                                                                    set_flag
                                                                    X86_MACHINE.AF
                                                                    b15)))))))))))))))))))))))))))))))))))
  
  (** val conv_STC :
      unit
      coq_Conv **)
  
  let conv_STC =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          Big.one))
      (fun one0 ->
      set_flag
        X86_MACHINE.CF
        one0)
  
  (** val conv_STD :
      unit
      coq_Conv **)
  
  let conv_STD =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          Big.one))
      (fun one0 ->
      set_flag
        X86_MACHINE.DF
        one0)
  
  (** val conv_CLC :
      unit
      coq_Conv **)
  
  let conv_CLC =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          Big.zero))
      (fun zero0 ->
      set_flag
        X86_MACHINE.CF
        zero0)
  
  (** val conv_CLD :
      unit
      coq_Conv **)
  
  let conv_CLD =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          Big.zero))
      (fun zero0 ->
      set_flag
        X86_MACHINE.DF
        zero0)
  
  (** val conv_CMC :
      unit
      coq_Conv **)
  
  let conv_CMC =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          Big.zero))
      (fun zero0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (get_flag
            X86_MACHINE.CF))
        (fun p1 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (test
              size1
              X86_RTL.Coq_eq_op
              zero0
              p1))
          (fun p0 ->
          set_flag
            X86_MACHINE.CF
            p0)))
  
  (** val conv_LAHF :
      unit
      coq_Conv **)
  
  let conv_LAHF =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size8
          Big.zero))
      (fun dst ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (get_flag
            X86_MACHINE.SF))
        (fun fl ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size8
              (Big.doubleplusone
              (Big.doubleplusone
              Big.one))))
          (fun pos ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (cast_u
                size1
                size8
                fl))
            (fun byt ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (arith
                  size8
                  X86_RTL.Coq_shl_op
                  byt
                  pos))
              (fun tmp ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (arith
                    size8
                    X86_RTL.Coq_or_op
                    dst
                    tmp))
                (fun dst0 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (get_flag
                      X86_MACHINE.ZF))
                  (fun fl0 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (load_Z
                        size8
                        (Big.double
                        (Big.doubleplusone
                        Big.one))))
                    (fun pos0 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (cast_u
                          size1
                          size8
                          fl0))
                      (fun byt0 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size8
                            X86_RTL.Coq_shl_op
                            byt0
                            pos0))
                        (fun tmp0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (arith
                              size8
                              X86_RTL.Coq_or_op
                              dst0
                              tmp0))
                          (fun dst1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (get_flag
                                X86_MACHINE.AF))
                            (fun fl1 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (load_Z
                                  size8
                                  (Big.double
                                  (Big.double
                                  Big.one))))
                              (fun pos2 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    size1
                                    size8
                                    fl1))
                                (fun byt1 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      size8
                                      X86_RTL.Coq_shl_op
                                      byt1
                                      pos2))
                                  (fun tmp1 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size8
                                        X86_RTL.Coq_or_op
                                        dst1
                                        tmp1))
                                    (fun dst2 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (get_flag
                                          X86_MACHINE.PF))
                                      (fun fl2 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (load_Z
                                            size8
                                            (Big.double
                                            Big.one)))
                                        (fun pos3 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (cast_u
                                              size1
                                              size8
                                              fl2))
                                          (fun byt2 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (arith
                                                size8
                                                X86_RTL.Coq_shl_op
                                                byt2
                                                pos3))
                                            (fun tmp2 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (arith
                                                  size8
                                                  X86_RTL.Coq_or_op
                                                  dst2
                                                  tmp2))
                                              (fun dst3 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (get_flag
                                                    X86_MACHINE.CF))
                                                (fun fl3 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (load_Z
                                                      size8
                                                      Big.zero))
                                                  (fun pos4 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u
                                                        size1
                                                        size8
                                                        fl3))
                                                    (fun byt3 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith
                                                          size8
                                                          X86_RTL.Coq_shl_op
                                                          byt3
                                                          pos4))
                                                      (fun tmp3 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (arith
                                                            size8
                                                            X86_RTL.Coq_or_op
                                                            dst3
                                                            tmp3))
                                                        (fun dst4 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (load_Z
                                                              size8
                                                              Big.one))
                                                          (fun fl4 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (load_Z
                                                                size8
                                                                Big.one))
                                                            (fun pos5 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  size8
                                                                  size8
                                                                  fl4))
                                                              (fun byt4 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (arith
                                                                    size8
                                                                    X86_RTL.Coq_shl_op
                                                                    byt4
                                                                    pos5))
                                                                (fun tmp4 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    size8
                                                                    X86_RTL.Coq_or_op
                                                                    dst4
                                                                    tmp4))
                                                                  (fun dst5 ->
                                                                  iset_op8
                                                                    DS
                                                                    dst5
                                                                    (Reg_op
                                                                    ESP))))))))))))))))))))))))))))))))
  
  (** val conv_SAHF :
      unit
      coq_Conv **)
  
  let conv_SAHF =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size8
          Big.one))
      (fun one0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (iload_op8
            DS
            (Reg_op
            ESP)))
        (fun ah ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size8
              (Big.doubleplusone
              (Big.doubleplusone
              Big.one))))
          (fun pos ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size8
                X86_RTL.Coq_shr_op
                ah
                pos))
            (fun tmp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (arith
                  size8
                  X86_RTL.Coq_and_op
                  tmp
                  one0))
              (fun tmp0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (test
                    size8
                    X86_RTL.Coq_eq_op
                    one0
                    tmp0))
                (fun b ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_flag
                    X86_MACHINE.SF
                    b)
                  (fun x ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (load_Z
                        size8
                        (Big.double
                        (Big.doubleplusone
                        Big.one))))
                    (fun pos0 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (arith
                          size8
                          X86_RTL.Coq_shr_op
                          ah
                          pos0))
                      (fun tmp1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size8
                            X86_RTL.Coq_and_op
                            tmp1
                            one0))
                        (fun tmp2 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (test
                              size8
                              X86_RTL.Coq_eq_op
                              one0
                              tmp2))
                          (fun b0 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (set_flag
                              X86_MACHINE.ZF
                              b0)
                            (fun x0 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (load_Z
                                  size8
                                  (Big.double
                                  (Big.double
                                  Big.one))))
                              (fun pos2 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size8
                                    X86_RTL.Coq_shr_op
                                    ah
                                    pos2))
                                (fun tmp3 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      size8
                                      X86_RTL.Coq_and_op
                                      tmp3
                                      one0))
                                  (fun tmp4 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (test
                                        size8
                                        X86_RTL.Coq_eq_op
                                        one0
                                        tmp4))
                                    (fun b1 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (set_flag
                                        X86_MACHINE.AF
                                        b1)
                                      (fun x1 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (load_Z
                                            size8
                                            (Big.double
                                            Big.one)))
                                        (fun pos3 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (arith
                                              size8
                                              X86_RTL.Coq_shr_op
                                              ah
                                              pos3))
                                          (fun tmp5 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (arith
                                                size8
                                                X86_RTL.Coq_and_op
                                                tmp5
                                                one0))
                                            (fun tmp6 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size8
                                                  X86_RTL.Coq_eq_op
                                                  one0
                                                  tmp6))
                                              (fun b2 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (set_flag
                                                  X86_MACHINE.PF
                                                  b2)
                                                (fun x2 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (load_Z
                                                      size8
                                                      Big.zero))
                                                  (fun pos4 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith
                                                        size8
                                                        X86_RTL.Coq_shr_op
                                                        ah
                                                        pos4))
                                                    (fun tmp7 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith
                                                          size8
                                                          X86_RTL.Coq_and_op
                                                          tmp7
                                                          one0))
                                                      (fun tmp8 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (test
                                                            size8
                                                            X86_RTL.Coq_eq_op
                                                            one0
                                                            tmp8))
                                                        (fun b3 ->
                                                        set_flag
                                                          X86_MACHINE.CF
                                                          b3))))))))))))))))))))))))))
  
  (** val conv_ADD :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_ADD pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          (opsize
            pre.op_override
            w)
          Big.zero))
      (fun zero0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size1
            Big.one))
        (fun up ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            load
            seg
            op1)
          (fun p0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              load
              seg
              op2)
            (fun p1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (arith
                  (opsize
                    pre.op_override
                    w)
                  X86_RTL.Coq_add_op
                  p0
                  p1))
              (fun p2 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set0
                  seg
                  p2
                  op1)
                (fun x ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (test
                      (opsize
                        pre.op_override
                        w)
                      X86_RTL.Coq_lt_op
                      zero0
                      p0))
                  (fun b0 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (test
                        (opsize
                          pre.op_override
                          w)
                        X86_RTL.Coq_lt_op
                        zero0
                        p1))
                    (fun b1 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (test
                          (opsize
                            pre.op_override
                            w)
                          X86_RTL.Coq_lt_op
                          zero0
                          p2))
                      (fun b2 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size1
                            X86_RTL.Coq_xor_op
                            b0
                            b1))
                        (fun b3 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (arith
                              size1
                              X86_RTL.Coq_xor_op
                              up
                              b3))
                          (fun b4 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                size1
                                X86_RTL.Coq_xor_op
                                b0
                                b2))
                            (fun b5 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  size1
                                  X86_RTL.Coq_and_op
                                  b4
                                  b5))
                              (fun b6 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (set_flag
                                  X86_MACHINE.OF
                                  b6)
                                (fun x0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      (opsize
                                        pre.op_override
                                        w)
                                      X86_RTL.Coq_ltu_op
                                      p2
                                      p0))
                                  (fun b7 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (test
                                        (opsize
                                          pre.op_override
                                          w)
                                        X86_RTL.Coq_ltu_op
                                        p2
                                        p1))
                                    (fun b8 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          size1
                                          X86_RTL.Coq_or_op
                                          b7
                                          b8))
                                      (fun b9 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (set_flag
                                          X86_MACHINE.CF
                                          b9)
                                        (fun x1 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (test
                                              (opsize
                                                pre.op_override
                                                w)
                                              X86_RTL.Coq_eq_op
                                              p2
                                              zero0))
                                          (fun b10 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (set_flag
                                              X86_MACHINE.ZF
                                              b10)
                                            (fun x2 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  (opsize
                                                    pre.op_override
                                                    w)
                                                  X86_RTL.Coq_lt_op
                                                  p2
                                                  zero0))
                                              (fun b11 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (set_flag
                                                  X86_MACHINE.SF
                                                  b11)
                                                (fun x3 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (compute_parity
                                                      (opsize
                                                        pre.op_override
                                                        w)
                                                      p2))
                                                  (fun b12 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (set_flag
                                                      X86_MACHINE.PF
                                                      b12)
                                                    (fun x4 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (cast_u
                                                          (opsize
                                                            pre.op_override
                                                            w)
                                                          size4
                                                          p0))
                                                      (fun n0 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (cast_u
                                                            (opsize
                                                              pre.op_override
                                                              w)
                                                            size4
                                                            p1))
                                                        (fun n1 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (arith
                                                              size4
                                                              X86_RTL.Coq_add_op
                                                              n0
                                                              n1))
                                                          (fun n2 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (test
                                                                size4
                                                                X86_RTL.Coq_ltu_op
                                                                n2
                                                                n0))
                                                            (fun b13 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (test
                                                                  size4
                                                                  X86_RTL.Coq_ltu_op
                                                                  n2
                                                                  n1))
                                                              (fun b14 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (arith
                                                                    size1
                                                                    X86_RTL.Coq_or_op
                                                                    b13
                                                                    b14))
                                                                (fun b15 ->
                                                                set_flag
                                                                  X86_MACHINE.AF
                                                                  b15))))))))))))))))))))))))))))))
  
  (** val conv_SUB_CMP_generic :
      bool
      ->
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      operand
      ->
      segment_register
      ->
      segment_register
      ->
      segment_register
      ->
      unit
      coq_Conv **)
  
  let conv_SUB_CMP_generic e pre w dest op1 op2 segdest seg1 seg2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          (opsize
            pre.op_override
            w)
          Big.zero))
      (fun zero0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size1
            Big.one))
        (fun up ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            load
            seg1
            op1)
          (fun p0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              load
              seg2
              op2)
            (fun p1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (arith
                  (opsize
                    pre.op_override
                    w)
                  X86_RTL.Coq_sub_op
                  p0
                  p1))
              (fun p2 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (arith
                    (opsize
                      pre.op_override
                      w)
                    X86_RTL.Coq_sub_op
                    zero0
                    p1))
                (fun negp1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (test
                      (opsize
                        pre.op_override
                        w)
                      X86_RTL.Coq_lt_op
                      zero0
                      p0))
                  (fun b0 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (test
                        (opsize
                          pre.op_override
                          w)
                        X86_RTL.Coq_lt_op
                        zero0
                        negp1))
                    (fun b1 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (test
                          (opsize
                            pre.op_override
                            w)
                          X86_RTL.Coq_lt_op
                          zero0
                          p2))
                      (fun b2 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size1
                            X86_RTL.Coq_xor_op
                            b0
                            b1))
                        (fun b3 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (arith
                              size1
                              X86_RTL.Coq_xor_op
                              up
                              b3))
                          (fun b4 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                size1
                                X86_RTL.Coq_xor_op
                                b0
                                b2))
                            (fun b5 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  size1
                                  X86_RTL.Coq_and_op
                                  b4
                                  b5))
                              (fun b6 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (set_flag
                                  X86_MACHINE.OF
                                  b6)
                                (fun x ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      (opsize
                                        pre.op_override
                                        w)
                                      X86_RTL.Coq_ltu_op
                                      p0
                                      p1))
                                  (fun b7 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (set_flag
                                      X86_MACHINE.CF
                                      b7)
                                    (fun x0 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (test
                                          (opsize
                                            pre.op_override
                                            w)
                                          X86_RTL.Coq_eq_op
                                          p2
                                          zero0))
                                      (fun b8 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (set_flag
                                          X86_MACHINE.ZF
                                          b8)
                                        (fun x1 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (test
                                              (opsize
                                                pre.op_override
                                                w)
                                              X86_RTL.Coq_lt_op
                                              p2
                                              zero0))
                                          (fun b9 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (set_flag
                                              X86_MACHINE.SF
                                              b9)
                                            (fun x2 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (compute_parity
                                                  (opsize
                                                    pre.op_override
                                                    w)
                                                  p2))
                                              (fun b10 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (set_flag
                                                  X86_MACHINE.PF
                                                  b10)
                                                (fun x3 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u
                                                      (opsize
                                                        pre.op_override
                                                        w)
                                                      size4
                                                      p0))
                                                  (fun n0 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u
                                                        (opsize
                                                          pre.op_override
                                                          w)
                                                        size4
                                                        p1))
                                                    (fun n1 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (test
                                                          (opsize
                                                            pre.op_override
                                                            w)
                                                          X86_RTL.Coq_ltu_op
                                                          p0
                                                          p1))
                                                      (fun b11 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (set_flag
                                                          X86_MACHINE.AF
                                                          b11)
                                                        (fun x4 ->
                                                        if e
                                                        then set0
                                                               segdest
                                                               p2
                                                               dest
                                                        else return
                                                               (Obj.magic
                                                                 coq_Conv_monad)
                                                               ()))))))))))))))))))))))))))
  
  (** val conv_CMP :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_CMP pre w op1 op2 =
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    conv_SUB_CMP_generic
      false
      pre
      w
      op1
      op1
      op2
      seg
      seg
      seg
  
  (** val conv_SUB :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_SUB pre w op1 op2 =
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    conv_SUB_CMP_generic
      true
      pre
      w
      op1
      op1
      op2
      seg
      seg
      seg
  
  (** val conv_NEG :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_NEG pre w op1 =
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    conv_SUB_CMP_generic
      true
      pre
      w
      op1
      (Imm_op
      (Word.zero
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero)))))))))))))))))))))))))))))))))
      op1
      seg
      seg
      seg
  
  (** val conv_SBB :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_SBB pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          (opsize
            pre.op_override
            w)
          Big.zero))
      (fun zero0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size1
            Big.one))
        (fun up ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (get_flag
              X86_MACHINE.CF))
          (fun old_cf ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (cast_u
                size1
                (opsize
                  pre.op_override
                  w)
                old_cf))
            (fun old_cf_ext ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                load
                seg
                op1)
              (fun p0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  load
                  seg
                  op2)
                (fun p1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (arith
                      (opsize
                        pre.op_override
                        w)
                      X86_RTL.Coq_sub_op
                      p0
                      p1))
                  (fun p2_0 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (arith
                        (opsize
                          pre.op_override
                          w)
                        X86_RTL.Coq_sub_op
                        p2_0
                        old_cf_ext))
                    (fun p2 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (arith
                          (opsize
                            pre.op_override
                            w)
                          X86_RTL.Coq_sub_op
                          zero0
                          p1))
                      (fun negp1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (test
                            (opsize
                              pre.op_override
                              w)
                            X86_RTL.Coq_lt_op
                            zero0
                            p0))
                        (fun b0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (test
                              (opsize
                                pre.op_override
                                w)
                              X86_RTL.Coq_lt_op
                              zero0
                              negp1))
                          (fun b1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (test
                                (opsize
                                  pre.op_override
                                  w)
                                X86_RTL.Coq_lt_op
                                zero0
                                p2))
                            (fun b2 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  size1
                                  X86_RTL.Coq_xor_op
                                  b0
                                  b1))
                              (fun b3 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size1
                                    X86_RTL.Coq_xor_op
                                    up
                                    b3))
                                (fun b4 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      size1
                                      X86_RTL.Coq_xor_op
                                      b0
                                      b2))
                                  (fun b5 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size1
                                        X86_RTL.Coq_and_op
                                        b4
                                        b5))
                                    (fun b6 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (set_flag
                                        X86_MACHINE.OF
                                        b6)
                                      (fun x ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (test
                                            (opsize
                                              pre.op_override
                                              w)
                                            X86_RTL.Coq_ltu_op
                                            p0
                                            p1))
                                        (fun b0' ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (test
                                              (opsize
                                                pre.op_override
                                                w)
                                              X86_RTL.Coq_eq_op
                                              p0
                                              p1))
                                          (fun b0'' ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (arith
                                                size1
                                                X86_RTL.Coq_or_op
                                                b0'
                                                b0''))
                                            (fun b7 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (set_flag
                                                X86_MACHINE.CF
                                                b7)
                                              (fun x0 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    (opsize
                                                      pre.op_override
                                                      w)
                                                    X86_RTL.Coq_eq_op
                                                    p2
                                                    zero0))
                                                (fun b8 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (set_flag
                                                    X86_MACHINE.ZF
                                                    b8)
                                                  (fun x1 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (test
                                                        (opsize
                                                          pre.op_override
                                                          w)
                                                        X86_RTL.Coq_lt_op
                                                        p2
                                                        zero0))
                                                    (fun b9 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (set_flag
                                                        X86_MACHINE.SF
                                                        b9)
                                                      (fun x2 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (compute_parity
                                                            (opsize
                                                              pre.op_override
                                                              w)
                                                            p2))
                                                        (fun b10 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (set_flag
                                                            X86_MACHINE.PF
                                                            b10)
                                                          (fun x3 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (cast_u
                                                                (opsize
                                                                  pre.op_override
                                                                  w)
                                                                size4
                                                                p0))
                                                            (fun n0 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  (opsize
                                                                    pre.op_override
                                                                    w)
                                                                  size4
                                                                  p1))
                                                              (fun n1 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (test
                                                                    (opsize
                                                                    pre.op_override
                                                                    w)
                                                                    X86_RTL.Coq_ltu_op
                                                                    p0
                                                                    p1))
                                                                (fun b0'0 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (test
                                                                    (opsize
                                                                    pre.op_override
                                                                    w)
                                                                    X86_RTL.Coq_eq_op
                                                                    p0
                                                                    p1))
                                                                  (fun b0''0 ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (arith
                                                                    size1
                                                                    X86_RTL.Coq_or_op
                                                                    b0'0
                                                                    b0''0))
                                                                    (fun b11 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (set_flag
                                                                    X86_MACHINE.AF
                                                                    b11)
                                                                    (fun x4 ->
                                                                    set0
                                                                    seg
                                                                    p2
                                                                    op1)))))))))))))))))))))))))))))))))
  
  (** val conv_DIV :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_DIV pre w op =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.CF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.OF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.SF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.ZF)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.AF)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (undef_flag
                  X86_MACHINE.PF)
                (fun x4 ->
                if pre.op_override
                then if w
                     then bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op16
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend_lower ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op16
                                  seg
                                  (Reg_op
                                  EDX)))
                              (fun dividend_upper ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    size16
                                    size32
                                    dividend_upper))
                                (fun dividend0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      size32
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      Big.one))))))
                                  (fun sixteen ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size32
                                        X86_RTL.Coq_shl_op
                                        dividend0
                                        sixteen))
                                    (fun dividend1 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u
                                          size16
                                          size32
                                          dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size32
                                            X86_RTL.Coq_or_op
                                            dividend1
                                            dividend_lower_ext))
                                        (fun dividend ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (iload_op16
                                              seg
                                              op))
                                          (fun divisor ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z
                                                size16
                                                Big.zero))
                                            (fun zero0 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size16
                                                  X86_RTL.Coq_eq_op
                                                  zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (coq_EMIT
                                                  (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u
                                                      size16
                                                      size32
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith
                                                        size32
                                                        X86_RTL.Coq_divu_op
                                                        dividend
                                                        divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z
                                                          size32
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one)))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (test
                                                            size32
                                                            X86_RTL.Coq_ltu_op
                                                            max_quotient
                                                            quotient))
                                                        (fun div_error ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (coq_EMIT
                                                            (X86_RTL.Coq_if_rtl
                                                            (div_error,
                                                            X86_RTL.Coq_trap_rtl)))
                                                          (fun x6 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (arith
                                                                size32
                                                                X86_RTL.Coq_modu_op
                                                                dividend
                                                                divisor_ext))
                                                            (fun remainder ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  size32
                                                                  size16
                                                                  quotient))
                                                              (fun quotient_trunc ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (cast_u
                                                                    size32
                                                                    size16
                                                                    remainder))
                                                                (fun remainder_trunc ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (iset_op16
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                  (fun x7 ->
                                                                  iset_op16
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX)))))))))))))))))))))
                     else bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op16
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op8
                                  seg
                                  op))
                              (fun divisor ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (load_Z
                                    size8
                                    Big.zero))
                                (fun zero0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      size8
                                      X86_RTL.Coq_eq_op
                                      zero0
                                      divisor))
                                  (fun divide_by_zero ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (coq_EMIT
                                      (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl)))
                                    (fun x5 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u
                                          size8
                                          size16
                                          divisor))
                                      (fun divisor_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size16
                                            X86_RTL.Coq_divu_op
                                            dividend
                                            divisor_ext))
                                        (fun quotient ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z
                                              size16
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one)))))))))
                                          (fun max_quotient ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (test
                                                size16
                                                X86_RTL.Coq_ltu_op
                                                max_quotient
                                                quotient))
                                            (fun div_error ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (coq_EMIT
                                                (X86_RTL.Coq_if_rtl
                                                (div_error,
                                                X86_RTL.Coq_trap_rtl)))
                                              (fun x6 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (arith
                                                    size16
                                                    X86_RTL.Coq_modu_op
                                                    dividend
                                                    divisor_ext))
                                                (fun remainder ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u
                                                      size16
                                                      size8
                                                      quotient))
                                                  (fun quotient_trunc ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u
                                                        size16
                                                        size8
                                                        remainder))
                                                    (fun remainder_trunc ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (iset_op8
                                                        seg
                                                        quotient_trunc
                                                        (Reg_op
                                                        EAX))
                                                      (fun x7 ->
                                                      iset_op8
                                                        seg
                                                        remainder_trunc
                                                        (Reg_op
                                                        ESP)))))))))))))))
                else if w
                     then bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op32
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend_lower ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op32
                                  seg
                                  (Reg_op
                                  EDX)))
                              (fun dividend_upper ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    size32
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    dividend_upper))
                                (fun dividend0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      Big.one)))))))
                                  (fun thirtytwo ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        X86_RTL.Coq_shl_op
                                        dividend0
                                        thirtytwo))
                                    (fun dividend1 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u
                                          size32
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            X86_RTL.Coq_or_op
                                            dividend1
                                            dividend_lower_ext))
                                        (fun dividend ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (iload_op32
                                              seg
                                              op))
                                          (fun divisor ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z
                                                size32
                                                Big.zero))
                                            (fun zero0 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size32
                                                  X86_RTL.Coq_eq_op
                                                  zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (coq_EMIT
                                                  (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u
                                                      size32
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                        X86_RTL.Coq_divu_op
                                                        dividend
                                                        divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one)))))))))))))))))))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (test
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                            X86_RTL.Coq_ltu_op
                                                            max_quotient
                                                            quotient))
                                                        (fun div_error ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (coq_EMIT
                                                            (X86_RTL.Coq_if_rtl
                                                            (div_error,
                                                            X86_RTL.Coq_trap_rtl)))
                                                          (fun x6 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (arith
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                X86_RTL.Coq_modu_op
                                                                dividend
                                                                divisor_ext))
                                                            (fun remainder ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                  size32
                                                                  quotient))
                                                              (fun quotient_trunc ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (cast_u
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    size32
                                                                    remainder))
                                                                (fun remainder_trunc ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (iset_op32
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                  (fun x7 ->
                                                                  iset_op32
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX)))))))))))))))))))))
                     else bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op16
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op8
                                  seg
                                  op))
                              (fun divisor ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (load_Z
                                    size8
                                    Big.zero))
                                (fun zero0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      size8
                                      X86_RTL.Coq_eq_op
                                      zero0
                                      divisor))
                                  (fun divide_by_zero ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (coq_EMIT
                                      (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl)))
                                    (fun x5 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u
                                          size8
                                          size16
                                          divisor))
                                      (fun divisor_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size16
                                            X86_RTL.Coq_divu_op
                                            dividend
                                            divisor_ext))
                                        (fun quotient ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z
                                              size16
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one)))))))))
                                          (fun max_quotient ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (test
                                                size16
                                                X86_RTL.Coq_ltu_op
                                                max_quotient
                                                quotient))
                                            (fun div_error ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (coq_EMIT
                                                (X86_RTL.Coq_if_rtl
                                                (div_error,
                                                X86_RTL.Coq_trap_rtl)))
                                              (fun x6 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (arith
                                                    size16
                                                    X86_RTL.Coq_modu_op
                                                    dividend
                                                    divisor_ext))
                                                (fun remainder ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u
                                                      size16
                                                      size8
                                                      quotient))
                                                  (fun quotient_trunc ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u
                                                        size16
                                                        size8
                                                        remainder))
                                                    (fun remainder_trunc ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (iset_op8
                                                        seg
                                                        quotient_trunc
                                                        (Reg_op
                                                        EAX))
                                                      (fun x7 ->
                                                      iset_op8
                                                        seg
                                                        remainder_trunc
                                                        (Reg_op
                                                        ESP)))))))))))))))))))))
  
  (** val conv_IDIV :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_IDIV pre w op =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.CF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.OF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.SF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.ZF)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.AF)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (undef_flag
                  X86_MACHINE.PF)
                (fun x4 ->
                if pre.op_override
                then if w
                     then bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op16
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend_lower ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op16
                                  seg
                                  (Reg_op
                                  EDX)))
                              (fun dividend_upper ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_s
                                    size16
                                    size32
                                    dividend_upper))
                                (fun dividend0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      size32
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      Big.one))))))
                                  (fun sixteen ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size32
                                        X86_RTL.Coq_shl_op
                                        dividend0
                                        sixteen))
                                    (fun dividend1 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s
                                          size16
                                          size32
                                          dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size32
                                            X86_RTL.Coq_or_op
                                            dividend1
                                            dividend_lower_ext))
                                        (fun dividend ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (iload_op16
                                              seg
                                              op))
                                          (fun divisor ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z
                                                size16
                                                Big.zero))
                                            (fun zero0 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size16
                                                  X86_RTL.Coq_eq_op
                                                  zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (coq_EMIT
                                                  (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_s
                                                      size16
                                                      size32
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith
                                                        size32
                                                        X86_RTL.Coq_divs_op
                                                        dividend
                                                        divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z
                                                          size32
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (load_Z
                                                            size32
                                                            (Big.opp
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            Big.one))))))))))))))))))
                                                        (fun min_quotient ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (test
                                                              size32
                                                              X86_RTL.Coq_lt_op
                                                              max_quotient
                                                              quotient))
                                                          (fun div_error0 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (test
                                                                size32
                                                                X86_RTL.Coq_lt_op
                                                                quotient
                                                                min_quotient))
                                                            (fun div_error1 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (arith
                                                                  size1
                                                                  X86_RTL.Coq_or_op
                                                                  div_error0
                                                                  div_error1))
                                                              (fun div_error ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (coq_EMIT
                                                                  (X86_RTL.Coq_if_rtl
                                                                  (div_error,
                                                                  X86_RTL.Coq_trap_rtl)))
                                                                (fun x6 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    size32
                                                                    X86_RTL.Coq_mods_op
                                                                    dividend
                                                                    divisor_ext))
                                                                  (fun remainder ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    size32
                                                                    size16
                                                                    quotient))
                                                                    (fun quotient_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    size32
                                                                    size16
                                                                    remainder))
                                                                    (fun remainder_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (iset_op16
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                    (fun x7 ->
                                                                    iset_op16
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX))))))))))))))))))))))))
                     else bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op16
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op8
                                  seg
                                  op))
                              (fun divisor ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (load_Z
                                    size8
                                    Big.zero))
                                (fun zero0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      size8
                                      X86_RTL.Coq_eq_op
                                      zero0
                                      divisor))
                                  (fun divide_by_zero ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (coq_EMIT
                                      (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl)))
                                    (fun x5 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s
                                          size8
                                          size16
                                          divisor))
                                      (fun divisor_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size16
                                            X86_RTL.Coq_divs_op
                                            dividend
                                            divisor_ext))
                                        (fun quotient ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z
                                              size16
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one))))))))
                                          (fun max_quotient ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z
                                                size16
                                                (Big.opp
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                Big.one))))))))))
                                            (fun min_quotient ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size16
                                                  X86_RTL.Coq_lt_op
                                                  max_quotient
                                                  quotient))
                                              (fun div_error0 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    size16
                                                    X86_RTL.Coq_lt_op
                                                    quotient
                                                    min_quotient))
                                                (fun div_error1 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (arith
                                                      size1
                                                      X86_RTL.Coq_or_op
                                                      div_error0
                                                      div_error1))
                                                  (fun div_error ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (coq_EMIT
                                                      (X86_RTL.Coq_if_rtl
                                                      (div_error,
                                                      X86_RTL.Coq_trap_rtl)))
                                                    (fun x6 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith
                                                          size16
                                                          X86_RTL.Coq_mods_op
                                                          dividend
                                                          divisor_ext))
                                                      (fun remainder ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (cast_s
                                                            size16
                                                            size8
                                                            quotient))
                                                        (fun quotient_trunc ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (cast_s
                                                              size16
                                                              size8
                                                              remainder))
                                                          (fun remainder_trunc ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (iset_op8
                                                              seg
                                                              quotient_trunc
                                                              (Reg_op
                                                              EAX))
                                                            (fun x7 ->
                                                            iset_op8
                                                              seg
                                                              remainder_trunc
                                                              (Reg_op
                                                              ESP))))))))))))))))))
                else if w
                     then bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op32
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend_lower ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op32
                                  seg
                                  (Reg_op
                                  EDX)))
                              (fun dividend_upper ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_s
                                    size32
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    dividend_upper))
                                (fun dividend0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      Big.one)))))))
                                  (fun thirtytwo ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        X86_RTL.Coq_shl_op
                                        dividend0
                                        thirtytwo))
                                    (fun dividend1 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s
                                          size32
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            X86_RTL.Coq_or_op
                                            dividend1
                                            dividend_lower_ext))
                                        (fun dividend ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (iload_op32
                                              seg
                                              op))
                                          (fun divisor ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z
                                                size32
                                                Big.zero))
                                            (fun zero0 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size32
                                                  X86_RTL.Coq_eq_op
                                                  zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (coq_EMIT
                                                  (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_s
                                                      size32
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      (Big.succ
                                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        (Big.succ
                                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                        X86_RTL.Coq_divs_op
                                                        dividend
                                                        divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          (Big.succ
                                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one))))))))))))))))))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (load_Z
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                            (Big.opp
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            Big.one))))))))))))))))))))))))))))))))))
                                                        (fun min_quotient ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (test
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                              X86_RTL.Coq_lt_op
                                                              max_quotient
                                                              quotient))
                                                          (fun div_error0 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (test
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                X86_RTL.Coq_lt_op
                                                                quotient
                                                                min_quotient))
                                                            (fun div_error1 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (arith
                                                                  size1
                                                                  X86_RTL.Coq_or_op
                                                                  div_error0
                                                                  div_error1))
                                                              (fun div_error ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (coq_EMIT
                                                                  (X86_RTL.Coq_if_rtl
                                                                  (div_error,
                                                                  X86_RTL.Coq_trap_rtl)))
                                                                (fun x6 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    X86_RTL.Coq_mods_op
                                                                    dividend
                                                                    divisor_ext))
                                                                  (fun remainder ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    size32
                                                                    quotient))
                                                                    (fun quotient_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    size32
                                                                    remainder))
                                                                    (fun remainder_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (iset_op32
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                    (fun x7 ->
                                                                    iset_op32
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX))))))))))))))))))))))))
                     else bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (iload_op16
                                seg
                                (Reg_op
                                EAX)))
                            (fun dividend ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (iload_op8
                                  seg
                                  op))
                              (fun divisor ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (load_Z
                                    size8
                                    Big.zero))
                                (fun zero0 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      size8
                                      X86_RTL.Coq_eq_op
                                      zero0
                                      divisor))
                                  (fun divide_by_zero ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (coq_EMIT
                                      (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl)))
                                    (fun x5 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s
                                          size8
                                          size16
                                          divisor))
                                      (fun divisor_ext ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size16
                                            X86_RTL.Coq_divs_op
                                            dividend
                                            divisor_ext))
                                        (fun quotient ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z
                                              size16
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one))))))))
                                          (fun max_quotient ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z
                                                size16
                                                (Big.opp
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                (Big.double
                                                Big.one))))))))))
                                            (fun min_quotient ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size16
                                                  X86_RTL.Coq_lt_op
                                                  max_quotient
                                                  quotient))
                                              (fun div_error0 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    size16
                                                    X86_RTL.Coq_lt_op
                                                    quotient
                                                    min_quotient))
                                                (fun div_error1 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (arith
                                                      size1
                                                      X86_RTL.Coq_or_op
                                                      div_error0
                                                      div_error1))
                                                  (fun div_error ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (coq_EMIT
                                                      (X86_RTL.Coq_if_rtl
                                                      (div_error,
                                                      X86_RTL.Coq_trap_rtl)))
                                                    (fun x6 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith
                                                          size16
                                                          X86_RTL.Coq_mods_op
                                                          dividend
                                                          divisor_ext))
                                                      (fun remainder ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (cast_s
                                                            size16
                                                            size8
                                                            quotient))
                                                        (fun quotient_trunc ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (cast_s
                                                              size16
                                                              size8
                                                              remainder))
                                                          (fun remainder_trunc ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (iset_op8
                                                              seg
                                                              quotient_trunc
                                                              (Reg_op
                                                              EAX))
                                                            (fun x7 ->
                                                            iset_op8
                                                              seg
                                                              remainder_trunc
                                                              (Reg_op
                                                              ESP))))))))))))))))))))))))
  
  (** val conv_IMUL :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      option
      ->
      int32
      option
      ->
      unit
      coq_Conv **)
  
  let conv_IMUL pre w op1 opopt2 iopt =
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.SF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.ZF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.AF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.PF)
            (fun x2 ->
            match opopt2 with
            | Some op2 ->
              (match iopt with
               | Some imm3 ->
                 let load =
                   load_op
                     pre
                     w
                 in
                 let set0 =
                   set_op
                     pre
                     w
                 in
                 let seg =
                   get_segment_op2
                     pre
                     DS
                     op1
                     op2
                 in
                 bind
                   (Obj.magic
                     coq_Conv_monad)
                   (Obj.magic
                     load
                     seg
                     op2)
                   (fun p1 ->
                   bind
                     (Obj.magic
                       coq_Conv_monad)
                     (Obj.magic
                       (load_int
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         Big.zero)))))))))))))))))))))))))))))))
                         imm3))
                     (fun p2 ->
                     bind
                       (Obj.magic
                         coq_Conv_monad)
                       (Obj.magic
                         (cast_s
                           (opsize
                             pre.op_override
                             w)
                           (minus
                             (mult
                               (Big.succ
                               (Big.succ
                               Big.zero))
                               (plus
                                 (opsize
                                   pre.op_override
                                   w)
                                 (Big.succ
                                 Big.zero)))
                             (Big.succ
                             Big.zero))
                           p1))
                       (fun p1ext ->
                       bind
                         (Obj.magic
                           coq_Conv_monad)
                         (Obj.magic
                           (cast_s
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             (Big.succ
                             Big.zero)))))))))))))))))))))))))))))))
                             (minus
                               (mult
                                 (Big.succ
                                 (Big.succ
                                 Big.zero))
                                 (plus
                                   (opsize
                                     pre.op_override
                                     w)
                                   (Big.succ
                                   Big.zero)))
                               (Big.succ
                               Big.zero))
                             p2))
                         (fun p2ext ->
                         bind
                           (Obj.magic
                             coq_Conv_monad)
                           (Obj.magic
                             (arith
                               (minus
                                 (mult
                                   (Big.succ
                                   (Big.succ
                                   Big.zero))
                                   (plus
                                     (opsize
                                       pre.op_override
                                       w)
                                     (Big.succ
                                     Big.zero)))
                                 (Big.succ
                                 Big.zero))
                               X86_RTL.Coq_mul_op
                               p1ext
                               p2ext))
                           (fun res ->
                           bind
                             (Obj.magic
                               coq_Conv_monad)
                             (Obj.magic
                               (cast_s
                                 (minus
                                   (mult
                                     (Big.succ
                                     (Big.succ
                                     Big.zero))
                                     (plus
                                       (opsize
                                         pre.op_override
                                         w)
                                       (Big.succ
                                       Big.zero)))
                                   (Big.succ
                                   Big.zero))
                                 (opsize
                                   pre.op_override
                                   w)
                                 res))
                             (fun lowerhalf ->
                             bind
                               (Obj.magic
                                 coq_Conv_monad)
                               (Obj.magic
                                 (cast_s
                                   (opsize
                                     pre.op_override
                                     w)
                                   (minus
                                     (mult
                                       (Big.succ
                                       (Big.succ
                                       Big.zero))
                                       (plus
                                         (opsize
                                           pre.op_override
                                           w)
                                         (Big.succ
                                         Big.zero)))
                                     (Big.succ
                                     Big.zero))
                                   lowerhalf))
                               (fun reextend ->
                               bind
                                 (Obj.magic
                                   coq_Conv_monad)
                                 (Obj.magic
                                   (test
                                     (minus
                                       (mult
                                         (Big.succ
                                         (Big.succ
                                         Big.zero))
                                         (plus
                                           (opsize
                                             pre.op_override
                                             w)
                                           (Big.succ
                                           Big.zero)))
                                       (Big.succ
                                       Big.zero))
                                     X86_RTL.Coq_eq_op
                                     reextend
                                     res))
                                 (fun b0 ->
                                 bind
                                   (Obj.magic
                                     coq_Conv_monad)
                                   (Obj.magic
                                     (not
                                       size1
                                       b0))
                                   (fun flag0 ->
                                   bind
                                     (Obj.magic
                                       coq_Conv_monad)
                                     (set_flag
                                       X86_MACHINE.CF
                                       flag0)
                                     (fun x3 ->
                                     bind
                                       (Obj.magic
                                         coq_Conv_monad)
                                       (set_flag
                                         X86_MACHINE.OF
                                         flag0)
                                       (fun x4 ->
                                       set0
                                         seg
                                         lowerhalf
                                         op1)))))))))))
               | None ->
                 let load =
                   load_op
                     pre
                     w
                 in
                 let set0 =
                   set_op
                     pre
                     w
                 in
                 let seg =
                   get_segment_op2
                     pre
                     DS
                     op1
                     op2
                 in
                 bind
                   (Obj.magic
                     coq_Conv_monad)
                   (Obj.magic
                     load
                     seg
                     op1)
                   (fun p1 ->
                   bind
                     (Obj.magic
                       coq_Conv_monad)
                     (Obj.magic
                       load
                       seg
                       op2)
                     (fun p2 ->
                     bind
                       (Obj.magic
                         coq_Conv_monad)
                       (Obj.magic
                         (cast_s
                           (opsize
                             pre.op_override
                             w)
                           (minus
                             (mult
                               (Big.succ
                               (Big.succ
                               Big.zero))
                               (plus
                                 (opsize
                                   pre.op_override
                                   w)
                                 (Big.succ
                                 Big.zero)))
                             (Big.succ
                             Big.zero))
                           p1))
                       (fun p1ext ->
                       bind
                         (Obj.magic
                           coq_Conv_monad)
                         (Obj.magic
                           (cast_s
                             (opsize
                               pre.op_override
                               w)
                             (minus
                               (mult
                                 (Big.succ
                                 (Big.succ
                                 Big.zero))
                                 (plus
                                   (opsize
                                     pre.op_override
                                     w)
                                   (Big.succ
                                   Big.zero)))
                               (Big.succ
                               Big.zero))
                             p2))
                         (fun p2ext ->
                         bind
                           (Obj.magic
                             coq_Conv_monad)
                           (Obj.magic
                             (arith
                               (minus
                                 (mult
                                   (Big.succ
                                   (Big.succ
                                   Big.zero))
                                   (plus
                                     (opsize
                                       pre.op_override
                                       w)
                                     (Big.succ
                                     Big.zero)))
                                 (Big.succ
                                 Big.zero))
                               X86_RTL.Coq_mul_op
                               p1ext
                               p2ext))
                           (fun res ->
                           bind
                             (Obj.magic
                               coq_Conv_monad)
                             (Obj.magic
                               (cast_s
                                 (minus
                                   (mult
                                     (Big.succ
                                     (Big.succ
                                     Big.zero))
                                     (plus
                                       (opsize
                                         pre.op_override
                                         w)
                                       (Big.succ
                                       Big.zero)))
                                   (Big.succ
                                   Big.zero))
                                 (opsize
                                   pre.op_override
                                   w)
                                 res))
                             (fun lowerhalf ->
                             bind
                               (Obj.magic
                                 coq_Conv_monad)
                               (Obj.magic
                                 (cast_s
                                   (opsize
                                     pre.op_override
                                     w)
                                   (minus
                                     (mult
                                       (Big.succ
                                       (Big.succ
                                       Big.zero))
                                       (plus
                                         (opsize
                                           pre.op_override
                                           w)
                                         (Big.succ
                                         Big.zero)))
                                     (Big.succ
                                     Big.zero))
                                   lowerhalf))
                               (fun reextend ->
                               bind
                                 (Obj.magic
                                   coq_Conv_monad)
                                 (Obj.magic
                                   (test
                                     (minus
                                       (mult
                                         (Big.succ
                                         (Big.succ
                                         Big.zero))
                                         (plus
                                           (opsize
                                             pre.op_override
                                             w)
                                           (Big.succ
                                           Big.zero)))
                                       (Big.succ
                                       Big.zero))
                                     X86_RTL.Coq_eq_op
                                     reextend
                                     res))
                                 (fun b0 ->
                                 bind
                                   (Obj.magic
                                     coq_Conv_monad)
                                   (Obj.magic
                                     (not
                                       size1
                                       b0))
                                   (fun flag0 ->
                                   bind
                                     (Obj.magic
                                       coq_Conv_monad)
                                     (set_flag
                                       X86_MACHINE.CF
                                       flag0)
                                     (fun x3 ->
                                     bind
                                       (Obj.magic
                                         coq_Conv_monad)
                                       (set_flag
                                         X86_MACHINE.OF
                                         flag0)
                                       (fun x4 ->
                                       set0
                                         seg
                                         lowerhalf
                                         op1))))))))))))
            | None ->
              let load =
                load_op
                  pre
                  w
              in
              let seg =
                get_segment_op
                  pre
                  DS
                  op1
              in
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  load
                  seg
                  (Reg_op
                  EAX))
                (fun p1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    load
                    seg
                    op1)
                  (fun p2 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (cast_s
                        (opsize
                          pre.op_override
                          w)
                        (minus
                          (mult
                            (Big.succ
                            (Big.succ
                            Big.zero))
                            (plus
                              (opsize
                                pre.op_override
                                w)
                              (Big.succ
                              Big.zero)))
                          (Big.succ
                          Big.zero))
                        p1))
                    (fun p1ext ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (cast_s
                          (opsize
                            pre.op_override
                            w)
                          (minus
                            (mult
                              (Big.succ
                              (Big.succ
                              Big.zero))
                              (plus
                                (opsize
                                  pre.op_override
                                  w)
                                (Big.succ
                                Big.zero)))
                            (Big.succ
                            Big.zero))
                          p2))
                      (fun p2ext ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            (minus
                              (mult
                                (Big.succ
                                (Big.succ
                                Big.zero))
                                (plus
                                  (opsize
                                    pre.op_override
                                    w)
                                  (Big.succ
                                  Big.zero)))
                              (Big.succ
                              Big.zero))
                            X86_RTL.Coq_mul_op
                            p1ext
                            p2ext))
                        (fun res ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (cast_s
                              (minus
                                (mult
                                  (Big.succ
                                  (Big.succ
                                  Big.zero))
                                  (plus
                                    (opsize
                                      pre.op_override
                                      w)
                                    (Big.succ
                                    Big.zero)))
                                (Big.succ
                                Big.zero))
                              (opsize
                                pre.op_override
                                w)
                              res))
                          (fun lowerhalf ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (load_Z
                                (minus
                                  (mult
                                    (Big.succ
                                    (Big.succ
                                    Big.zero))
                                    (plus
                                      (opsize
                                        pre.op_override
                                        w)
                                      (Big.succ
                                      Big.zero)))
                                  (Big.succ
                                  Big.zero))
                                (Z.of_nat
                                  (plus
                                    (opsize
                                      pre.op_override
                                      w)
                                    (Big.succ
                                    Big.zero)))))
                            (fun shift ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (minus
                                    (mult
                                      (Big.succ
                                      (Big.succ
                                      Big.zero))
                                      (plus
                                        (opsize
                                          pre.op_override
                                          w)
                                        (Big.succ
                                        Big.zero)))
                                    (Big.succ
                                    Big.zero))
                                  X86_RTL.Coq_shr_op
                                  res
                                  shift))
                              (fun res_shifted ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_s
                                    (minus
                                      (mult
                                        (Big.succ
                                        (Big.succ
                                        Big.zero))
                                        (plus
                                          (opsize
                                            pre.op_override
                                            w)
                                          (Big.succ
                                          Big.zero)))
                                      (Big.succ
                                      Big.zero))
                                    (opsize
                                      pre.op_override
                                      w)
                                    res_shifted))
                                (fun upperhalf ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      (opsize
                                        pre.op_override
                                        w)
                                      Big.zero))
                                  (fun zero0 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z
                                        (opsize
                                          pre.op_override
                                          w)
                                        (Word.max_unsigned
                                          (opsize
                                            pre.op_override
                                            w))))
                                    (fun max0 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (test
                                          (opsize
                                            pre.op_override
                                            w)
                                          X86_RTL.Coq_eq_op
                                          upperhalf
                                          zero0))
                                      (fun b0 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (test
                                            (opsize
                                              pre.op_override
                                              w)
                                            X86_RTL.Coq_eq_op
                                            upperhalf
                                            max0))
                                        (fun b1 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (arith
                                              size1
                                              X86_RTL.Coq_or_op
                                              b0
                                              b1))
                                          (fun b2 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (not
                                                size1
                                                b2))
                                            (fun flag0 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (set_flag
                                                X86_MACHINE.CF
                                                flag0)
                                              (fun x3 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (set_flag
                                                  X86_MACHINE.OF
                                                  flag0)
                                                (fun x4 ->
                                                if w
                                                then let set0 =
                                                       set_op
                                                         pre
                                                         w
                                                     in
                                                     bind
                                                       (Obj.magic
                                                         coq_Conv_monad)
                                                       (set0
                                                         seg
                                                         lowerhalf
                                                         (Reg_op
                                                         EAX))
                                                       (fun x5 ->
                                                       set0
                                                         seg
                                                         upperhalf
                                                         (Reg_op
                                                         EDX))
                                                else iset_op16
                                                       seg
                                                       res
                                                       (Reg_op
                                                       EAX))))))))))))))))))))))
  
  (** val conv_MUL :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_MUL pre w op =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.SF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.ZF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.AF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.PF)
            (fun x2 ->
            if pre.op_override
            then if w
                 then bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (iload_op16
                            seg
                            op))
                        (fun p1 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (iload_op16
                              seg
                              (Reg_op
                              EAX)))
                          (fun p2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (cast_u
                                size16
                                size32
                                p1))
                            (fun p1ext ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (cast_u
                                  size16
                                  size32
                                  p2))
                              (fun p2ext ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size32
                                    X86_RTL.Coq_mul_op
                                    p1ext
                                    p2ext))
                                (fun res ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (cast_u
                                      size32
                                      size16
                                      res))
                                  (fun res_lower ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z
                                        size32
                                        (Big.double
                                        (Big.double
                                        (Big.double
                                        (Big.double
                                        Big.one))))))
                                    (fun sixteen ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          size32
                                          X86_RTL.Coq_shru_op
                                          res
                                          sixteen))
                                      (fun res_shifted ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (cast_u
                                            size32
                                            size16
                                            res_shifted))
                                        (fun res_upper ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (iset_op16
                                            seg
                                            res_lower
                                            (Reg_op
                                            EAX))
                                          (fun x3 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (iset_op16
                                              seg
                                              res_upper
                                              (Reg_op
                                              EDX))
                                            (fun x4 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (load_Z
                                                  size16
                                                  Big.zero))
                                              (fun zero0 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    size16
                                                    X86_RTL.Coq_ltu_op
                                                    zero0
                                                    res_upper))
                                                (fun cf_test ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (set_flag
                                                    X86_MACHINE.CF
                                                    cf_test)
                                                  (fun x5 ->
                                                  set_flag
                                                    X86_MACHINE.OF
                                                    cf_test))))))))))))))
                 else bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (iload_op8
                            seg
                            op))
                        (fun p1 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (iload_op8
                              seg
                              (Reg_op
                              EAX)))
                          (fun p2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (cast_u
                                size8
                                size16
                                p1))
                            (fun p1ext ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (cast_u
                                  size8
                                  size16
                                  p2))
                              (fun p2ext ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size16
                                    X86_RTL.Coq_mul_op
                                    p1ext
                                    p2ext))
                                (fun res ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (iset_op16
                                    seg
                                    res
                                    (Reg_op
                                    EAX))
                                  (fun x3 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z
                                        size16
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        Big.one)))))))))
                                    (fun max0 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (test
                                          size16
                                          X86_RTL.Coq_ltu_op
                                          max0
                                          res))
                                      (fun cf_test ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (set_flag
                                          X86_MACHINE.CF
                                          cf_test)
                                        (fun x4 ->
                                        set_flag
                                          X86_MACHINE.OF
                                          cf_test)))))))))
            else if w
                 then bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (iload_op32
                            seg
                            op))
                        (fun p1 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (iload_op32
                              seg
                              (Reg_op
                              EAX)))
                          (fun p2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (cast_u
                                size32
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                p1))
                            (fun p1ext ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (cast_u
                                  size32
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                  p2))
                              (fun p2ext ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    X86_RTL.Coq_mul_op
                                    p1ext
                                    p2ext))
                                (fun res ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (cast_u
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      size32
                                      res))
                                  (fun res_lower ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        (Big.double
                                        (Big.double
                                        (Big.double
                                        (Big.double
                                        (Big.double
                                        Big.one)))))))
                                    (fun thirtytwo ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          X86_RTL.Coq_shru_op
                                          res
                                          thirtytwo))
                                      (fun res_shifted ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (cast_u
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            size32
                                            res_shifted))
                                        (fun res_upper ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (iset_op32
                                            seg
                                            res_lower
                                            (Reg_op
                                            EAX))
                                          (fun x3 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (iset_op32
                                              seg
                                              res_upper
                                              (Reg_op
                                              EDX))
                                            (fun x4 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (load_Z
                                                  size32
                                                  Big.zero))
                                              (fun zero0 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    size32
                                                    X86_RTL.Coq_ltu_op
                                                    zero0
                                                    res_upper))
                                                (fun cf_test ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (set_flag
                                                    X86_MACHINE.CF
                                                    cf_test)
                                                  (fun x5 ->
                                                  set_flag
                                                    X86_MACHINE.OF
                                                    cf_test))))))))))))))
                 else bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (iload_op8
                            seg
                            op))
                        (fun p1 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (iload_op8
                              seg
                              (Reg_op
                              EAX)))
                          (fun p2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (cast_u
                                size8
                                size16
                                p1))
                            (fun p1ext ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (cast_u
                                  size8
                                  size16
                                  p2))
                              (fun p2ext ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size16
                                    X86_RTL.Coq_mul_op
                                    p1ext
                                    p2ext))
                                (fun res ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (iset_op16
                                    seg
                                    res
                                    (Reg_op
                                    EAX))
                                  (fun x3 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z
                                        size16
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        (Big.doubleplusone
                                        Big.one)))))))))
                                    (fun max0 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (test
                                          size16
                                          X86_RTL.Coq_ltu_op
                                          max0
                                          res))
                                      (fun cf_test ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (set_flag
                                          X86_MACHINE.CF
                                          cf_test)
                                        (fun x4 ->
                                        set_flag
                                          X86_MACHINE.OF
                                          cf_test)))))))))))))
  
  (** val conv_shift :
      X86_RTL.bit_vector_op
      ->
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_shift shift pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.OF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.CF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.SF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.ZF)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.PF)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (undef_flag
                  X86_MACHINE.AF)
                (fun x4 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    load
                    seg
                    op1)
                  (fun p1 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (match op2 with
                     | Reg_ri r2 ->
                       Obj.magic
                         (iload_op8
                           seg
                           (Reg_op
                           r2))
                     | Imm_ri i ->
                       Obj.magic
                         (load_int
                           (Big.succ
                           (Big.succ
                           (Big.succ
                           (Big.succ
                           (Big.succ
                           (Big.succ
                           (Big.succ
                           Big.zero)))))))
                           i))
                    (fun p2 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (load_Z
                          size8
                          (Big.doubleplusone
                          (Big.doubleplusone
                          (Big.doubleplusone
                          (Big.doubleplusone
                          Big.one))))))
                      (fun mask0 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size8
                            X86_RTL.Coq_and_op
                            p2
                            mask0))
                        (fun p3 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (cast_u
                              size8
                              (opsize
                                pre.op_override
                                w)
                              p3))
                          (fun p2cast ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                (opsize
                                  pre.op_override
                                  w)
                                shift
                                p1
                                p2cast))
                            (fun p4 ->
                            set0
                              seg
                              p4
                              op1))))))))))))
  
  (** val conv_SHL :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_SHL pre w op1 op2 =
    conv_shift
      X86_RTL.Coq_shl_op
      pre
      w
      op1
      op2
  
  (** val conv_SAR :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_SAR pre w op1 op2 =
    conv_shift
      X86_RTL.Coq_shr_op
      pre
      w
      op1
      op2
  
  (** val conv_SHR :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_SHR pre w op1 op2 =
    conv_shift
      X86_RTL.Coq_shru_op
      pre
      w
      op1
      op2
  
  (** val conv_ROR :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_ROR pre w op1 op2 =
    conv_shift
      X86_RTL.Coq_ror_op
      pre
      w
      op1
      op2
  
  (** val conv_ROL :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_ROL pre w op1 op2 =
    conv_shift
      X86_RTL.Coq_rol_op
      pre
      w
      op1
      op2
  
  (** val conv_RCL :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_RCL pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op1)
      (fun p1 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (match op2 with
         | Reg_ri r2 ->
           Obj.magic
             (iload_op8
               seg
               (Reg_op
               r2))
         | Imm_ri i ->
           Obj.magic
             (load_int
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               Big.zero)))))))
               i))
        (fun p2 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size8
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              Big.one))))))
          (fun mask0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size8
                X86_RTL.Coq_and_op
                p2
                mask0))
            (fun p3 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Big.nat_case
                 (fun _ ->
                 return
                   (Obj.magic
                     coq_Conv_monad)
                   ())
                 (fun n ->
                 Big.nat_case
                   (fun _ ->
                   return
                     (Obj.magic
                       coq_Conv_monad)
                     ())
                   (fun n0 ->
                   Big.nat_case
                     (fun _ ->
                     return
                       (Obj.magic
                         coq_Conv_monad)
                       ())
                     (fun n1 ->
                     Big.nat_case
                       (fun _ ->
                       return
                         (Obj.magic
                           coq_Conv_monad)
                         ())
                       (fun n2 ->
                       Big.nat_case
                         (fun _ ->
                         return
                           (Obj.magic
                             coq_Conv_monad)
                           ())
                         (fun n3 ->
                         Big.nat_case
                           (fun _ ->
                           return
                             (Obj.magic
                               coq_Conv_monad)
                             ())
                           (fun n4 ->
                           Big.nat_case
                             (fun _ ->
                             return
                               (Obj.magic
                                 coq_Conv_monad)
                               ())
                             (fun n5 ->
                             Big.nat_case
                               (fun _ ->
                               bind
                                 (Obj.magic
                                   coq_Conv_monad)
                                 (Obj.magic
                                   (load_Z
                                     size8
                                     (Big.doubleplusone
                                     (Big.double
                                     (Big.double
                                     Big.one)))))
                                 (fun modmask ->
                                 bind
                                   (Obj.magic
                                     coq_Conv_monad)
                                   (Obj.magic
                                     (arith
                                       size8
                                       X86_RTL.Coq_modu_op
                                       p3
                                       modmask))
                                   (fun p4 ->
                                   return
                                     (Obj.magic
                                       coq_Conv_monad)
                                     ())))
                               (fun n6 ->
                               Big.nat_case
                                 (fun _ ->
                                 return
                                   (Obj.magic
                                     coq_Conv_monad)
                                   ())
                                 (fun n7 ->
                                 Big.nat_case
                                   (fun _ ->
                                   return
                                     (Obj.magic
                                       coq_Conv_monad)
                                     ())
                                   (fun n8 ->
                                   Big.nat_case
                                     (fun _ ->
                                     return
                                       (Obj.magic
                                         coq_Conv_monad)
                                       ())
                                     (fun n9 ->
                                     Big.nat_case
                                       (fun _ ->
                                       return
                                         (Obj.magic
                                           coq_Conv_monad)
                                         ())
                                       (fun n10 ->
                                       Big.nat_case
                                         (fun _ ->
                                         return
                                           (Obj.magic
                                             coq_Conv_monad)
                                           ())
                                         (fun n11 ->
                                         Big.nat_case
                                           (fun _ ->
                                           return
                                             (Obj.magic
                                               coq_Conv_monad)
                                             ())
                                           (fun n12 ->
                                           Big.nat_case
                                             (fun _ ->
                                             return
                                               (Obj.magic
                                                 coq_Conv_monad)
                                               ())
                                             (fun n13 ->
                                             Big.nat_case
                                               (fun _ ->
                                               bind
                                                 (Obj.magic
                                                   coq_Conv_monad)
                                                 (Obj.magic
                                                   (load_Z
                                                     size8
                                                     (Big.doubleplusone
                                                     (Big.double
                                                     (Big.double
                                                     (Big.double
                                                     Big.one))))))
                                                 (fun modmask ->
                                                 bind
                                                   (Obj.magic
                                                     coq_Conv_monad)
                                                   (Obj.magic
                                                     (arith
                                                       size8
                                                       X86_RTL.Coq_modu_op
                                                       p3
                                                       modmask))
                                                   (fun p4 ->
                                                   return
                                                     (Obj.magic
                                                       coq_Conv_monad)
                                                     ())))
                                               (fun n14 ->
                                               return
                                                 (Obj.magic
                                                   coq_Conv_monad)
                                                 ())
                                               n13)
                                             n12)
                                           n11)
                                         n10)
                                       n9)
                                     n8)
                                   n7)
                                 n6)
                               n5)
                             n4)
                           n3)
                         n2)
                       n1)
                     n0)
                   n)
                 (opsize
                   pre.op_override
                   w))
              (fun x ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (cast_u
                    size8
                    (plus
                      (opsize
                        pre.op_override
                        w)
                      (Big.succ
                      Big.zero))
                    p3))
                (fun p2cast ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (cast_u
                      (opsize
                        pre.op_override
                        w)
                      (plus
                        (opsize
                          pre.op_override
                          w)
                        (Big.succ
                        Big.zero))
                      p1))
                  (fun tmp ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (get_flag
                        X86_MACHINE.CF))
                    (fun cf ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (cast_u
                          size1
                          (plus
                            (opsize
                              pre.op_override
                              w)
                            (Big.succ
                            Big.zero))
                          cf))
                      (fun cf0 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (load_Z
                            (plus
                              (opsize
                                pre.op_override
                                w)
                              (Big.succ
                              Big.zero))
                            (Z.of_nat
                              (plus
                                (opsize
                                  pre.op_override
                                  w)
                                (Big.succ
                                Big.zero)))))
                        (fun tt ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (arith
                              (plus
                                (opsize
                                  pre.op_override
                                  w)
                                (Big.succ
                                Big.zero))
                              X86_RTL.Coq_shl_op
                              cf0
                              tt))
                          (fun cf1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                (plus
                                  (opsize
                                    pre.op_override
                                    w)
                                  (Big.succ
                                  Big.zero))
                                X86_RTL.Coq_or_op
                                tmp
                                cf1))
                            (fun tmp0 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (plus
                                    (opsize
                                      pre.op_override
                                      w)
                                    (Big.succ
                                    Big.zero))
                                  X86_RTL.Coq_rol_op
                                  tmp0
                                  p2cast))
                              (fun tmp1 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (plus
                                      (opsize
                                        pre.op_override
                                        w)
                                      (Big.succ
                                      Big.zero))
                                    (opsize
                                      pre.op_override
                                      w)
                                    tmp1))
                                (fun p4 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      (plus
                                        (opsize
                                          pre.op_override
                                          w)
                                        (Big.succ
                                        Big.zero))
                                      X86_RTL.Coq_shr_op
                                      tmp1
                                      tt))
                                  (fun cf2 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u
                                        (plus
                                          (opsize
                                            pre.op_override
                                            w)
                                          (Big.succ
                                          Big.zero))
                                        size1
                                        cf2))
                                    (fun cf3 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (undef_flag
                                        X86_MACHINE.OF)
                                      (fun x0 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (set_flag
                                          X86_MACHINE.CF
                                          cf3)
                                        (fun x1 ->
                                        set0
                                          seg
                                          p4
                                          op1))))))))))))))))))
  
  (** val conv_RCR :
      prefix
      ->
      bool
      ->
      operand
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_RCR pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op1)
      (fun p1 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (match op2 with
         | Reg_ri r2 ->
           Obj.magic
             (iload_op8
               seg
               (Reg_op
               r2))
         | Imm_ri i ->
           Obj.magic
             (load_int
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               (Big.succ
               Big.zero)))))))
               i))
        (fun p2 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size8
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              Big.one))))))
          (fun mask0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size8
                X86_RTL.Coq_and_op
                p2
                mask0))
            (fun p3 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Big.nat_case
                 (fun _ ->
                 return
                   (Obj.magic
                     coq_Conv_monad)
                   ())
                 (fun n ->
                 Big.nat_case
                   (fun _ ->
                   return
                     (Obj.magic
                       coq_Conv_monad)
                     ())
                   (fun n0 ->
                   Big.nat_case
                     (fun _ ->
                     return
                       (Obj.magic
                         coq_Conv_monad)
                       ())
                     (fun n1 ->
                     Big.nat_case
                       (fun _ ->
                       return
                         (Obj.magic
                           coq_Conv_monad)
                         ())
                       (fun n2 ->
                       Big.nat_case
                         (fun _ ->
                         return
                           (Obj.magic
                             coq_Conv_monad)
                           ())
                         (fun n3 ->
                         Big.nat_case
                           (fun _ ->
                           return
                             (Obj.magic
                               coq_Conv_monad)
                             ())
                           (fun n4 ->
                           Big.nat_case
                             (fun _ ->
                             return
                               (Obj.magic
                                 coq_Conv_monad)
                               ())
                             (fun n5 ->
                             Big.nat_case
                               (fun _ ->
                               bind
                                 (Obj.magic
                                   coq_Conv_monad)
                                 (Obj.magic
                                   (load_Z
                                     size8
                                     (Big.doubleplusone
                                     (Big.double
                                     (Big.double
                                     Big.one)))))
                                 (fun modmask ->
                                 bind
                                   (Obj.magic
                                     coq_Conv_monad)
                                   (Obj.magic
                                     (arith
                                       size8
                                       X86_RTL.Coq_modu_op
                                       p3
                                       modmask))
                                   (fun p4 ->
                                   return
                                     (Obj.magic
                                       coq_Conv_monad)
                                     ())))
                               (fun n6 ->
                               Big.nat_case
                                 (fun _ ->
                                 return
                                   (Obj.magic
                                     coq_Conv_monad)
                                   ())
                                 (fun n7 ->
                                 Big.nat_case
                                   (fun _ ->
                                   return
                                     (Obj.magic
                                       coq_Conv_monad)
                                     ())
                                   (fun n8 ->
                                   Big.nat_case
                                     (fun _ ->
                                     return
                                       (Obj.magic
                                         coq_Conv_monad)
                                       ())
                                     (fun n9 ->
                                     Big.nat_case
                                       (fun _ ->
                                       return
                                         (Obj.magic
                                           coq_Conv_monad)
                                         ())
                                       (fun n10 ->
                                       Big.nat_case
                                         (fun _ ->
                                         return
                                           (Obj.magic
                                             coq_Conv_monad)
                                           ())
                                         (fun n11 ->
                                         Big.nat_case
                                           (fun _ ->
                                           return
                                             (Obj.magic
                                               coq_Conv_monad)
                                             ())
                                           (fun n12 ->
                                           Big.nat_case
                                             (fun _ ->
                                             return
                                               (Obj.magic
                                                 coq_Conv_monad)
                                               ())
                                             (fun n13 ->
                                             Big.nat_case
                                               (fun _ ->
                                               bind
                                                 (Obj.magic
                                                   coq_Conv_monad)
                                                 (Obj.magic
                                                   (load_Z
                                                     size8
                                                     (Big.doubleplusone
                                                     (Big.double
                                                     (Big.double
                                                     (Big.double
                                                     Big.one))))))
                                                 (fun modmask ->
                                                 bind
                                                   (Obj.magic
                                                     coq_Conv_monad)
                                                   (Obj.magic
                                                     (arith
                                                       size8
                                                       X86_RTL.Coq_modu_op
                                                       p3
                                                       modmask))
                                                   (fun p4 ->
                                                   return
                                                     (Obj.magic
                                                       coq_Conv_monad)
                                                     ())))
                                               (fun n14 ->
                                               return
                                                 (Obj.magic
                                                   coq_Conv_monad)
                                                 ())
                                               n13)
                                             n12)
                                           n11)
                                         n10)
                                       n9)
                                     n8)
                                   n7)
                                 n6)
                               n5)
                             n4)
                           n3)
                         n2)
                       n1)
                     n0)
                   n)
                 (opsize
                   pre.op_override
                   w))
              (fun x ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (cast_u
                    size8
                    (plus
                      (opsize
                        pre.op_override
                        w)
                      (Big.succ
                      Big.zero))
                    p3))
                (fun p2cast ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (load_Z
                      (plus
                        (opsize
                          pre.op_override
                          w)
                        (Big.succ
                        Big.zero))
                      Big.one))
                  (fun oneshift ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (cast_u
                        (opsize
                          pre.op_override
                          w)
                        (plus
                          (opsize
                            pre.op_override
                            w)
                          (Big.succ
                          Big.zero))
                        p1))
                    (fun tmp ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (arith
                          (plus
                            (opsize
                              pre.op_override
                              w)
                            (Big.succ
                            Big.zero))
                          X86_RTL.Coq_shl_op
                          tmp
                          oneshift))
                      (fun tmp0 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (get_flag
                            X86_MACHINE.CF))
                        (fun cf ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (cast_u
                              size1
                              (plus
                                (opsize
                                  pre.op_override
                                  w)
                                (Big.succ
                                Big.zero))
                              cf))
                          (fun cf0 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                (plus
                                  (opsize
                                    pre.op_override
                                    w)
                                  (Big.succ
                                  Big.zero))
                                X86_RTL.Coq_or_op
                                tmp0
                                cf0))
                            (fun tmp1 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (plus
                                    (opsize
                                      pre.op_override
                                      w)
                                    (Big.succ
                                    Big.zero))
                                  X86_RTL.Coq_ror_op
                                  tmp1
                                  p2cast))
                              (fun tmp2 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (plus
                                      (opsize
                                        pre.op_override
                                        w)
                                      (Big.succ
                                      Big.zero))
                                    size1
                                    tmp2))
                                (fun cf1 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      (plus
                                        (opsize
                                          pre.op_override
                                          w)
                                        (Big.succ
                                        Big.zero))
                                      X86_RTL.Coq_shr_op
                                      tmp2
                                      oneshift))
                                  (fun p4 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u
                                        (plus
                                          (opsize
                                            pre.op_override
                                            w)
                                          (Big.succ
                                          Big.zero))
                                        (opsize
                                          pre.op_override
                                          w)
                                        p4))
                                    (fun p5 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (undef_flag
                                        X86_MACHINE.OF)
                                      (fun x0 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (set_flag
                                          X86_MACHINE.CF
                                          cf1)
                                        (fun x1 ->
                                        set0
                                          seg
                                          p5
                                          op1))))))))))))))))))
  
  (** val conv_SHLD :
      prefix
      ->
      operand
      ->
      register
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_SHLD pre op1 r2 ri =
    let load =
      load_op
        pre
        true
    in
    let set0 =
      set_op
        pre
        true
    in
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (match ri with
       | Reg_ri r3 ->
         Obj.magic
           (iload_op8
             seg
             (Reg_op
             r3))
       | Imm_ri i ->
         Obj.magic
           (load_int
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             Big.zero)))))))
             i))
      (fun count ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size8
            (Big.double
            (Big.double
            (Big.double
            (Big.double
            (Big.double
            Big.one)))))))
        (fun thirtytwo ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              size8
              X86_RTL.Coq_modu_op
              count
              thirtytwo))
          (fun count0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.CF)
            (fun x ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.SF)
              (fun x0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (undef_flag
                  X86_MACHINE.ZF)
                (fun x1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (undef_flag
                    X86_MACHINE.PF)
                  (fun x2 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (undef_flag
                      X86_MACHINE.AF)
                    (fun x3 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        load
                        seg
                        op1)
                      (fun p1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          load
                          seg
                          (Reg_op
                          r2))
                        (fun p2 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (if pre.op_override
                           then Obj.magic
                                  (load_Z
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    (Big.double
                                    (Big.double
                                    (Big.double
                                    (Big.double
                                    Big.one)))))
                           else Obj.magic
                                  (load_Z
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    (Big.double
                                    (Big.double
                                    (Big.double
                                    (Big.double
                                    (Big.double
                                    Big.one)))))))
                          (fun shiftup ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (cast_u
                                (opsize
                                  pre.op_override
                                  true)
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                (Big.succ
                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                p1))
                            (fun wide_p1 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                  X86_RTL.Coq_shl_op
                                  wide_p1
                                  shiftup))
                              (fun wide_p2 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (opsize
                                      pre.op_override
                                      true)
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    p2))
                                (fun wide_p3 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      X86_RTL.Coq_or_op
                                      wide_p2
                                      wide_p3))
                                  (fun combined ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u
                                        size8
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        count0))
                                    (fun wide_count ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          X86_RTL.Coq_shl_op
                                          combined
                                          wide_count))
                                      (fun shifted ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            X86_RTL.Coq_shru_op
                                            shifted
                                            shiftup))
                                        (fun shifted0 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (cast_u
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              (Big.succ
                                              Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                              (opsize
                                                pre.op_override
                                                true)
                                              shifted0))
                                          (fun newdest0 ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (if pre.op_override
                                             then Obj.magic
                                                    (load_Z
                                                      size8
                                                      (Big.double
                                                      (Big.double
                                                      (Big.double
                                                      (Big.double
                                                      Big.one)))))
                                             else Obj.magic
                                                    (load_Z
                                                      size8
                                                      (Big.double
                                                      (Big.double
                                                      (Big.double
                                                      (Big.double
                                                      (Big.double
                                                      Big.one)))))))
                                            (fun maxcount ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size8
                                                  X86_RTL.Coq_ltu_op
                                                  maxcount
                                                  count0))
                                              (fun guard1 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    size8
                                                    X86_RTL.Coq_eq_op
                                                    maxcount
                                                    count0))
                                                (fun guard2 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (arith
                                                      size1
                                                      X86_RTL.Coq_or_op
                                                      guard1
                                                      guard2))
                                                  (fun guard ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (choose
                                                        (opsize
                                                          pre.op_override
                                                          true)))
                                                    (fun newdest1 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (if_exp
                                                          (opsize
                                                            pre.op_override
                                                            true)
                                                          guard
                                                          newdest1
                                                          newdest0))
                                                      (fun newdest ->
                                                      set0
                                                        seg
                                                        newdest
                                                        op1)))))))))))))))))))))))))
  
  (** val conv_SHRD :
      prefix
      ->
      operand
      ->
      register
      ->
      reg_or_immed
      ->
      unit
      coq_Conv **)
  
  let conv_SHRD pre op1 r2 ri =
    let load =
      load_op
        pre
        true
    in
    let set0 =
      set_op
        pre
        true
    in
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (match ri with
       | Reg_ri r3 ->
         Obj.magic
           (iload_op8
             seg
             (Reg_op
             r3))
       | Imm_ri i ->
         Obj.magic
           (load_int
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             (Big.succ
             Big.zero)))))))
             i))
      (fun count ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size8
            (Big.double
            (Big.double
            (Big.double
            (Big.double
            (Big.double
            Big.one)))))))
        (fun thirtytwo ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              size8
              X86_RTL.Coq_modu_op
              count
              thirtytwo))
          (fun count0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.CF)
            (fun x ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.SF)
              (fun x0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (undef_flag
                  X86_MACHINE.ZF)
                (fun x1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (undef_flag
                    X86_MACHINE.PF)
                  (fun x2 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (undef_flag
                      X86_MACHINE.AF)
                    (fun x3 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        load
                        seg
                        op1)
                      (fun p1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          load
                          seg
                          (Reg_op
                          r2))
                        (fun p2 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (cast_u
                              (opsize
                                pre.op_override
                                true)
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                              p1))
                          (fun wide_p1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (if pre.op_override
                             then Obj.magic
                                    (load_Z
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      Big.one)))))
                             else Obj.magic
                                    (load_Z
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      (Big.double
                                      Big.one)))))))
                            (fun shiftup ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (cast_u
                                  (opsize
                                    pre.op_override
                                    true)
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                  p2))
                              (fun wide_p2 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    X86_RTL.Coq_shl_op
                                    wide_p2
                                    shiftup))
                                (fun wide_p3 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      X86_RTL.Coq_or_op
                                      wide_p1
                                      wide_p3))
                                  (fun combined ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u
                                        size8
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        count0))
                                    (fun wide_count ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          X86_RTL.Coq_shru_op
                                          combined
                                          wide_count))
                                      (fun shifted ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (cast_u
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            (opsize
                                              pre.op_override
                                              true)
                                            shifted))
                                        (fun newdest0 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (if pre.op_override
                                           then Obj.magic
                                                  (load_Z
                                                    size8
                                                    (Big.double
                                                    (Big.double
                                                    (Big.double
                                                    (Big.double
                                                    Big.one)))))
                                           else Obj.magic
                                                  (load_Z
                                                    size8
                                                    (Big.double
                                                    (Big.double
                                                    (Big.double
                                                    (Big.double
                                                    (Big.double
                                                    Big.one)))))))
                                          (fun maxcount ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (test
                                                size8
                                                X86_RTL.Coq_ltu_op
                                                maxcount
                                                count0))
                                            (fun guard1 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  size8
                                                  X86_RTL.Coq_eq_op
                                                  maxcount
                                                  count0))
                                              (fun guard2 ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (arith
                                                    size1
                                                    X86_RTL.Coq_or_op
                                                    guard1
                                                    guard2))
                                                (fun guard ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (choose
                                                      (opsize
                                                        pre.op_override
                                                        true)))
                                                  (fun newdest1 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (if_exp
                                                        (opsize
                                                          pre.op_override
                                                          true)
                                                        guard
                                                        newdest1
                                                        newdest0))
                                                    (fun newdest ->
                                                    set0
                                                      seg
                                                      newdest
                                                      op1))))))))))))))))))))))))
  
  (** val get_AH :
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_AH =
    iload_op8
      DS
      (Reg_op
      ESP)
  
  (** val set_AH :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_AH v =
    iset_op8
      DS
      v
      (Reg_op
      ESP)
  
  (** val get_AL :
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_AL =
    iload_op8
      DS
      (Reg_op
      EAX)
  
  (** val set_AL :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_AL v =
    iset_op8
      DS
      v
      (Reg_op
      EAX)
  
  (** val conv_AAA_AAS :
      X86_RTL.bit_vector_op
      ->
      unit
      coq_Conv **)
  
  let conv_AAA_AAS op1 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size8
          (Big.doubleplusone
          (Big.double
          (Big.double
          Big.one)))))
      (fun pnine ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size8
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            Big.one)))))
        (fun p0Fmask ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (get_flag
              X86_MACHINE.AF))
          (fun paf ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              get_AL)
            (fun pal ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (arith
                  size8
                  X86_RTL.Coq_and_op
                  pal
                  p0Fmask))
              (fun digit1 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (test
                    size8
                    X86_RTL.Coq_lt_op
                    pnine
                    digit1))
                (fun cond1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (arith
                      size1
                      X86_RTL.Coq_or_op
                      cond1
                      paf))
                  (fun cond ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      get_AH)
                    (fun pah ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (load_Z
                          size1
                          Big.zero))
                      (fun pfalse ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (copy_ps
                            size8
                            pah))
                        (fun v_ah0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (copy_ps
                              size1
                              pfalse))
                          (fun v_af0 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (copy_ps
                                size1
                                pfalse))
                            (fun v_cf0 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  size8
                                  X86_RTL.Coq_and_op
                                  pal
                                  p0Fmask))
                              (fun v_al0 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (load_Z
                                    size8
                                    (Big.double
                                    (Big.doubleplusone
                                    Big.one))))
                                (fun psix ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z
                                      size8
                                      Big.one))
                                  (fun pone ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z
                                        size1
                                        Big.one))
                                    (fun ptrue ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          size8
                                          op1
                                          pal
                                          psix))
                                      (fun pal_c ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size8
                                            X86_RTL.Coq_and_op
                                            pal_c
                                            p0Fmask))
                                        (fun pal_cmask ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (if_exp
                                              size8
                                              cond
                                              pal_cmask
                                              v_al0))
                                          (fun v_al ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              get_AH)
                                            (fun pah0 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (arith
                                                  size8
                                                  op1
                                                  pah0
                                                  pone))
                                              (fun pah_c ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (if_exp
                                                    size8
                                                    cond
                                                    pah_c
                                                    v_ah0))
                                                (fun v_ah ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (if_exp
                                                      size1
                                                      cond
                                                      ptrue
                                                      v_af0))
                                                  (fun v_af ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (if_exp
                                                        size1
                                                        cond
                                                        ptrue
                                                        v_cf0))
                                                    (fun v_cf ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (set_AL
                                                        v_al)
                                                      (fun x ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (set_AH
                                                          v_ah)
                                                        (fun x0 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (set_flag
                                                            X86_MACHINE.AF
                                                            v_af)
                                                          (fun x1 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (set_flag
                                                              X86_MACHINE.CF
                                                              v_cf)
                                                            (fun x2 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (undef_flag
                                                                X86_MACHINE.OF)
                                                              (fun x3 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (undef_flag
                                                                  X86_MACHINE.SF)
                                                                (fun x4 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (undef_flag
                                                                    X86_MACHINE.ZF)
                                                                  (fun x5 ->
                                                                  undef_flag
                                                                    X86_MACHINE.PF)))))))))))))))))))))))))))))))
  
  (** val conv_AAD :
      unit
      coq_Conv **)
  
  let conv_AAD =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        get_AL)
      (fun pal ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          get_AH)
        (fun pah ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size8
              (Big.double
              (Big.doubleplusone
              (Big.double
              Big.one)))))
          (fun pten ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (load_Z
                size8
                (Big.doubleplusone
                (Big.doubleplusone
                (Big.doubleplusone
                (Big.doubleplusone
                (Big.doubleplusone
                (Big.doubleplusone
                (Big.doubleplusone
                Big.one)))))))))
            (fun pFF ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (load_Z
                  size8
                  Big.zero))
              (fun pzero ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (arith
                    size8
                    X86_RTL.Coq_mul_op
                    pah
                    pten))
                (fun tensval ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (arith
                      size8
                      X86_RTL.Coq_add_op
                      pal
                      tensval))
                  (fun pal_c ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (arith
                        size8
                        X86_RTL.Coq_and_op
                        pal_c
                        pFF))
                    (fun pal_cmask ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_AL
                        pal_cmask)
                      (fun x ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (set_AH
                          pzero)
                        (fun x0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (test
                              size8
                              X86_RTL.Coq_eq_op
                              pal_cmask
                              pzero))
                          (fun b0 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (set_flag
                              X86_MACHINE.ZF
                              b0)
                            (fun x1 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (test
                                  size8
                                  X86_RTL.Coq_lt_op
                                  pal_cmask
                                  pzero))
                              (fun b1 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (set_flag
                                  X86_MACHINE.SF
                                  b1)
                                (fun x2 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (compute_parity
                                      size8
                                      pal_cmask))
                                  (fun b2 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (set_flag
                                      X86_MACHINE.PF
                                      b2)
                                    (fun x3 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (undef_flag
                                        X86_MACHINE.OF)
                                      (fun x4 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (undef_flag
                                          X86_MACHINE.AF)
                                        (fun x5 ->
                                        undef_flag
                                          X86_MACHINE.CF))))))))))))))))))
  
  (** val conv_AAM :
      unit
      coq_Conv **)
  
  let conv_AAM =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        get_AL)
      (fun pal ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size8
            (Big.double
            (Big.doubleplusone
            (Big.double
            Big.one)))))
        (fun pten ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              size8
              X86_RTL.Coq_divu_op
              pal
              pten))
          (fun digit1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size8
                X86_RTL.Coq_modu_op
                pal
                pten))
            (fun digit2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_AH
                digit1)
              (fun x ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set_AL
                  digit2)
                (fun x0 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (load_Z
                      size8
                      Big.zero))
                  (fun pzero ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (test
                        size8
                        X86_RTL.Coq_eq_op
                        digit2
                        pzero))
                    (fun b0 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_flag
                        X86_MACHINE.ZF
                        b0)
                      (fun x1 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (test
                            size8
                            X86_RTL.Coq_lt_op
                            digit2
                            pzero))
                        (fun b1 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (set_flag
                            X86_MACHINE.SF
                            b1)
                          (fun x2 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (compute_parity
                                size8
                                digit2))
                            (fun b2 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (set_flag
                                X86_MACHINE.PF
                                b2)
                              (fun x3 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (undef_flag
                                  X86_MACHINE.OF)
                                (fun x4 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (undef_flag
                                    X86_MACHINE.AF)
                                  (fun x5 ->
                                  undef_flag
                                    X86_MACHINE.CF)))))))))))))))
  
  (** val testcarryAdd :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let testcarryAdd s p1 p2 p3 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test
        s
        X86_RTL.Coq_ltu_op
        p3
        p1)
      (fun b0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (test
          s
          X86_RTL.Coq_ltu_op
          p3
          p2)
        (fun b1 ->
        arith
          size1
          X86_RTL.Coq_or_op
          b0
          b1))
  
  (** val testcarrySub :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let testcarrySub s p1 p2 p3 =
    test
      s
      X86_RTL.Coq_ltu_op
      p1
      p2
  
  (** val conv_DAA_DAS :
      X86_RTL.bit_vector_op
      ->
      (X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv)
      ->
      unit
      coq_Conv **)
  
  let conv_DAA_DAS op1 tester =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (choose
          size8))
      (fun pal ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_AL
          pal)
        (fun x ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.CF)
          (fun x0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.AF)
            (fun x1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.SF)
              (fun x2 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (undef_flag
                  X86_MACHINE.ZF)
                (fun x3 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (undef_flag
                    X86_MACHINE.PF)
                  (fun x4 ->
                  undef_flag
                    X86_MACHINE.OF)))))))
  
  (** val conv_logical_op :
      bool
      ->
      X86_RTL.bit_vector_op
      ->
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_logical_op do_effect b pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op1)
      (fun p0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          load
          seg
          op2)
        (fun p1 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              (opsize
                pre.op_override
                w)
              b
              p0
              p1))
          (fun p2 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (load_Z
                (opsize
                  pre.op_override
                  w)
                Big.zero))
            (fun zero0 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (test
                  (opsize
                    pre.op_override
                    w)
                  X86_RTL.Coq_eq_op
                  zero0
                  p2))
              (fun zfp ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (test
                    (opsize
                      pre.op_override
                      w)
                    X86_RTL.Coq_lt_op
                    p2
                    zero0))
                (fun sfp ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (compute_parity
                      (opsize
                        pre.op_override
                        w)
                      p2))
                  (fun pfp ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (load_Z
                        size1
                        Big.zero))
                    (fun zero1 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_flag
                        X86_MACHINE.OF
                        zero1)
                      (fun x ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (set_flag
                          X86_MACHINE.CF
                          zero1)
                        (fun x0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (set_flag
                            X86_MACHINE.ZF
                            zfp)
                          (fun x1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (set_flag
                              X86_MACHINE.SF
                              sfp)
                            (fun x2 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (set_flag
                                X86_MACHINE.PF
                                pfp)
                              (fun x3 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (undef_flag
                                  X86_MACHINE.AF)
                                (fun x4 ->
                                if do_effect
                                then set0
                                       seg
                                       p2
                                       op1
                                else return
                                       (Obj.magic
                                         coq_Conv_monad)
                                       ()))))))))))))))
  
  (** val conv_AND :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_AND p w op1 op2 =
    conv_logical_op
      true
      X86_RTL.Coq_and_op
      p
      w
      op1
      op2
  
  (** val conv_OR :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_OR p w op1 op2 =
    conv_logical_op
      true
      X86_RTL.Coq_or_op
      p
      w
      op1
      op2
  
  (** val conv_XOR :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_XOR p w op1 op2 =
    conv_logical_op
      true
      X86_RTL.Coq_xor_op
      p
      w
      op1
      op2
  
  (** val conv_TEST :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_TEST p w op1 op2 =
    conv_logical_op
      false
      X86_RTL.Coq_and_op
      p
      w
      op1
      op2
  
  (** val conv_NOT :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_NOT pre w op =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op)
      (fun p0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            (opsize
              pre.op_override
              w)
            (Word.max_unsigned
              size32)))
        (fun max_unsigned0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              (opsize
                pre.op_override
                w)
              X86_RTL.Coq_xor_op
              p0
              max_unsigned0))
          (fun p1 ->
          set0
            seg
            p1
            op)))
  
  (** val conv_POP :
      prefix
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_POP pre op =
    let seg =
      SS
    in
    let set0 =
      set_op
        pre
        true
        seg
    in
    let loadmem =
      load_mem
        pre
        true
        seg
    in
    let espoffset =
      if pre.op_override
      then (Big.double
             Big.one)
      else (Big.double
             (Big.double
             Big.one))
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_reg
          ESP))
      (fun oldesp ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          loadmem
          oldesp)
        (fun value0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size32
              espoffset))
          (fun offset ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_add_op
                oldesp
                offset))
            (fun newesp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_reg
                newesp
                ESP)
              (fun x ->
              set0
                value0
                op)))))
  
  (** val conv_POPA :
      prefix
      ->
      unit
      coq_Conv **)
  
  let conv_POPA pre =
    let espoffset =
      if pre.op_override
      then (Big.double
             Big.one)
      else (Big.double
             (Big.double
             Big.one))
    in
    let poprtl =
      fun r2 ->
      conv_POP
        pre
        (Reg_op
        r2)
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (poprtl
        EDI)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (poprtl
          ESI)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (poprtl
            EBP)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (load_reg
                ESP))
            (fun oldesp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (load_Z
                  size32
                  espoffset))
              (fun offset ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (arith
                    size32
                    X86_RTL.Coq_add_op
                    oldesp
                    offset))
                (fun newesp ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_reg
                    newesp
                    ESP)
                  (fun x2 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (poprtl
                      EBX)
                    (fun x3 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (poprtl
                        EDX)
                      (fun x4 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (poprtl
                          ECX)
                        (fun x5 ->
                        poprtl
                          EAX))))))))))
  
  (** val conv_PUSH :
      prefix
      ->
      bool
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_PUSH pre w op =
    let seg =
      SS
    in
    let load =
      load_op
        pre
        true
        seg
    in
    let setmem =
      set_mem
        pre
        true
        seg
    in
    let espoffset =
      if pre.op_override
      then (Big.double
             Big.one)
      else (Big.double
             (Big.double
             Big.one))
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        op)
      (fun p0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_reg
            ESP))
        (fun oldesp ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size32
              espoffset))
          (fun offset ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_sub_op
                oldesp
                offset))
            (fun newesp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (setmem
                p0
                newesp)
              (fun x ->
              set_reg
                newesp
                ESP)))))
  
  (** val conv_PUSH_pseudo :
      prefix
      ->
      bool
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let conv_PUSH_pseudo pre w pr =
    let seg =
      SS
    in
    let setmem =
      set_mem
        pre
        w
        seg
    in
    let espoffset =
      if pre.op_override
      then if w
           then (Big.double
                  Big.one)
           else Big.one
      else if w
           then (Big.double
                  (Big.double
                  Big.one))
           else Big.one
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_reg
          ESP))
      (fun oldesp ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size32
            espoffset))
        (fun offset ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              size32
              X86_RTL.Coq_sub_op
              oldesp
              offset))
          (fun newesp ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (setmem
              pr
              newesp)
            (fun x ->
            set_reg
              newesp
              ESP))))
  
  (** val conv_PUSHA :
      prefix
      ->
      unit
      coq_Conv **)
  
  let conv_PUSHA pre =
    let load =
      load_op
        pre
        true
        SS
    in
    let pushrtl =
      fun r2 ->
      conv_PUSH
        pre
        true
        (Reg_op
        r2)
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        (Reg_op
        ESP))
      (fun oldesp ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (pushrtl
          EAX)
        (fun x ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (pushrtl
            ECX)
          (fun x0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (pushrtl
              EDX)
            (fun x1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (pushrtl
                EBX)
              (fun x2 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (conv_PUSH_pseudo
                  pre
                  true
                  oldesp)
                (fun x3 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (pushrtl
                    EBP)
                  (fun x4 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (pushrtl
                      ESI)
                    (fun x5 ->
                    pushrtl
                      EDI))))))))
  
  (** val get_and_place :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      Big.big_int
      ->
      X86_MACHINE.flag
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_and_place t0 dst pos fl =
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_flag
        fl)
      (fun fl0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (load_Z
          t0
          pos)
        (fun pos0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (cast_u
            size1
            t0
            fl0)
          (fun byt ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              t0
              X86_RTL.Coq_shl_op
              byt
              pos0)
            (fun tmp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (arith
                t0
                X86_RTL.Coq_or_op
                dst
                tmp)
              (fun dst0 ->
              return
                (Obj.magic
                  coq_Conv_monad)
                dst0)))))
  
  (** val conv_POP_pseudo :
      prefix
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let conv_POP_pseudo pre =
    let seg =
      SS
    in
    let loadmem =
      load_mem
        pre
        true
        seg
    in
    let espoffset =
      if pre.op_override
      then (Big.double
             Big.one)
      else (Big.double
             (Big.double
             Big.one))
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_reg
        ESP)
      (fun oldesp ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (loadmem
          oldesp)
        (fun value0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (load_Z
            size32
            espoffset)
          (fun offset ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              size32
              X86_RTL.Coq_add_op
              oldesp
              offset)
            (fun newesp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (set_reg
                  newesp
                  ESP))
              (fun x ->
              return
                (Obj.magic
                  coq_Conv_monad)
                value0)))))
  
  (** val extract_and_set :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      Big.big_int
      ->
      X86_MACHINE.flag
      ->
      unit
      coq_Conv **)
  
  let extract_and_set t0 value0 pos fl =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          t0
          Big.one))
      (fun one0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            t0
            pos))
        (fun pos0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              t0
              X86_RTL.Coq_shr_op
              value0
              pos0))
          (fun tmp ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                t0
                X86_RTL.Coq_and_op
                tmp
                one0))
            (fun tmp0 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (test
                  t0
                  X86_RTL.Coq_eq_op
                  one0
                  tmp0))
              (fun b ->
              set_flag
                fl
                b)))))
  
  (** val conv_JMP :
      prefix
      ->
      bool
      ->
      bool
      ->
      operand
      ->
      selector
      option
      ->
      unit
      coq_Conv **)
  
  let conv_JMP pre near absolute op sel =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    if near
    then bind
           (Obj.magic
             coq_Conv_monad)
           (Obj.magic
             (iload_op32
               seg
               op))
           (fun disp ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (if absolute
              then Obj.magic
                     (load_Z
                       size32
                       Big.zero)
              else Obj.magic
                     get_pc)
             (fun base ->
             bind
               (Obj.magic
                 coq_Conv_monad)
               (Obj.magic
                 (arith
                   size32
                   X86_RTL.Coq_add_op
                   base
                   disp))
               (fun newpc ->
               set_pc
                 newpc)))
    else coq_EMIT
           X86_RTL.Coq_error_rtl
  
  (** val conv_Jcc :
      prefix
      ->
      condition_type
      ->
      int32
      ->
      unit
      coq_Conv **)
  
  let conv_Jcc pre ct disp =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (compute_cc
          ct))
      (fun guard ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          get_pc)
        (fun oldpc ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_int
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              (Big.succ
              Big.zero)))))))))))))))))))))))))))))))
              disp))
          (fun pdisp ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_add_op
                oldpc
                pdisp))
            (fun newpc ->
            coq_EMIT
              (X86_RTL.Coq_if_rtl
              (guard,
              (X86_RTL.Coq_set_loc_rtl
              (size32,
              newpc,
              X86_MACHINE.Coq_pc_loc))))))))
  
  (** val conv_CALL :
      prefix
      ->
      bool
      ->
      bool
      ->
      operand
      ->
      selector
      option
      ->
      unit
      coq_Conv **)
  
  let conv_CALL pre near absolute op sel =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        get_pc)
      (fun oldpc ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_reg
            ESP))
        (fun oldesp ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size32
              (Big.double
              (Big.double
              Big.one))))
          (fun four ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_sub_op
                oldesp
                four))
            (fun newesp ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_mem32
                SS
                oldpc
                newesp)
              (fun x ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set_reg
                  newesp
                  ESP)
                (fun x0 ->
                conv_JMP
                  pre
                  near
                  absolute
                  op
                  sel))))))
  
  (** val conv_RET :
      prefix
      ->
      bool
      ->
      int16
      option
      ->
      unit
      coq_Conv **)
  
  let conv_RET pre same_segment disp =
    if same_segment
    then bind
           (Obj.magic
             coq_Conv_monad)
           (Obj.magic
             (load_reg
               ESP))
           (fun oldesp ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (Obj.magic
               (load_mem32
                 SS
                 oldesp))
             (fun value0 ->
             bind
               (Obj.magic
                 coq_Conv_monad)
               (Obj.magic
                 (load_Z
                   size32
                   (Big.double
                   (Big.double
                   Big.one))))
               (fun four ->
               bind
                 (Obj.magic
                   coq_Conv_monad)
                 (Obj.magic
                   (arith
                     size32
                     X86_RTL.Coq_add_op
                     oldesp
                     four))
                 (fun newesp ->
                 bind
                   (Obj.magic
                     coq_Conv_monad)
                   (match disp with
                    | Some imm ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (load_int
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            (Big.succ
                            Big.zero)))))))))))))))
                            imm))
                        (fun imm0 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (cast_u
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              (Big.succ
                              Big.zero)))))))))))))))
                              size32
                              imm0))
                          (fun imm1 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                size32
                                X86_RTL.Coq_add_op
                                newesp
                                imm1))
                            (fun newesp2 ->
                            set_reg
                              newesp2
                              ESP)))
                    | None ->
                      set_reg
                        newesp
                        ESP)
                   (fun x ->
                   set_pc
                     value0)))))
    else coq_EMIT
           X86_RTL.Coq_error_rtl
  
  (** val conv_LEAVE :
      prefix
      ->
      unit
      coq_Conv **)
  
  let conv_LEAVE pre =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_reg
          EBP))
      (fun ebp_val ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_reg
          ebp_val
          ESP)
        (fun x ->
        conv_POP
          pre
          (Reg_op
          EBP)))
  
  (** val conv_LOOP :
      prefix
      ->
      bool
      ->
      bool
      ->
      int8
      ->
      unit
      coq_Conv **)
  
  let conv_LOOP pre flagged testz disp =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          Big.one))
      (fun ptrue ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_reg
            ECX))
        (fun p0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (load_Z
              size32
              Big.one))
          (fun p1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_sub_op
                p0
                p1))
            (fun p2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_reg
                p2
                ECX)
              (fun x ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (load_Z
                    size32
                    Big.zero))
                (fun pzero ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (test
                      size32
                      X86_RTL.Coq_eq_op
                      p2
                      pzero))
                  (fun pcz ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (arith
                        size1
                        X86_RTL.Coq_xor_op
                        pcz
                        ptrue))
                    (fun pcnz ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (get_flag
                          X86_MACHINE.ZF))
                      (fun pzf ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size1
                            X86_RTL.Coq_xor_op
                            pzf
                            ptrue))
                        (fun pnzf ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (if flagged
                           then if testz
                                then Obj.magic
                                       (arith
                                         size1
                                         X86_RTL.Coq_and_op
                                         pzf
                                         pcnz)
                                else Obj.magic
                                       (arith
                                         size1
                                         X86_RTL.Coq_and_op
                                         pnzf
                                         pcnz)
                           else Obj.magic
                                  (arith
                                    size1
                                    X86_RTL.Coq_or_op
                                    pcnz
                                    pcnz))
                          (fun bcond ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              get_pc)
                            (fun eip0 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (load_int
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  (Big.succ
                                  Big.zero)))))))
                                  disp))
                              (fun doffset0 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_s
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    (Big.succ
                                    Big.zero)))))))
                                    size32
                                    doffset0))
                                (fun doffset1 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      size32
                                      X86_RTL.Coq_add_op
                                      eip0
                                      doffset1))
                                  (fun eip1 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (if pre.op_override
                                     then Obj.magic
                                            (load_Z
                                              size32
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              (Big.double
                                              Big.one)))))))))))))))))
                                     else Obj.magic
                                            (load_Z
                                              size32
                                              (Z.opp
                                                Big.one)))
                                    (fun eipmask ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          size32
                                          X86_RTL.Coq_and_op
                                          eip1
                                          eipmask))
                                      (fun eip2 ->
                                      coq_EMIT
                                        (X86_RTL.Coq_if_rtl
                                        (bcond,
                                        (X86_RTL.Coq_set_loc_rtl
                                        (size32,
                                        eip2,
                                        X86_MACHINE.Coq_pc_loc)))))))))))))))))))))
  
  (** val conv_BS_aux :
      Big.big_int
      ->
      bool
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let rec conv_BS_aux s d n op =
    let curr_int =
      if d
      then Word.repr
             s
             (Z.of_nat
               (minus
                 s
                 n))
      else Word.repr
             s
             (Z.of_nat
               n)
    in
    (Big.nat_case
       (fun _ ->
       load_int
         s
         curr_int)
       (fun n' ->
       bind
         (Obj.magic
           coq_Conv_monad)
         (load_int
           s
           curr_int)
         (fun bcount ->
         bind
           (Obj.magic
             coq_Conv_monad)
           (conv_BS_aux
             s
             d
             n'
             op)
           (fun rec0 ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (arith
               s
               X86_RTL.Coq_shru_op
               op
               bcount)
             (fun ps ->
             bind
               (Obj.magic
                 coq_Conv_monad)
               (cast_u
                 s
                 size1
                 ps)
               (fun curr_bit ->
               bind
                 (Obj.magic
                   coq_Conv_monad)
                 (load_int
                   s
                   curr_int)
                 (fun rec1 ->
                 bind
                   (Obj.magic
                     coq_Conv_monad)
                   (if_exp
                     s
                     curr_bit
                     rec1
                     rec0)
                   (fun rec2 ->
                   return
                     (Obj.magic
                       coq_Conv_monad)
                     rec2)))))))
       n)
  
  (** val conv_BS :
      bool
      ->
      prefix
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_BS d pre op1 op2 =
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.AF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.CF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.SF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.OF)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_flag
                X86_MACHINE.PF)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (iload_op32
                    seg
                    op1))
                (fun des ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (iload_op32
                      seg
                      op2))
                  (fun src ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (load_Z
                        size32
                        Big.zero))
                    (fun zero0 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (test
                          size32
                          X86_RTL.Coq_eq_op
                          src
                          zero0))
                      (fun zf ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (set_flag
                          X86_MACHINE.ZF
                          zf)
                        (fun x4 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (conv_BS_aux
                              size32
                              d
                              size32
                              src))
                          (fun res0 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (choose
                                size32))
                            (fun res1 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (if_exp
                                  size32
                                  zf
                                  res1
                                  res0))
                              (fun res ->
                              iset_op32
                                seg
                                res
                                op1)))))))))))))
  
  (** val conv_BSF :
      prefix
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_BSF p op1 op2 =
    conv_BS
      true
      p
      op1
      op2
  
  (** val conv_BSR :
      prefix
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_BSR p op1 op2 =
    conv_BS
      false
      p
      op1
      op2
  
  (** val get_Bit :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_Bit s pb poff =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        s
        Big.one)
      (fun omask ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (arith
          s
          X86_RTL.Coq_shr_op
          pb
          poff)
        (fun shr_pb ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (arith
            s
            X86_RTL.Coq_and_op
            shr_pb
            omask)
          (fun mask_pb ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (cast_u
              s
              size1
              mask_pb)
            (fun tb ->
            return
              (Obj.magic
                coq_Conv_monad)
              tb))))
  
  (** val modify_Bit :
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let modify_Bit s value0 poff bitval =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        s
        Big.one)
      (fun obit ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (arith
          s
          X86_RTL.Coq_shl_op
          obit
          poff)
        (fun one_shifted ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (not
            s
            one_shifted)
          (fun inv_one_shifted ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (cast_u
              size1
              s
              bitval)
            (fun bitvalword ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (arith
                s
                X86_RTL.Coq_shl_op
                bitvalword
                poff)
              (fun bit_shifted ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (arith
                  s
                  X86_RTL.Coq_and_op
                  value0
                  inv_one_shifted)
                (fun newval ->
                arith
                  s
                  X86_RTL.Coq_or_op
                  newval
                  bit_shifted))))))
  
  (** val set_Bit :
      prefix
      ->
      bool
      ->
      operand
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_Bit pre w op poff bitval =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    let load =
      load_op
        pre
        w
        seg
    in
    let set0 =
      set_op
        pre
        w
        seg
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        op)
      (fun value0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (modify_Bit
            (opsize
              pre.op_override
              w)
            value0
            poff
            bitval))
        (fun newvalue ->
        set0
          newvalue
          op))
  
  (** val set_Bit_mem :
      prefix
      ->
      bool
      ->
      operand
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_Bit_mem pre w op addr poff bitval =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    let load =
      load_mem
        pre
        w
        seg
    in
    let set0 =
      set_mem
        pre
        w
        seg
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        addr)
      (fun value0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (modify_Bit
            (opsize
              pre.op_override
              w)
            value0
            poff
            bitval))
        (fun newvalue ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (copy_ps
              size32
              addr))
          (fun newaddr ->
          set0
            newvalue
            newaddr)))
  
  (** val fbit :
      bool
      ->
      bool
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let fbit param1 param2 v =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        size1
        Big.one)
      (fun pone ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (load_Z
          size1
          Big.zero)
        (fun pzero ->
        if param1
        then if param2
             then return
                    (Obj.magic
                      coq_Conv_monad)
                    pone
             else return
                    (Obj.magic
                      coq_Conv_monad)
                    pzero
        else if param2
             then return
                    (Obj.magic
                      coq_Conv_monad)
                    v
             else bind
                    (Obj.magic
                      coq_Conv_monad)
                    (not
                      size1
                      v)
                    (fun v1 ->
                    return
                      (Obj.magic
                        coq_Conv_monad)
                      v1)))
  
  (** val conv_BT :
      bool
      ->
      bool
      ->
      prefix
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_BT param1 param2 pre op1 regimm =
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    let load =
      load_op
        pre
        true
        seg
    in
    let lmem0 =
      load_mem
        pre
        true
        seg
    in
    let opsz =
      opsize
        pre.op_override
        true
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (undef_flag
        X86_MACHINE.OF)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (undef_flag
          X86_MACHINE.SF)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_flag
            X86_MACHINE.AF)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_flag
              X86_MACHINE.PF)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                load
                regimm)
              (fun pi0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (load_Z
                    opsz
                    (Z.add
                      (Z.of_nat
                        opsz)
                      Big.one)))
                (fun popsz ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (match regimm with
                   | Imm_op i ->
                     Obj.magic
                       (arith
                         (opsize
                           pre.op_override
                           true)
                         X86_RTL.Coq_modu_op
                         pi0
                         popsz)
                   | _ ->
                     Obj.magic
                       (copy_ps
                         (opsize
                           pre.op_override
                           true)
                         pi0))
                  (fun rawoffset ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (load_Z
                        size32
                        (Z.div
                          (Z.of_nat
                            (plus
                              opsz
                              (Big.succ
                              Big.zero)))
                          (Big.double
                          (Big.double
                          (Big.double
                          Big.one))))))
                    (fun popsz_bytes ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (load_Z
                          opsz
                          Big.zero))
                      (fun pzero ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (load_Z
                            size32
                            (Big.opp
                            Big.one)))
                        (fun pneg1 ->
                        let btmem =
                          fun psaddr ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (arith
                                (opsize
                                  pre.op_override
                                  true)
                                X86_RTL.Coq_mods_op
                                rawoffset
                                popsz))
                            (fun bitoffset ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (opsize
                                    pre.op_override
                                    true)
                                  X86_RTL.Coq_divs_op
                                  rawoffset
                                  popsz))
                              (fun wordoffset' ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (cast_s
                                    (opsize
                                      pre.op_override
                                      true)
                                    size32
                                    wordoffset'))
                                (fun wordoffset ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (test
                                      (opsize
                                        pre.op_override
                                        true)
                                      X86_RTL.Coq_lt_op
                                      bitoffset
                                      pzero))
                                  (fun isneg ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (copy_ps
                                        (opsize
                                          pre.op_override
                                          true)
                                        bitoffset))
                                    (fun nbitoffset0 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (copy_ps
                                          size32
                                          wordoffset))
                                      (fun nwordoffset0 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            opsz
                                            X86_RTL.Coq_add_op
                                            popsz
                                            bitoffset))
                                        (fun negbitoffset ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (arith
                                              size32
                                              X86_RTL.Coq_add_op
                                              pneg1
                                              wordoffset))
                                          (fun negwordoffset ->
                                          bind
                                            (Obj.magic
                                              coq_Conv_monad)
                                            (Obj.magic
                                              (cast_u
                                                opsz
                                                (opsize
                                                  pre.op_override
                                                  true)
                                                negbitoffset))
                                            (fun nbitoffset1 ->
                                            bind
                                              (Obj.magic
                                                coq_Conv_monad)
                                              (Obj.magic
                                                (if_exp
                                                  (opsize
                                                    pre.op_override
                                                    true)
                                                  isneg
                                                  nbitoffset1
                                                  nbitoffset0))
                                              (fun nbitoffset ->
                                              bind
                                                (Obj.magic
                                                  coq_Conv_monad)
                                                (Obj.magic
                                                  (cast_u
                                                    size32
                                                    size32
                                                    negwordoffset))
                                                (fun nwordoffset1 ->
                                                bind
                                                  (Obj.magic
                                                    coq_Conv_monad)
                                                  (Obj.magic
                                                    (if_exp
                                                      size32
                                                      isneg
                                                      nwordoffset1
                                                      nwordoffset0))
                                                  (fun nwordoffset ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith
                                                        size32
                                                        X86_RTL.Coq_mul_op
                                                        nwordoffset
                                                        popsz_bytes))
                                                    (fun newaddrdelta ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith
                                                          size32
                                                          X86_RTL.Coq_add_op
                                                          newaddrdelta
                                                          psaddr))
                                                      (fun newaddr ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          lmem0
                                                          newaddr)
                                                        (fun value0 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (get_Bit
                                                              (opsize
                                                                pre.op_override
                                                                true)
                                                              value0
                                                              nbitoffset))
                                                          (fun bt ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (set_flag
                                                              X86_MACHINE.CF
                                                              bt)
                                                            (fun x3 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (fbit
                                                                  param1
                                                                  param2
                                                                  bt))
                                                              (fun newbt ->
                                                              set_Bit_mem
                                                                pre
                                                                true
                                                                op1
                                                                newaddr
                                                                nbitoffset
                                                                newbt))))))))))))))))))
                        in
                        (match op1 with
                         | Imm_op i ->
                           coq_EMIT
                             X86_RTL.Coq_error_rtl
                         | Reg_op r2 ->
                           bind
                             (Obj.magic
                               coq_Conv_monad)
                             (Obj.magic
                               load
                               (Reg_op
                               r2))
                             (fun value0 ->
                             bind
                               (Obj.magic
                                 coq_Conv_monad)
                               (Obj.magic
                                 (arith
                                   (opsize
                                     pre.op_override
                                     true)
                                   X86_RTL.Coq_modu_op
                                   rawoffset
                                   popsz))
                               (fun bitoffset ->
                               bind
                                 (Obj.magic
                                   coq_Conv_monad)
                                 (Obj.magic
                                   (get_Bit
                                     (opsize
                                       pre.op_override
                                       true)
                                     value0
                                     bitoffset))
                                 (fun bt ->
                                 bind
                                   (Obj.magic
                                     coq_Conv_monad)
                                   (set_flag
                                     X86_MACHINE.CF
                                     bt)
                                   (fun x3 ->
                                   bind
                                     (Obj.magic
                                       coq_Conv_monad)
                                     (Obj.magic
                                       (fbit
                                         param1
                                         param2
                                         bt))
                                     (fun newbt ->
                                     set_Bit
                                       pre
                                       true
                                       op1
                                       bitoffset
                                       newbt)))))
                         | Address_op a ->
                           bind
                             (Obj.magic
                               coq_Conv_monad)
                             (Obj.magic
                               (compute_addr
                                 a))
                             (fun psaddr ->
                             btmem
                               psaddr)
                         | Offset_op ioff ->
                           bind
                             (Obj.magic
                               coq_Conv_monad)
                             (Obj.magic
                               (load_int
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 (Big.succ
                                 Big.zero)))))))))))))))))))))))))))))))
                                 ioff))
                             (fun psaddr ->
                             btmem
                               psaddr))))))))))))
  
  (** val conv_BSWAP :
      prefix
      ->
      register
      ->
      unit
      coq_Conv **)
  
  let conv_BSWAP pre r2 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size32
          (Big.double
          (Big.double
          (Big.double
          Big.one)))))
      (fun eight ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_reg
            r2))
        (fun ps0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (cast_u
              size32
              size8
              ps0))
          (fun b0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_shru_op
                ps0
                eight))
            (fun ps1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (cast_u
                  size32
                  size8
                  ps1))
              (fun b1 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (cast_u
                    size8
                    size32
                    b1))
                (fun w1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    (arith
                      size32
                      X86_RTL.Coq_shru_op
                      ps1
                      eight))
                  (fun ps2 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (Obj.magic
                      (cast_u
                        size32
                        size8
                        ps2))
                    (fun b2 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (Obj.magic
                        (cast_u
                          size8
                          size32
                          b2))
                      (fun w2 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (Obj.magic
                          (arith
                            size32
                            X86_RTL.Coq_shru_op
                            ps2
                            eight))
                        (fun ps3 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (Obj.magic
                            (cast_u
                              size32
                              size8
                              ps3))
                          (fun b3 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (Obj.magic
                              (cast_u
                                size8
                                size32
                                b3))
                            (fun w3 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (Obj.magic
                                (cast_u
                                  size8
                                  size32
                                  b0))
                              (fun res0 ->
                              bind
                                (Obj.magic
                                  coq_Conv_monad)
                                (Obj.magic
                                  (arith
                                    size32
                                    X86_RTL.Coq_shl_op
                                    res0
                                    eight))
                                (fun res1 ->
                                bind
                                  (Obj.magic
                                    coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      size32
                                      X86_RTL.Coq_add_op
                                      res1
                                      w1))
                                  (fun res2 ->
                                  bind
                                    (Obj.magic
                                      coq_Conv_monad)
                                    (Obj.magic
                                      (arith
                                        size32
                                        X86_RTL.Coq_shl_op
                                        res2
                                        eight))
                                    (fun res3 ->
                                    bind
                                      (Obj.magic
                                        coq_Conv_monad)
                                      (Obj.magic
                                        (arith
                                          size32
                                          X86_RTL.Coq_add_op
                                          res3
                                          w2))
                                      (fun res4 ->
                                      bind
                                        (Obj.magic
                                          coq_Conv_monad)
                                        (Obj.magic
                                          (arith
                                            size32
                                            X86_RTL.Coq_shl_op
                                            res4
                                            eight))
                                        (fun res5 ->
                                        bind
                                          (Obj.magic
                                            coq_Conv_monad)
                                          (Obj.magic
                                            (arith
                                              size32
                                              X86_RTL.Coq_add_op
                                              res5
                                              w3))
                                          (fun res6 ->
                                          set_reg
                                            res6
                                            r2)))))))))))))))))))
  
  (** val conv_CWDE :
      prefix
      ->
      unit
      coq_Conv **)
  
  let conv_CWDE pre =
    let seg =
      get_segment
        pre
        DS
    in
    if pre.op_override
    then bind
           (Obj.magic
             coq_Conv_monad)
           (Obj.magic
             (iload_op8
               seg
               (Reg_op
               EAX)))
           (fun p1 ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (Obj.magic
               (cast_s
                 size8
                 size16
                 p1))
             (fun p2 ->
             iset_op16
               seg
               p2
               (Reg_op
               EAX)))
    else bind
           (Obj.magic
             coq_Conv_monad)
           (Obj.magic
             (iload_op16
               seg
               (Reg_op
               EAX)))
           (fun p1 ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (Obj.magic
               (cast_s
                 size16
                 size32
                 p1))
             (fun p2 ->
             iset_op32
               seg
               p2
               (Reg_op
               EAX)))
  
  (** val conv_CDQ :
      prefix
      ->
      unit
      coq_Conv **)
  
  let conv_CDQ pre =
    let seg =
      get_segment
        pre
        DS
    in
    if pre.op_override
    then bind
           (Obj.magic
             coq_Conv_monad)
           (Obj.magic
             (iload_op16
               seg
               (Reg_op
               EAX)))
           (fun p1 ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (Obj.magic
               (cast_s
                 size16
                 size32
                 p1))
             (fun p2 ->
             bind
               (Obj.magic
                 coq_Conv_monad)
               (Obj.magic
                 (cast_s
                   size32
                   size16
                   p2))
               (fun p2_bottom ->
               bind
                 (Obj.magic
                   coq_Conv_monad)
                 (Obj.magic
                   (load_Z
                     size32
                     (Big.double
                     (Big.double
                     (Big.double
                     (Big.double
                     Big.one))))))
                 (fun sixteen ->
                 bind
                   (Obj.magic
                     coq_Conv_monad)
                   (Obj.magic
                     (arith
                       size32
                       X86_RTL.Coq_shr_op
                       p2
                       sixteen))
                   (fun p2_top0 ->
                   bind
                     (Obj.magic
                       coq_Conv_monad)
                     (Obj.magic
                       (cast_s
                         size32
                         size16
                         p2_top0))
                     (fun p2_top ->
                     bind
                       (Obj.magic
                         coq_Conv_monad)
                       (iset_op16
                         seg
                         p2_bottom
                         (Reg_op
                         EAX))
                       (fun x ->
                       iset_op16
                         seg
                         p2_top
                         (Reg_op
                         EDX))))))))
    else bind
           (Obj.magic
             coq_Conv_monad)
           (Obj.magic
             (iload_op32
               seg
               (Reg_op
               EAX)))
           (fun p1 ->
           bind
             (Obj.magic
               coq_Conv_monad)
             (Obj.magic
               (cast_s
                 size32
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 (Big.succ
                 Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                 p1))
             (fun p2 ->
             bind
               (Obj.magic
                 coq_Conv_monad)
               (Obj.magic
                 (cast_s
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   (Big.succ
                   Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                   size32
                   p2))
               (fun p2_bottom ->
               bind
                 (Obj.magic
                   coq_Conv_monad)
                 (Obj.magic
                   (load_Z
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     (Big.succ
                     Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                     (Big.double
                     (Big.double
                     (Big.double
                     (Big.double
                     (Big.double
                     Big.one)))))))
                 (fun thirtytwo ->
                 bind
                   (Obj.magic
                     coq_Conv_monad)
                   (Obj.magic
                     (arith
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       (Big.succ
                       Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                       X86_RTL.Coq_shr_op
                       p2
                       thirtytwo))
                   (fun p2_top0 ->
                   bind
                     (Obj.magic
                       coq_Conv_monad)
                     (Obj.magic
                       (cast_s
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         (Big.succ
                         Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                         size32
                         p2_top0))
                     (fun p2_top ->
                     bind
                       (Obj.magic
                         coq_Conv_monad)
                       (iset_op32
                         seg
                         p2_bottom
                         (Reg_op
                         EAX))
                       (fun x ->
                       iset_op32
                         seg
                         p2_top
                         (Reg_op
                         EDX))))))))
  
  (** val conv_MOV :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_MOV pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op2)
      (fun res ->
      set0
        seg
        res
        op1)
  
  (** val conv_CMOV :
      prefix
      ->
      bool
      ->
      condition_type
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_CMOV pre w cc op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op1)
      (fun tmp0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          load
          seg
          op2)
        (fun src ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (compute_cc
              cc))
          (fun cc0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (cast_u
                (opsize
                  pre.op_override
                  w)
                (opsize
                  pre.op_override
                  w)
                src))
            (fun tmp1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (if_exp
                  (opsize
                    pre.op_override
                    w)
                  cc0
                  tmp1
                  tmp0))
              (fun tmp ->
              set0
                seg
                tmp
                op1)))))
  
  (** val conv_MOV_extend :
      (Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv)
      ->
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_MOV_extend extend_op pre w op1 op2 =
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    if pre.op_override
    then if w
         then bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (iload_op16
                    seg
                    op2))
                (fun p1 ->
                iset_op16
                  seg
                  p1
                  op1)
         else bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (iload_op8
                    seg
                    op2))
                (fun p1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    extend_op
                    size8
                    size16
                    p1)
                  (fun p2 ->
                  iset_op16
                    seg
                    p2
                    op1))
    else if w
         then bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (iload_op16
                    seg
                    op2))
                (fun p1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    extend_op
                    size16
                    size32
                    p1)
                  (fun p2 ->
                  iset_op32
                    seg
                    p2
                    op1))
         else bind
                (Obj.magic
                  coq_Conv_monad)
                (Obj.magic
                  (iload_op8
                    seg
                    op2))
                (fun p1 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (Obj.magic
                    extend_op
                    size8
                    size32
                    p1)
                  (fun p2 ->
                  iset_op32
                    seg
                    p2
                    op1))
  
  (** val conv_MOVZX :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_MOVZX pre w op1 op2 =
    conv_MOV_extend
      cast_u
      pre
      w
      op1
      op2
  
  (** val conv_MOVSX :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_MOVSX pre w op1 op2 =
    conv_MOV_extend
      cast_s
      pre
      w
      op1
      op2
  
  (** val conv_XCHG :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_XCHG pre w op1 op2 =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg =
      get_segment_op2
        pre
        DS
        op1
        op2
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg
        op1)
      (fun p1 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          load
          seg
          op2)
        (fun p2 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (set0
            seg
            p2
            op1)
          (fun x ->
          set0
            seg
            p1
            op2)))
  
  (** val conv_XADD :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_XADD pre w op1 op2 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (conv_XCHG
        pre
        w
        op1
        op2)
      (fun x ->
      conv_ADD
        pre
        w
        op1
        op2)
  
  (** val conv_CMPXCHG :
      prefix
      ->
      bool
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_CMPXCHG pre w op1 op2 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (conv_CMP
        pre
        w
        (Reg_op
        EAX)
        op1)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (conv_CMOV
          pre
          w
          E_ct
          op1
          op2)
        (fun x0 ->
        conv_CMOV
          pre
          w
          NE_ct
          (Reg_op
          EAX)
          op1))
  
  (** val string_op_reg_shift :
      register
      ->
      prefix
      ->
      bool
      ->
      unit
      coq_Conv **)
  
  let string_op_reg_shift reg0 pre w =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size32
          (if pre.op_override
           then if w
                then (Big.double
                       Big.one)
                else Big.one
           else if w
                then (Big.double
                       (Big.double
                       Big.one))
                else Big.one)))
      (fun offset ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (get_flag
            X86_MACHINE.DF))
        (fun df ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (iload_op32
              DS
              (Reg_op
              reg0)))
          (fun old_reg ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (Obj.magic
              (arith
                size32
                X86_RTL.Coq_add_op
                old_reg
                offset))
            (fun new_reg1 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (arith
                  size32
                  X86_RTL.Coq_sub_op
                  old_reg
                  offset))
              (fun new_reg2 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (coq_EMIT
                  (X86_RTL.Coq_set_loc_rtl
                  (size32,
                  new_reg1,
                  (X86_MACHINE.Coq_reg_loc
                  reg0))))
                (fun x ->
                coq_EMIT
                  (X86_RTL.Coq_if_rtl
                  (df,
                  (X86_RTL.Coq_set_loc_rtl
                  (size32,
                  new_reg2,
                  (X86_MACHINE.Coq_reg_loc
                  reg0)))))))))))
  
  (** val conv_MOVS :
      prefix
      ->
      bool
      ->
      unit
      coq_Conv **)
  
  let conv_MOVS pre w =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    let seg_load =
      get_segment
        pre
        DS
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        seg_load
        (Address_op
        { addrDisp =
        (Word.zero
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          (Big.succ
          Big.zero))))))))))))))))))))))))))))))));
        addrBase =
        (Some
        ESI);
        addrIndex =
        None }))
      (fun p1 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set0
          ES
          p1
          (Address_op
          { addrDisp =
          (Word.zero
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero))))))))))))))))))))))))))))))));
          addrBase =
          (Some
          EDI);
          addrIndex =
          None }))
        (fun x ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (string_op_reg_shift
            EDI
            pre
            w)
          (fun x0 ->
          string_op_reg_shift
            ESI
            pre
            w)))
  
  (** val conv_STOS :
      prefix
      ->
      bool
      ->
      unit
      coq_Conv **)
  
  let conv_STOS pre w =
    let load =
      load_op
        pre
        w
    in
    let set0 =
      set_op
        pre
        w
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        load
        DS
        (Reg_op
        EAX))
      (fun p1 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set0
          ES
          p1
          (Address_op
          { addrDisp =
          (Word.zero
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            (Big.succ
            Big.zero))))))))))))))))))))))))))))))));
          addrBase =
          (Some
          EDI);
          addrIndex =
          None }))
        (fun x ->
        string_op_reg_shift
          EDI
          pre
          w))
  
  (** val conv_CMPS :
      prefix
      ->
      bool
      ->
      unit
      coq_Conv **)
  
  let conv_CMPS pre w =
    let seg1 =
      get_segment
        pre
        DS
    in
    let op1 =
      Address_op
      { addrDisp =
      (Word.zero
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero))))))))))))))))))))))))))))))));
      addrBase =
      (Some
      ESI);
      addrIndex =
      None }
    in
    let op2 =
      Address_op
      { addrDisp =
      (Word.zero
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        (Big.succ
        Big.zero))))))))))))))))))))))))))))))));
      addrBase =
      (Some
      EDI);
      addrIndex =
      None }
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (conv_SUB_CMP_generic
        false
        pre
        w
        op1
        op2
        op2
        seg1
        seg1
        ES)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (string_op_reg_shift
          EDI
          pre
          w)
        (fun x0 ->
        string_op_reg_shift
          ESI
          pre
          w))
  
  (** val conv_LEA :
      prefix
      ->
      operand
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_LEA pre op1 op2 =
    let seg =
      get_segment_op
        pre
        DS
        op1
    in
    (match op2 with
     | Address_op a ->
       bind
         (Obj.magic
           coq_Conv_monad)
         (Obj.magic
           (compute_addr
             a))
         (fun r2 ->
         iset_op32
           seg
           r2
           op1)
     | _ ->
       coq_EMIT
         X86_RTL.Coq_error_rtl)
  
  (** val conv_HLT :
      prefix
      ->
      unit
      coq_Conv **)
  
  let conv_HLT pre =
    coq_EMIT
      X86_RTL.Coq_trap_rtl
  
  (** val conv_SETcc :
      prefix
      ->
      condition_type
      ->
      operand
      ->
      unit
      coq_Conv **)
  
  let conv_SETcc pre ct op =
    let seg =
      get_segment_op
        pre
        DS
        op
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (compute_cc
          ct))
      (fun ccval ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (cast_u
            size1
            size8
            ccval))
        (fun ccext ->
        iset_op8
          seg
          ccext
          op))
  
  (** val check_prefix :
      prefix
      ->
      unit
      coq_Conv **)
  
  let check_prefix p =
    if p.addr_override
    then coq_EMIT
           X86_RTL.Coq_error_rtl
    else return
           (Obj.magic
             coq_Conv_monad)
           ()
  
  (** val int_to_bin32 :
      Word.int
      ->
      binary32 **)
  
  let int_to_bin32 i =
    b32_of_bits
      (Word.intval
        size32
        i)
  
  (** val bin32_to_int :
      binary32
      ->
      Word.int **)
  
  let bin32_to_int b =
    Word.repr
      size32
      (bits_of_b32
        b)
  
  (** val int_to_bin64 :
      Word.int
      ->
      binary64 **)
  
  let int_to_bin64 i =
    b64_of_bits
      (Word.intval
        size64
        i)
  
  (** val bin64_to_int :
      binary64
      ->
      Word.int **)
  
  let bin64_to_int b =
    Word.repr
      size64
      (bits_of_b64
        b)
  
  (** val int_to_de_float :
      Word.int
      ->
      de_float **)
  
  let int_to_de_float i =
    de_float_of_bits
      (Word.intval
        size80
        i)
  
  (** val de_float_to_int :
      de_float
      ->
      Word.int **)
  
  let de_float_to_int b =
    Word.repr
      size80
      (bits_of_de_float
        b)
  
  (** val string_to_de_float :
      char list
      ->
      de_float **)
  
  let string_to_de_float s =
    let intval0 =
      Word.string_to_int
        size80
        s
    in
    int_to_de_float
      intval0
  
  (** val s2bf :
      char list
      ->
      de_float **)
  
  let s2bf s =
    string_to_de_float
      s
  
  (** val s2int80 :
      char list
      ->
      int0 **)
  
  let s2int80 s =
    Word.string_to_int
      size80
      s
  
  (** val integer_to_de_float :
      Word.int
      ->
      de_float **)
  
  let integer_to_de_float i =
    let bin =
      int_to_de_float
        i
    in
    (match bin with
     | B754_finite (s,
                    m,
                    e) ->
       let mant_val =
         Word.intval
           size80
           i
       in
       let (rec0,
            shifted_m) =
         shr0
           { shr_m =
           mant_val;
           shr_r =
           false;
           shr_s =
           false }
           mant_val
           Big.one
       in
       let exp_val =
         Z.of_nat
           size80
       in
       let joined =
         join_bits
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           Big.one))))))
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           (Big.double
           Big.one))))))))))))))
           s
           (Z.sub
             shifted_m
             Big.one)
           exp_val
       in
       de_float_of_bits
         joined
     | x ->
       x)
  
  (** val enc_rounding_mode :
      X86_RTL.rounding_mode
      ->
      Big.big_int **)
  
  let enc_rounding_mode = function
  | Mode_ZR ->
    (Big.doubleplusone
      Big.one)
  | Mode_DN ->
    Big.one
  | Mode_UP ->
    (Big.double
      Big.one)
  | _ ->
    Big.zero
  
  type fpu_precision_control =
  | PC_single
  | PC_reserved
  | PC_double
  | PC_double_extended
  
  (** val fpu_precision_control_rect :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      fpu_precision_control
      ->
      'a1 **)
  
  let fpu_precision_control_rect f f0 f1 f2 = function
  | PC_single ->
    f
  | PC_reserved ->
    f0
  | PC_double ->
    f1
  | PC_double_extended ->
    f2
  
  (** val fpu_precision_control_rec :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      fpu_precision_control
      ->
      'a1 **)
  
  let fpu_precision_control_rec f f0 f1 f2 = function
  | PC_single ->
    f
  | PC_reserved ->
    f0
  | PC_double ->
    f1
  | PC_double_extended ->
    f2
  
  (** val enc_fpu_precision_control :
      fpu_precision_control
      ->
      Big.big_int **)
  
  let enc_fpu_precision_control = function
  | PC_single ->
    Big.zero
  | PC_reserved ->
    Big.one
  | PC_double ->
    (Big.double
      Big.one)
  | PC_double_extended ->
    (Big.doubleplusone
      Big.one)
  
  type fpu_tag_mode =
  | TM_valid
  | TM_zero
  | TM_special
  | TM_empty
  
  (** val fpu_tag_mode_rect :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      fpu_tag_mode
      ->
      'a1 **)
  
  let fpu_tag_mode_rect f f0 f1 f2 = function
  | TM_valid ->
    f
  | TM_zero ->
    f0
  | TM_special ->
    f1
  | TM_empty ->
    f2
  
  (** val fpu_tag_mode_rec :
      'a1
      ->
      'a1
      ->
      'a1
      ->
      'a1
      ->
      fpu_tag_mode
      ->
      'a1 **)
  
  let fpu_tag_mode_rec f f0 f1 f2 = function
  | TM_valid ->
    f
  | TM_zero ->
    f0
  | TM_special ->
    f1
  | TM_empty ->
    f2
  
  (** val enc_fpu_tag_mode :
      fpu_tag_mode
      ->
      Big.big_int **)
  
  let enc_fpu_tag_mode = function
  | TM_valid ->
    Big.zero
  | TM_zero ->
    Big.one
  | TM_special ->
    (Big.double
      Big.one)
  | TM_empty ->
    (Big.doubleplusone
      Big.one)
  
  (** val get_stktop :
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_stktop =
    return
      (Obj.magic
        coq_Conv_monad)
      (X86_RTL.Coq_get_loc_rtl_exp
      (size3,
      X86_MACHINE.Coq_fpu_stktop_loc))
  
  (** val get_fpu_rctrl :
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_fpu_rctrl =
    return
      (Obj.magic
        coq_Conv_monad)
      (X86_RTL.Coq_get_loc_rtl_exp
      (size2,
      X86_MACHINE.Coq_fpu_rctrl_loc))
  
  (** val get_fpu_reg :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_fpu_reg i =
    return
      (Obj.magic
        coq_Conv_monad)
      (X86_RTL.Coq_get_array_rtl_exp
      (size3,
      size80,
      X86_MACHINE.Coq_fpu_datareg,
      i))
  
  (** val get_fpu_tag :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_fpu_tag i =
    return
      (Obj.magic
        coq_Conv_monad)
      (X86_RTL.Coq_get_array_rtl_exp
      (size3,
      size2,
      X86_MACHINE.Coq_fpu_tag,
      i))
  
  (** val set_stktop :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_stktop t0 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (size3,
      t0,
      X86_MACHINE.Coq_fpu_stktop_loc))
  
  (** val set_stktop_const :
      Big.big_int
      ->
      unit
      coq_Conv **)
  
  let set_stktop_const t0 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size3
          t0))
      (fun r2 ->
      set_stktop
        r2)
  
  (** val set_fpu_flag :
      X86_MACHINE.fpu_flag
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_flag fl r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (size1,
      r2,
      (X86_MACHINE.Coq_fpu_flag_loc
      fl)))
  
  (** val set_fpu_flag_const :
      X86_MACHINE.fpu_flag
      ->
      Big.big_int
      ->
      unit
      coq_Conv **)
  
  let set_fpu_flag_const fl bit0 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          bit0))
      (fun r2 ->
      set_fpu_flag
        fl
        r2)
  
  (** val set_fpu_ctrl :
      X86_MACHINE.fpu_ctrl_flag
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_ctrl cf r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (size1,
      r2,
      (X86_MACHINE.Coq_fpu_ctrl_flag_loc
      cf)))
  
  (** val set_fpu_ctrl_const :
      X86_MACHINE.fpu_ctrl_flag
      ->
      Big.big_int
      ->
      unit
      coq_Conv **)
  
  let set_fpu_ctrl_const cf bit0 =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size1
          bit0))
      (fun r2 ->
      set_fpu_ctrl
        cf
        r2)
  
  (** val set_fpu_rctrl :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_rctrl r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (size2,
      r2,
      X86_MACHINE.Coq_fpu_rctrl_loc))
  
  (** val set_fpu_rctrl_const :
      mode
      ->
      unit
      coq_Conv **)
  
  let set_fpu_rctrl_const rm =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size2
          (enc_rounding_mode
            rm)))
      (fun r2 ->
      set_fpu_rctrl
        r2)
  
  (** val set_fpu_pctrl :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_pctrl r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (size2,
      r2,
      X86_MACHINE.Coq_fpu_pctrl_loc))
  
  (** val set_fpu_pctrl_const :
      fpu_precision_control
      ->
      unit
      coq_Conv **)
  
  let set_fpu_pctrl_const pc =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size2
          (enc_fpu_precision_control
            pc)))
      (fun r2 ->
      set_fpu_pctrl
        r2)
  
  (** val set_fpu_lastInstrPtr :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_lastInstrPtr r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (X86_MACHINE.size48,
      r2,
      X86_MACHINE.Coq_fpu_lastInstrPtr_loc))
  
  (** val set_fpu_lastInstrPtr_const :
      Big.big_int
      ->
      unit
      coq_Conv **)
  
  let set_fpu_lastInstrPtr_const v =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          X86_MACHINE.size48
          v))
      (fun r2 ->
      set_fpu_lastInstrPtr
        r2)
  
  (** val set_fpu_lastDataPtr :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_lastDataPtr r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (X86_MACHINE.size48,
      r2,
      X86_MACHINE.Coq_fpu_lastDataPtr_loc))
  
  (** val set_fpu_lastDataPtr_const :
      Big.big_int
      ->
      unit
      coq_Conv **)
  
  let set_fpu_lastDataPtr_const v =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          X86_MACHINE.size48
          v))
      (fun r2 ->
      set_fpu_lastDataPtr
        r2)
  
  (** val set_fpu_lastOpcode :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_lastOpcode r2 =
    coq_EMIT
      (X86_RTL.Coq_set_loc_rtl
      (X86_MACHINE.size11,
      r2,
      X86_MACHINE.Coq_fpu_lastOpcode_loc))
  
  (** val set_fpu_lastOpcode_const :
      Big.big_int
      ->
      unit
      coq_Conv **)
  
  let set_fpu_lastOpcode_const v =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          X86_MACHINE.size11
          v))
      (fun r2 ->
      set_fpu_lastOpcode
        r2)
  
  (** val set_fpu_reg :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_reg i v =
    coq_EMIT
      (X86_RTL.Coq_set_array_rtl
      (size3,
      size80,
      X86_MACHINE.Coq_fpu_datareg,
      i,
      v))
  
  (** val set_fpu_tag :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let set_fpu_tag i v =
    coq_EMIT
      (X86_RTL.Coq_set_array_rtl
      (size3,
      size2,
      X86_MACHINE.Coq_fpu_tag,
      i,
      v))
  
  (** val set_fpu_tag_const :
      Big.big_int
      ->
      fpu_tag_mode
      ->
      unit
      coq_Conv **)
  
  let set_fpu_tag_const loc0 tm =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_Z
          size3
          loc0))
      (fun i ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size2
            (enc_fpu_tag_mode
              tm)))
        (fun v ->
        set_fpu_tag
          i
          v))
  
  (** val inc_stktop :
      unit
      coq_Conv **)
  
  let inc_stktop =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        get_stktop)
      (fun st ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size3
            Big.one))
        (fun one0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              size3
              X86_RTL.Coq_add_op
              st
              one0))
          (fun newst ->
          set_stktop
            newst)))
  
  (** val dec_stktop :
      unit
      coq_Conv **)
  
  let dec_stktop =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        get_stktop)
      (fun st ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (load_Z
            size3
            Big.one))
        (fun one0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (arith
              size3
              X86_RTL.Coq_sub_op
              st
              one0))
          (fun newst ->
          set_stktop
            newst)))
  
  (** val stk_push :
      X86_RTL.rtl_exp
      ->
      unit
      coq_Conv **)
  
  let stk_push f =
    bind
      (Obj.magic
        coq_Conv_monad)
      dec_stktop
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          get_stktop)
        (fun topp ->
        set_fpu_reg
          topp
          f))
  
  (** val freg_of_offset :
      int3
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let freg_of_offset offset =
    bind
      (Obj.magic
        coq_Conv_monad)
      get_stktop
      (fun topp ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (load_Z
          size3
          (Word.unsigned
            (Big.succ
            (Big.succ
            Big.zero))
            offset))
        (fun ri ->
        arith
          size3
          X86_RTL.Coq_add_op
          topp
          ri))
  
  (** val undef_fpu_flag :
      X86_MACHINE.fpu_flag
      ->
      unit
      coq_Conv **)
  
  let undef_fpu_flag f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (choose
          size1))
      (fun v ->
      set_fpu_flag
        f
        v)
  
  (** val is_empty_tag :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let is_empty_tag i =
    bind
      (Obj.magic
        coq_Conv_monad)
      (get_fpu_tag
        i)
      (fun tag ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (load_Z
          size2
          (Big.doubleplusone
          Big.one))
        (fun empty_tag ->
        test
          size2
          X86_RTL.Coq_eq_op
          tag
          empty_tag))
  
  (** val is_nonempty_tag :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let is_nonempty_tag i =
    bind
      (Obj.magic
        coq_Conv_monad)
      (is_empty_tag
        i)
      (fun isempty ->
      not
        size1
        isempty)
  
  (** val test_pos_zero :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_pos_zero ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        Big.zero)
      (fun poszero ->
      test
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        X86_RTL.Coq_eq_op
        f
        poszero)
  
  (** val test_neg_zero :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_neg_zero ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        (two_power_nat
          (plus
            (Coq_Pos.to_nat
              mw)
            (Coq_Pos.to_nat
              ew))))
      (fun negzero ->
      test
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        X86_RTL.Coq_eq_op
        f
        negzero)
  
  (** val test_zero :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_zero ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test_pos_zero
        ew
        mw
        f)
      (fun isposzero ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (test_neg_zero
          ew
          mw
          f)
        (fun isnegzero ->
        arith
          size1
          X86_RTL.Coq_or_op
          isposzero
          isnegzero))
  
  (** val test_pos_inf :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_pos_inf ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        (Z.mul
          (two_power_nat
            (Coq_Pos.to_nat
              mw))
          (Z.sub
            (two_power_nat
              (Coq_Pos.to_nat
                ew))
            Big.one)))
      (fun posinf ->
      test
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        X86_RTL.Coq_eq_op
        f
        posinf)
  
  (** val test_neg_inf :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_neg_inf ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        (Z.mul
          (two_power_nat
            (Coq_Pos.to_nat
              mw))
          (Z.sub
            (two_power_nat
              (plus
                (Coq_Pos.to_nat
                  ew)
                (Big.succ
                Big.zero)))
            Big.one)))
      (fun neginf ->
      test
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        X86_RTL.Coq_eq_op
        f
        neginf)
  
  (** val test_inf :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_inf ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test_pos_inf
        ew
        mw
        f)
      (fun isposinf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (test_neg_inf
          ew
          mw
          f)
        (fun isneginf ->
        arith
          size1
          X86_RTL.Coq_or_op
          isposinf
          isneginf))
  
  (** val test_qnan :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_qnan ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        (Z.mul
          (two_power_nat
            (minus
              (Coq_Pos.to_nat
                mw)
              (Big.succ
              Big.zero)))
          (Z.sub
            (two_power_nat
              (plus
                (Coq_Pos.to_nat
                  ew)
                (Big.succ
                Big.zero)))
            Big.one)))
      (fun mask0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (arith
          (plus
            (Coq_Pos.to_nat
              ew)
            (Coq_Pos.to_nat
              mw))
          X86_RTL.Coq_and_op
          f
          mask0)
        (fun maskRes ->
        test
          (plus
            (Coq_Pos.to_nat
              ew)
            (Coq_Pos.to_nat
              mw))
          X86_RTL.Coq_eq_op
          maskRes
          mask0))
  
  (** val test_snan :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_snan ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test_inf
        ew
        mw
        f)
      (fun isinf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (not
          size1
          isinf)
        (fun isnotinf ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (load_Z
            (plus
              (Coq_Pos.to_nat
                ew)
              (Coq_Pos.to_nat
                mw))
            (Z.mul
              (two_power_nat
                (minus
                  (Coq_Pos.to_nat
                    mw)
                  (Big.succ
                  Big.zero)))
              (Z.sub
                (two_power_nat
                  (plus
                    (Coq_Pos.to_nat
                      ew)
                    (Big.succ
                    Big.zero)))
                Big.one)))
          (fun mask0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              (plus
                (Coq_Pos.to_nat
                  ew)
                (Coq_Pos.to_nat
                  mw))
              X86_RTL.Coq_and_op
              f
              mask0)
            (fun maskRes ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (load_Z
                (plus
                  (Coq_Pos.to_nat
                    ew)
                  (Coq_Pos.to_nat
                    mw))
                (Z.mul
                  (two_power_nat
                    (Coq_Pos.to_nat
                      mw))
                  (Z.sub
                    (two_power_nat
                      (Coq_Pos.to_nat
                        ew))
                    Big.one)))
              (fun expected ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (test
                  (plus
                    (Coq_Pos.to_nat
                      ew)
                    (Coq_Pos.to_nat
                      mw))
                  X86_RTL.Coq_eq_op
                  maskRes
                  expected)
                (fun is_snan ->
                arith
                  size1
                  X86_RTL.Coq_and_op
                  isnotinf
                  is_snan))))))
  
  (** val test_nan :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_nan ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test_qnan
        ew
        mw
        f)
      (fun isqnan ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (test_snan
          ew
          mw
          f)
        (fun issnan ->
        arith
          size1
          X86_RTL.Coq_or_op
          isqnan
          issnan))
  
  (** val test_denormal :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_denormal ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test_zero
        ew
        mw
        f)
      (fun iszero ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (not
          size1
          iszero)
        (fun isnotzero ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (load_Z
            (plus
              (Coq_Pos.to_nat
                ew)
              (Coq_Pos.to_nat
                mw))
            (Z.mul
              (two_power_nat
                (Coq_Pos.to_nat
                  mw))
              (Z.sub
                (two_power_nat
                  (Coq_Pos.to_nat
                    ew))
                Big.one)))
          (fun mask0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (arith
              (plus
                (Coq_Pos.to_nat
                  ew)
                (Coq_Pos.to_nat
                  mw))
              X86_RTL.Coq_and_op
              f
              mask0)
            (fun maskRes ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (load_Z
                (plus
                  (Coq_Pos.to_nat
                    ew)
                  (Coq_Pos.to_nat
                    mw))
                Big.zero)
              (fun zero0 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (test
                  (plus
                    (Coq_Pos.to_nat
                      ew)
                    (Coq_Pos.to_nat
                      mw))
                  X86_RTL.Coq_eq_op
                  maskRes
                  zero0)
                (fun expZero ->
                arith
                  size1
                  X86_RTL.Coq_and_op
                  isnotzero
                  expZero))))))
  
  (** val test_normal_fin :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_normal_fin ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (load_Z
        (plus
          (Coq_Pos.to_nat
            ew)
          (Coq_Pos.to_nat
            mw))
        (Z.mul
          (two_power_nat
            (Coq_Pos.to_nat
              mw))
          (Z.sub
            (two_power_nat
              (Coq_Pos.to_nat
                ew))
            Big.one)))
      (fun mask0 ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (arith
          (plus
            (Coq_Pos.to_nat
              ew)
            (Coq_Pos.to_nat
              mw))
          X86_RTL.Coq_and_op
          f
          mask0)
        (fun maskRes ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (load_Z
            (plus
              (Coq_Pos.to_nat
                ew)
              (Coq_Pos.to_nat
                mw))
            Big.zero)
          (fun zero0 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (test
              (plus
                (Coq_Pos.to_nat
                  ew)
                (Coq_Pos.to_nat
                  mw))
              X86_RTL.Coq_eq_op
              maskRes
              zero0)
            (fun iszero ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (not
                size1
                iszero)
              (fun notzero ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (test
                  (plus
                    (Coq_Pos.to_nat
                      ew)
                    (Coq_Pos.to_nat
                      mw))
                  X86_RTL.Coq_eq_op
                  maskRes
                  mask0)
                (fun maxexpo ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (not
                    size1
                    maxexpo)
                  (fun notmaxexpo ->
                  arith
                    size1
                    X86_RTL.Coq_and_op
                    notzero
                    notmaxexpo)))))))
  
  (** val test_fin :
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_fin ew mw f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (test_denormal
        ew
        mw
        f)
      (fun isdefin ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (test_normal_fin
          ew
          mw
          f)
        (fun isnorfin ->
        arith
          size1
          X86_RTL.Coq_or_op
          isdefin
          isnorfin))
  
  (** val size63 :
      Big.big_int **)
  
  let size63 =
    Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      (Big.succ
      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  
  (** val de_float_of_float79 :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let de_float_of_float79 f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (first_bits
        size16
        size79
        f)
      (fun signAndExpo ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (last_bits
          size63
          size79
          f)
        (fun mantissa ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (test_inf
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            Big.one)))))
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            Big.one)))
            f)
          (fun isInf ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (test_normal_fin
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              Big.one)))))
              (Big.doubleplusone
              (Big.doubleplusone
              (Big.doubleplusone
              Big.one)))
              f)
            (fun isNorFin ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (arith
                size1
                X86_RTL.Coq_or_op
                isInf
                isNorFin)
              (fun intSig ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (concat_bits
                  size1
                  size63
                  intSig
                  mantissa)
                (fun r2 ->
                concat_bits
                  size16
                  (plus
                    (plus
                      size1
                      size63)
                    (Big.succ
                    Big.zero))
                  signAndExpo
                  r2))))))
  
  (** val float79_of_de_float :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let float79_of_de_float f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (first_bits
        size16
        size80
        f)
      (fun signAndExpo ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (last_bits
          size63
          size80
          f)
        (fun mantissa ->
        concat_bits
          size16
          size63
          signAndExpo
          mantissa))
  
  (** val fcast :
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      Big.big_int
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let fcast ew1 mw1 ew2 mw2 rm e =
    return
      (Obj.magic
        coq_Conv_monad)
      (X86_RTL.Coq_fcast_rtl_exp
      (ew1,
      mw1,
      ew2,
      mw2,
      rm,
      e))
  
  (** val de_float_of_float32 :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let de_float_of_float32 f rm =
    bind
      (Obj.magic
        coq_Conv_monad)
      (fcast
        (Big.double
        (Big.double
        (Big.double
        Big.one)))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.double
        Big.one))))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))))
        rm
        f)
      (fun f' ->
      de_float_of_float79
        f')
  
  (** val de_float_of_float64 :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let de_float_of_float64 f rm =
    bind
      (Obj.magic
        coq_Conv_monad)
      (fcast
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.double
        Big.one)))
        (Big.double
        (Big.double
        (Big.doubleplusone
        (Big.double
        (Big.doubleplusone
        Big.one)))))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))))
        rm
        f)
      (fun f' ->
      de_float_of_float79
        f')
  
  (** val float32_of_de_float :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let float32_of_de_float f rm =
    bind
      (Obj.magic
        coq_Conv_monad)
      (float79_of_de_float
        f)
      (fun f' ->
      fcast
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))))
        (Big.double
        (Big.double
        (Big.double
        Big.one)))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.double
        Big.one))))
        rm
        f')
  
  (** val float64_of_de_float :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let float64_of_de_float f rm =
    bind
      (Obj.magic
        coq_Conv_monad)
      (float79_of_de_float
        f)
      (fun f' ->
      fcast
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.doubleplusone
        Big.one)))))
        (Big.doubleplusone
        (Big.doubleplusone
        (Big.double
        Big.one)))
        (Big.double
        (Big.double
        (Big.doubleplusone
        (Big.double
        (Big.doubleplusone
        Big.one)))))
        rm
        f')
  
  (** val enc_tag :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let enc_tag f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (float79_of_de_float
        f)
      (fun nf ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (test_zero
          (Big.doubleplusone
          (Big.doubleplusone
          (Big.doubleplusone
          Big.one)))
          (Big.doubleplusone
          (Big.doubleplusone
          (Big.doubleplusone
          (Big.doubleplusone
          (Big.doubleplusone
          Big.one)))))
          nf)
        (fun iszero ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (test_normal_fin
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            Big.one)))
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            (Big.doubleplusone
            Big.one)))))
            nf)
          (fun isnorfin ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (load_Z
              size2
              (enc_fpu_tag_mode
                TM_valid))
            (fun enc_valid ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (load_Z
                size2
                (enc_fpu_tag_mode
                  TM_zero))
              (fun enc_zero ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (load_Z
                  size2
                  (enc_fpu_tag_mode
                    TM_special))
                (fun enc_special ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (if_exp
                    size2
                    iszero
                    enc_zero
                    enc_special)
                  (fun z_or_s ->
                  if_exp
                    size2
                    isnorfin
                    enc_valid
                    z_or_s)))))))
  
  (** val load_fp_op :
      prefix
      ->
      segment_register
      ->
      fp_operand
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let load_fp_op pre seg op =
    let sr =
      get_segment
        pre
        seg
    in
    bind
      (Obj.magic
        coq_Conv_monad)
      get_fpu_rctrl
      (fun rm ->
      match op with
      | FPS_op i ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (freg_of_offset
            i)
          (fun fi ->
          get_fpu_reg
            fi)
      | FPM16_op a ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (Obj.magic
            (coq_EMIT
              X86_RTL.Coq_error_rtl))
          (fun x ->
          choose
            size80)
      | FPM32_op a ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (compute_addr
            a)
          (fun addr ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (load_mem32
              sr
              addr)
            (fun val0 ->
            de_float_of_float32
              val0
              rm))
      | FPM64_op a ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (compute_addr
            a)
          (fun addr ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (load_mem64
              sr
              addr)
            (fun val0 ->
            de_float_of_float64
              val0
              rm))
      | FPM80_op a ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (compute_addr
            a)
          (fun addr ->
          load_mem80
            sr
            addr))
  
  (** val conv_FNCLEX :
      unit
      coq_Conv **)
  
  let conv_FNCLEX =
    bind
      (Obj.magic
        coq_Conv_monad)
      (set_fpu_flag_const
        X86_MACHINE.F_PE
        Big.zero)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_flag_const
          X86_MACHINE.F_UE
          Big.zero)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (set_fpu_flag_const
            X86_MACHINE.F_OE
            Big.zero)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (set_fpu_flag_const
              X86_MACHINE.F_ZE
              Big.zero)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_fpu_flag_const
                X86_MACHINE.F_DE
                Big.zero)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set_fpu_flag_const
                  X86_MACHINE.F_IE
                  Big.zero)
                (fun x4 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_fpu_flag_const
                    X86_MACHINE.F_ES
                    Big.zero)
                  (fun x5 ->
                  set_fpu_flag_const
                    X86_MACHINE.F_Busy
                    Big.zero)))))))
  
  (** val init_control_word :
      unit
      coq_Conv **)
  
  let init_control_word =
    bind
      (Obj.magic
        coq_Conv_monad)
      (set_fpu_ctrl_const
        X86_MACHINE.F_Res15
        Big.zero)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_ctrl_const
          X86_MACHINE.F_Res14
          Big.zero)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (set_fpu_ctrl_const
            X86_MACHINE.F_Res13
            Big.zero)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (set_fpu_ctrl_const
              X86_MACHINE.F_IC
              Big.zero)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_fpu_rctrl_const
                Mode_NE)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set_fpu_pctrl_const
                  PC_double_extended)
                (fun x4 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_fpu_ctrl_const
                    X86_MACHINE.F_Res6
                    Big.zero)
                  (fun x5 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (set_fpu_ctrl_const
                      X86_MACHINE.F_Res7
                      Big.one)
                    (fun x6 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_fpu_ctrl_const
                        X86_MACHINE.F_PM
                        Big.one)
                      (fun x7 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (set_fpu_ctrl_const
                          X86_MACHINE.F_UM
                          Big.one)
                        (fun x8 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (set_fpu_ctrl_const
                            X86_MACHINE.F_OM
                            Big.one)
                          (fun x9 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (set_fpu_ctrl_const
                              X86_MACHINE.F_ZM
                              Big.one)
                            (fun x10 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (set_fpu_ctrl_const
                                X86_MACHINE.F_DM
                                Big.one)
                              (fun x11 ->
                              set_fpu_ctrl_const
                                X86_MACHINE.F_IM
                                Big.one)))))))))))))
  
  (** val init_status_word :
      unit
      coq_Conv **)
  
  let init_status_word =
    bind
      (Obj.magic
        coq_Conv_monad)
      (set_fpu_flag_const
        X86_MACHINE.F_Busy
        Big.zero)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_flag_const
          X86_MACHINE.F_C3
          Big.zero)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (set_stktop_const
            Big.zero)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (set_fpu_flag_const
              X86_MACHINE.F_C2
              Big.zero)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_fpu_flag_const
                X86_MACHINE.F_C1
                Big.zero)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set_fpu_flag_const
                  X86_MACHINE.F_C0
                  Big.zero)
                (fun x4 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_fpu_flag_const
                    X86_MACHINE.F_ES
                    Big.zero)
                  (fun x5 ->
                  bind
                    (Obj.magic
                      coq_Conv_monad)
                    (set_fpu_flag_const
                      X86_MACHINE.F_SF
                      Big.zero)
                    (fun x6 ->
                    bind
                      (Obj.magic
                        coq_Conv_monad)
                      (set_fpu_flag_const
                        X86_MACHINE.F_PE
                        Big.zero)
                      (fun x7 ->
                      bind
                        (Obj.magic
                          coq_Conv_monad)
                        (set_fpu_flag_const
                          X86_MACHINE.F_UE
                          Big.zero)
                        (fun x8 ->
                        bind
                          (Obj.magic
                            coq_Conv_monad)
                          (set_fpu_flag_const
                            X86_MACHINE.F_OE
                            Big.zero)
                          (fun x9 ->
                          bind
                            (Obj.magic
                              coq_Conv_monad)
                            (set_fpu_flag_const
                              X86_MACHINE.F_ZE
                              Big.zero)
                            (fun x10 ->
                            bind
                              (Obj.magic
                                coq_Conv_monad)
                              (set_fpu_flag_const
                                X86_MACHINE.F_DE
                                Big.zero)
                              (fun x11 ->
                              set_fpu_flag_const
                                X86_MACHINE.F_IE
                                Big.zero)))))))))))))
  
  (** val init_tag_word :
      unit
      coq_Conv **)
  
  let init_tag_word =
    bind
      (Obj.magic
        coq_Conv_monad)
      (set_fpu_tag_const
        Big.zero
        TM_empty)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_tag_const
          Big.one
          TM_empty)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (set_fpu_tag_const
            (Big.double
            Big.one)
            TM_empty)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (set_fpu_tag_const
              (Big.doubleplusone
              Big.one)
              TM_empty)
            (fun x2 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (set_fpu_tag_const
                (Big.double
                (Big.double
                Big.one))
                TM_empty)
              (fun x3 ->
              bind
                (Obj.magic
                  coq_Conv_monad)
                (set_fpu_tag_const
                  (Big.doubleplusone
                  (Big.double
                  Big.one))
                  TM_empty)
                (fun x4 ->
                bind
                  (Obj.magic
                    coq_Conv_monad)
                  (set_fpu_tag_const
                    (Big.double
                    (Big.doubleplusone
                    Big.one))
                    TM_empty)
                  (fun x5 ->
                  set_fpu_tag_const
                    (Big.doubleplusone
                    (Big.doubleplusone
                    Big.one))
                    TM_empty)))))))
  
  (** val init_last_ptrs :
      unit
      coq_Conv **)
  
  let init_last_ptrs =
    bind
      (Obj.magic
        coq_Conv_monad)
      (set_fpu_lastInstrPtr_const
        Big.zero)
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_lastDataPtr_const
          Big.zero)
        (fun x0 ->
        set_fpu_lastOpcode_const
          Big.zero))
  
  (** val conv_FNINIT :
      unit
      coq_Conv **)
  
  let conv_FNINIT =
    bind
      (Obj.magic
        coq_Conv_monad)
      init_control_word
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        init_status_word
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          init_tag_word
          (fun x1 ->
          init_last_ptrs)))
  
  (** val conv_FINCSTP :
      unit
      coq_Conv **)
  
  let conv_FINCSTP =
    bind
      (Obj.magic
        coq_Conv_monad)
      inc_stktop
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_flag_const
          X86_MACHINE.F_C1
          Big.zero)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_fpu_flag
            X86_MACHINE.F_C0)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_fpu_flag
              X86_MACHINE.F_C2)
            (fun x2 ->
            undef_fpu_flag
              X86_MACHINE.F_C3))))
  
  (** val conv_FDECSTP :
      unit
      coq_Conv **)
  
  let conv_FDECSTP =
    bind
      (Obj.magic
        coq_Conv_monad)
      dec_stktop
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (set_fpu_flag_const
          X86_MACHINE.F_C1
          Big.zero)
        (fun x0 ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (undef_fpu_flag
            X86_MACHINE.F_C0)
          (fun x1 ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_fpu_flag
              X86_MACHINE.F_C2)
            (fun x2 ->
            undef_fpu_flag
              X86_MACHINE.F_C3))))
  
  (** val stk_push_and_set_tag :
      X86_RTL.rtl_exp
      ->
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let stk_push_and_set_tag f =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (stk_push
          f))
      (fun x ->
      bind
        (Obj.magic
          coq_Conv_monad)
        get_stktop
        (fun topp ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (is_nonempty_tag
            topp)
          (fun notempty ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (enc_tag
              f)
            (fun tag ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (Obj.magic
                (set_fpu_tag
                  topp
                  tag))
              (fun x0 ->
              return
                (Obj.magic
                  coq_Conv_monad)
                notempty)))))
  
  (** val conv_FLD :
      prefix
      ->
      fp_operand
      ->
      unit
      coq_Conv **)
  
  let conv_FLD pre op =
    bind
      (Obj.magic
        coq_Conv_monad)
      (Obj.magic
        (load_fp_op
          pre
          DS
          op))
      (fun v ->
      bind
        (Obj.magic
          coq_Conv_monad)
        (Obj.magic
          (stk_push_and_set_tag
            v))
        (fun overflow ->
        bind
          (Obj.magic
            coq_Conv_monad)
          (set_fpu_flag
            X86_MACHINE.F_C1
            overflow)
          (fun x ->
          bind
            (Obj.magic
              coq_Conv_monad)
            (undef_fpu_flag
              X86_MACHINE.F_C0)
            (fun x0 ->
            bind
              (Obj.magic
                coq_Conv_monad)
              (undef_fpu_flag
                X86_MACHINE.F_C2)
              (fun x1 ->
              undef_fpu_flag
                X86_MACHINE.F_C3)))))
  
  (** val load_stktop :
      X86_RTL.rtl_exp
      coq_Conv **)
  
  let load_stktop =
    bind
      (Obj.magic
        coq_Conv_monad)
      get_stktop
      (fun topp ->
      get_fpu_reg
        topp)
  
  (** val conv_FST : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FST pre op =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
        (fun v ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (is_empty_tag topp))
          (fun underflow ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl)
            (fun rm ->
            let sr = get_segment pre DS in
            bind (Obj.magic coq_Conv_monad)
              (match op with
               | FPS_op i ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (freg_of_offset i)) (fun fi ->
                   set_fpu_reg fi v)
               | FPM16_op a -> coq_EMIT X86_RTL.Coq_error_rtl
               | FPM32_op a ->
                 bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
                   (fun addr ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (float32_of_de_float v rm)) (fun f32 ->
                     set_mem32 sr f32 addr))
               | FPM64_op a ->
                 bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
                   (fun addr ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (float64_of_de_float v rm)) (fun f64 ->
                     set_mem64 sr f64 addr))
               | FPM80_op a ->
                 bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
                   (fun addr -> set_mem80 sr v addr)) (fun x ->
              bind (Obj.magic coq_Conv_monad)
                (undef_fpu_flag X86_MACHINE.F_C1) (fun x0 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (load_Z size1 Big.zero)) (fun zero0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (if_test underflow (X86_RTL.Coq_set_loc_rtl (size1,
                      zero0, (X86_MACHINE.Coq_fpu_flag_loc
                      X86_MACHINE.F_C1)))) (fun x1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (undef_fpu_flag X86_MACHINE.F_C0) (fun x2 ->
                      bind (Obj.magic coq_Conv_monad)
                        (undef_fpu_flag X86_MACHINE.F_C2) (fun x3 ->
                        undef_fpu_flag X86_MACHINE.F_C3))))))))))
  
  (** val stk_pop_and_set_tag : unit coq_Conv **)
  
  let stk_pop_and_set_tag =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_Z size2 (enc_fpu_tag_mode TM_empty)))
        (fun tag_emp ->
        bind (Obj.magic coq_Conv_monad) (set_fpu_tag topp tag_emp) (fun x ->
          inc_stktop)))
  
  (** val conv_FSTP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FSTP pre op =
    bind (Obj.magic coq_Conv_monad) (conv_FST pre op) (fun x ->
      stk_pop_and_set_tag)
  
  (** val pos1 : int0 **)
  
  let pos1 =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
          (append ('1'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
            (append
              ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
              (append
                ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                (append
                  ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                  (append
                    ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                    (append
                      ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                      (append
                        ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                        ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[])))))))))))))))))
  
  (** val log2_10 : int0 **)
  
  let log2_10 =
    s2int80
      (append ('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
        (append ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
          (append ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::[]))))))))
            (append
              ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
              (append
                ('0'::('1'::('1'::('1'::('1'::('0'::('0'::('0'::[]))))))))
                (append
                  ('0'::('1'::('0'::('0'::('1'::('0'::('1'::('1'::[]))))))))
                  (append
                    ('1'::('1'::('0'::('0'::('1'::('1'::('0'::('1'::[]))))))))
                    (append
                      ('0'::('0'::('0'::('1'::('1'::('0'::('1'::('1'::[]))))))))
                      (append
                        ('1'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[]))))))))
                        ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('0'::[])))))))))))))))))
  
  (** val log2_e : int0 **)
  
  let log2_e =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
          (append ('1'::('0'::('1'::('1'::('1'::('0'::('0'::('0'::[]))))))))
            (append
              ('1'::('0'::('1'::('0'::('1'::('0'::('1'::('0'::[]))))))))
              (append
                ('0'::('0'::('1'::('1'::('1'::('0'::('1'::('1'::[]))))))))
                (append
                  ('0'::('0'::('1'::('0'::('1'::('0'::('0'::('1'::[]))))))))
                  (append
                    ('0'::('1'::('0'::('1'::('1'::('1'::('0'::('0'::[]))))))))
                    (append
                      ('0'::('0'::('0'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                      (append
                        ('1'::('1'::('1'::('1'::('0'::('0'::('0'::('0'::[]))))))))
                        ('1'::('0'::('1'::('1'::('1'::('1'::('0'::('0'::[])))))))))))))))))
  
  (** val pi : int0 **)
  
  let pi =
    s2int80
      (append ('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
        (append ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
          (append ('1'::('1'::('0'::('0'::('1'::('0'::('0'::('1'::[]))))))))
            (append
              ('0'::('0'::('0'::('0'::('1'::('1'::('1'::('1'::[]))))))))
              (append
                ('1'::('1'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
                (append
                  ('1'::('0'::('1'::('0'::('0'::('0'::('1'::('0'::[]))))))))
                  (append
                    ('0'::('0'::('1'::('0'::('0'::('0'::('0'::('1'::[]))))))))
                    (append
                      ('0'::('1'::('1'::('0'::('1'::('0'::('0'::('0'::[]))))))))
                      (append
                        ('1'::('1'::('0'::('0'::('0'::('0'::('1'::('0'::[]))))))))
                        ('0'::('0'::('1'::('1'::('0'::('1'::('0'::('1'::[])))))))))))))))))
  
  (** val log10_2 : int0 **)
  
  let log10_2 =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('0'::('1'::[]))))))))
          (append ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
            (append
              ('0'::('0'::('1'::('0'::('0'::('0'::('0'::('0'::[]))))))))
              (append
                ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
                (append
                  ('1'::('0'::('0'::('0'::('0'::('1'::('0'::('0'::[]))))))))
                  (append
                    ('1'::('1'::('1'::('1'::('1'::('0'::('1'::('1'::[]))))))))
                    (append
                      ('1'::('1'::('0'::('0'::('1'::('1'::('1'::('1'::[]))))))))
                      (append
                        ('1'::('1'::('1'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                        ('1'::('0'::('0'::('1'::('1'::('0'::('0'::('1'::[])))))))))))))))))
  
  (** val loge_2 : int0 **)
  
  let loge_2 =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('0'::[]))))))))
          (append ('1'::('0'::('1'::('1'::('0'::('0'::('0'::('1'::[]))))))))
            (append
              ('0'::('1'::('1'::('1'::('0'::('0'::('1'::('0'::[]))))))))
              (append
                ('0'::('0'::('0'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                (append
                  ('1'::('1'::('1'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                  (append
                    ('1'::('1'::('0'::('1'::('0'::('0'::('0'::('1'::[]))))))))
                    (append
                      ('1'::('1'::('0'::('0'::('1'::('1'::('1'::('1'::[]))))))))
                      (append
                        ('0'::('1'::('1'::('1'::('1'::('0'::('0'::('1'::[]))))))))
                        ('1'::('0'::('1'::('0'::('1'::('1'::('0'::('0'::[])))))))))))))))))
  
  (** val conv_load_fpconstant : int0 -> unit coq_Conv **)
  
  let conv_load_fpconstant c =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_int size80 c))
      (fun r2 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (stk_push_and_set_tag r2))
        (fun overflow ->
        bind (Obj.magic coq_Conv_monad)
          (set_fpu_flag X86_MACHINE.F_C1 overflow) (fun x ->
          bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C0)
            (fun x0 ->
            bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C2)
              (fun x1 -> undef_fpu_flag X86_MACHINE.F_C3)))))
  
  (** val conv_FLDZ : unit coq_Conv **)
  
  let conv_FLDZ =
    conv_load_fpconstant (Word.repr size80 Big.zero)
  
  (** val conv_FLD1 : unit coq_Conv **)
  
  let conv_FLD1 =
    conv_load_fpconstant pos1
  
  (** val conv_FLDPI : unit coq_Conv **)
  
  let conv_FLDPI =
    conv_load_fpconstant pi
  
  (** val conv_FLDL2T : unit coq_Conv **)
  
  let conv_FLDL2T =
    conv_load_fpconstant log2_10
  
  (** val conv_FLDL2E : unit coq_Conv **)
  
  let conv_FLDL2E =
    conv_load_fpconstant log2_e
  
  (** val conv_FLDLG2 : unit coq_Conv **)
  
  let conv_FLDLG2 =
    conv_load_fpconstant log10_2
  
  (** val conv_FLDLN2 : unit coq_Conv **)
  
  let conv_FLDLN2 =
    conv_load_fpconstant loge_2
  
  (** val farith_float79 :
      X86_RTL.float_arith_op -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let farith_float79 op rm e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_farith_rtl_exp
      ((Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one))),
      (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))))), op, rm, e1, e2))
  
  (** val farith_de :
      X86_RTL.float_arith_op -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let farith_de op rm e1 e2 =
    bind (Obj.magic coq_Conv_monad) (float79_of_de_float e1) (fun e1' ->
      bind (Obj.magic coq_Conv_monad) (float79_of_de_float e2) (fun e2' ->
        bind (Obj.magic coq_Conv_monad) (farith_float79 op rm e1' e2')
          (fun res -> de_float_of_float79 res)))
  
  (** val conv_farith :
      X86_RTL.float_arith_op -> bool -> prefix -> bool -> fp_operand -> unit
      coq_Conv **)
  
  let conv_farith fop noreverse pre zerod op =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_fp_op pre DS op))
      (fun opv ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
          (fun st0 ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic (is_empty_tag topp))
            (fun underflow ->
            bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl)
              (fun rm ->
              bind (Obj.magic coq_Conv_monad)
                (if zerod
                 then if noreverse
                      then Obj.magic (farith_de fop rm st0 opv)
                      else Obj.magic (farith_de fop rm opv st0)
                 else if noreverse
                      then Obj.magic (farith_de fop rm opv st0)
                      else Obj.magic (farith_de fop rm st0 opv)) (fun res ->
                bind (Obj.magic coq_Conv_monad)
                  (if zerod
                   then (match op with
                         | FPM16_op a -> coq_EMIT X86_RTL.Coq_error_rtl
                         | FPM80_op a -> coq_EMIT X86_RTL.Coq_error_rtl
                         | _ -> set_fpu_reg topp res)
                   else (match op with
                         | FPS_op i ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic (freg_of_offset i)) (fun fi ->
                             set_fpu_reg fi res)
                         | _ -> coq_EMIT X86_RTL.Coq_error_rtl)) (fun x ->
                  bind (Obj.magic coq_Conv_monad)
                    (undef_fpu_flag X86_MACHINE.F_C1) (fun x0 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (load_Z size1 Big.zero)) (fun zero0 ->
                      bind (Obj.magic coq_Conv_monad)
                        (if_test underflow (X86_RTL.Coq_set_loc_rtl (size1,
                          zero0, (X86_MACHINE.Coq_fpu_flag_loc
                          X86_MACHINE.F_C1)))) (fun x1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (undef_fpu_flag X86_MACHINE.F_C0) (fun x2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (undef_fpu_flag X86_MACHINE.F_C2) (fun x3 ->
                            undef_fpu_flag X86_MACHINE.F_C3))))))))))))
  
  (** val conv_farith_and_pop :
      X86_RTL.float_arith_op -> bool -> prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_farith_and_pop fop noreverse pre op = match op with
  | FPS_op i ->
    bind (Obj.magic coq_Conv_monad) (conv_farith fop noreverse pre false op)
      (fun x -> stk_pop_and_set_tag)
  | _ -> coq_EMIT X86_RTL.Coq_error_rtl
  
  (** val conv_FADD : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FADD =
    conv_farith X86_RTL.Coq_fadd_op true
  
  (** val conv_FSUB : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUB =
    conv_farith X86_RTL.Coq_fsub_op true
  
  (** val conv_FMUL : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FMUL =
    conv_farith X86_RTL.Coq_fmul_op true
  
  (** val conv_FDIV : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIV =
    conv_farith X86_RTL.Coq_fdiv_op true
  
  (** val conv_FADDP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FADDP =
    conv_farith_and_pop X86_RTL.Coq_fadd_op true
  
  (** val conv_FSUBP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUBP =
    conv_farith_and_pop X86_RTL.Coq_fsub_op true
  
  (** val conv_FMULP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FMULP =
    conv_farith_and_pop X86_RTL.Coq_fmul_op true
  
  (** val conv_FDIVP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIVP =
    conv_farith_and_pop X86_RTL.Coq_fdiv_op true
  
  (** val conv_FSUBR : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUBR =
    conv_farith X86_RTL.Coq_fsub_op false
  
  (** val conv_FDIVR : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIVR =
    conv_farith X86_RTL.Coq_fdiv_op false
  
  (** val conv_FSUBRP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUBRP =
    conv_farith_and_pop X86_RTL.Coq_fsub_op false
  
  (** val conv_FDIVRP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIVRP =
    conv_farith_and_pop X86_RTL.Coq_fdiv_op false
  
  (** val float_compare : de_float -> de_float -> comparison **)
  
  let float_compare a b =
    let aR =
      b2R (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))) (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))))))))))) a
    in
    let bR =
      b2R (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))) (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))))))))))) b
    in
    rcompare aR bR
  
  (** val set_CC_flags : comparison -> unit coq_Conv **)
  
  let set_CC_flags = function
  | Eq ->
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_C3 Big.one) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x0 ->
        set_fpu_flag_const X86_MACHINE.F_C0 Big.zero))
  | Lt ->
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_C3 Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x0 ->
        set_fpu_flag_const X86_MACHINE.F_C0 Big.one))
  | Gt ->
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_C3 Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x0 ->
        set_fpu_flag_const X86_MACHINE.F_C0 Big.zero))
  
  (** val conv_FCOM : fp_operand option -> unit coq_Conv **)
  
  let conv_FCOM op1 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
        (fun st0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl) (fun rm ->
          match op1 with
          | Some op ->
            (match op with
             | FPM32_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem32 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float32 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | FPM64_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem64 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float64 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | _ -> undef_fpu_flag X86_MACHINE.F_C3)
          | None -> undef_fpu_flag X86_MACHINE.F_C3)))
  
  (** val conv_FICOM : fp_operand option -> unit coq_Conv **)
  
  let conv_FICOM op1 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
        (fun st0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl) (fun rm ->
          match op1 with
          | Some op ->
            (match op with
             | FPM32_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem32 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float32 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | FPM64_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem64 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float64 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | _ -> undef_fpu_flag X86_MACHINE.F_C3)
          | None -> undef_fpu_flag X86_MACHINE.F_C3)))
  
  (** val conv_FCOMP : fp_operand option -> unit coq_Conv **)
  
  let conv_FCOMP op1 =
    bind (Obj.magic coq_Conv_monad) (conv_FCOM op1) (fun x ->
      stk_pop_and_set_tag)
  
  (** val conv_FCOMPP : unit coq_Conv **)
  
  let conv_FCOMPP =
    bind (Obj.magic coq_Conv_monad) (conv_FCOMP None) (fun x ->
      stk_pop_and_set_tag)
  
  (** val conv_FICOMP : fp_operand option -> unit coq_Conv **)
  
  let conv_FICOMP op1 =
    bind (Obj.magic coq_Conv_monad) (conv_FICOM op1) (fun x ->
      stk_pop_and_set_tag)
  
  (** val conv_FICOMPP : unit coq_Conv **)
  
  let conv_FICOMPP =
    bind (Obj.magic coq_Conv_monad) (conv_FICOMP None) (fun x ->
      stk_pop_and_set_tag)
  
  (** val instr_to_rtl : prefix -> instr -> X86_RTL.rtl_instr list **)
  
  let instr_to_rtl pre i =
    runConv
      (bind (Obj.magic coq_Conv_monad) (check_prefix pre) (fun x ->
        match i with
        | AAA -> conv_AAA_AAS X86_RTL.Coq_add_op
        | AAD -> conv_AAD
        | AAM -> conv_AAM
        | AAS -> conv_AAA_AAS X86_RTL.Coq_sub_op
        | ADC (w, op1, op2) -> conv_ADC pre w op1 op2
        | ADD (w, op1, op2) -> conv_ADD pre w op1 op2
        | AND (w, op1, op2) -> conv_AND pre w op1 op2
        | BSF (op1, op2) -> conv_BSF pre op1 op2
        | BSR (op1, op2) -> conv_BSR pre op1 op2
        | BSWAP r2 -> conv_BSWAP pre r2
        | BT (op1, op2) -> conv_BT false true pre op1 op2
        | BTC (op1, op2) -> conv_BT false false pre op1 op2
        | BTR (op1, op2) -> conv_BT true false pre op1 op2
        | BTS (op1, op2) -> conv_BT true true pre op1 op2
        | CALL (near, abs0, op1, sel) -> conv_CALL pre near abs0 op1 sel
        | CDQ -> conv_CDQ pre
        | CLC -> conv_CLC
        | CLD -> conv_CLD
        | CMC -> conv_CMC
        | CMOVcc (ct, op1, op2) -> conv_CMOV pre true ct op1 op2
        | CMP (w, op1, op2) -> conv_CMP pre w op1 op2
        | CMPS w -> conv_CMPS pre w
        | CMPXCHG (w, op1, op2) -> conv_CMPXCHG pre w op1 op2
        | CWDE -> conv_CWDE pre
        | DAA -> conv_DAA_DAS X86_RTL.Coq_add_op (testcarryAdd size8)
        | DAS -> conv_DAA_DAS X86_RTL.Coq_sub_op (testcarrySub size8)
        | DEC (w, op1) -> conv_DEC pre w op1
        | DIV (w, op) -> conv_DIV pre w op
        | FADD (d, op1) -> conv_FADD pre d op1
        | FADDP op1 -> conv_FADDP pre op1
        | FDECSTP -> conv_FDECSTP
        | FDIV (d, op) -> conv_FDIV pre d op
        | FDIVP op -> conv_FDIVP pre op
        | FDIVR (d, op) -> conv_FDIVR pre d op
        | FDIVRP op -> conv_FDIVRP pre op
        | FINCSTP -> conv_FINCSTP
        | FLD op -> conv_FLD pre op
        | FLDL2E -> conv_FLDL2E
        | FLDL2T -> conv_FLDL2T
        | FLDLG2 -> conv_FLDLG2
        | FLDLN2 -> conv_FLDLN2
        | FLDPI -> conv_FLDPI
        | FLDZ -> conv_FLDZ
        | FMUL (d, op1) -> conv_FMUL pre d op1
        | FMULP op1 -> conv_FMULP pre op1
        | FNCLEX -> conv_FNCLEX
        | FNINIT -> conv_FNINIT
        | FST op1 -> conv_FST pre op1
        | FSTP op1 -> conv_FSTP pre op1
        | FSUB (d, op1) -> conv_FSUB pre d op1
        | FSUBP op1 -> conv_FSUBP pre op1
        | FSUBR (d, op) -> conv_FSUBR pre d op
        | FSUBRP op -> conv_FSUBRP pre op
        | HLT -> conv_HLT pre
        | IDIV (w, op) -> conv_IDIV pre w op
        | IMUL (w, op1, op2, i0) -> conv_IMUL pre w op1 op2 i0
        | INC (w, op1) -> conv_INC pre w op1
        | Jcc (ct, disp) -> conv_Jcc pre ct disp
        | JMP (near, abs0, op1, sel) -> conv_JMP pre near abs0 op1 sel
        | LAHF -> conv_LAHF
        | LEA (op1, op2) -> conv_LEA pre op1 op2
        | LEAVE -> conv_LEAVE pre
        | LOOP disp -> conv_LOOP pre false false disp
        | LOOPZ disp -> conv_LOOP pre true true disp
        | LOOPNZ disp -> conv_LOOP pre true false disp
        | MOV (w, op1, op2) -> conv_MOV pre w op1 op2
        | MOVS w -> conv_MOVS pre w
        | MOVSX (w, op1, op2) -> conv_MOVSX pre w op1 op2
        | MOVZX (w, op1, op2) -> conv_MOVZX pre w op1 op2
        | MUL (w, op) -> conv_MUL pre w op
        | NEG (w, op1) -> conv_NEG pre w op1
        | NOP op -> return (Obj.magic coq_Conv_monad) ()
        | NOT (w, op1) -> conv_NOT pre w op1
        | OR (w, op1, op2) -> conv_OR pre w op1 op2
        | POP op -> conv_POP pre op
        | POPA -> conv_POPA pre
        | PUSH (w, op) -> conv_PUSH pre w op
        | PUSHA -> conv_PUSHA pre
        | RCL (w, op1, op2) -> conv_RCL pre w op1 op2
        | RCR (w, op1, op2) -> conv_RCR pre w op1 op2
        | RET (ss, disp) -> conv_RET pre ss disp
        | ROL (w, op1, op2) -> conv_ROL pre w op1 op2
        | ROR (w, op1, op2) -> conv_ROR pre w op1 op2
        | SAHF -> conv_SAHF
        | SAR (w, op1, op2) -> conv_SAR pre w op1 op2
        | SBB (w, op1, op2) -> conv_SBB pre w op1 op2
        | SETcc (ct, op) -> conv_SETcc pre ct op
        | SHL (w, op1, op2) -> conv_SHL pre w op1 op2
        | SHLD (op1, op2, ri) -> conv_SHLD pre op1 op2 ri
        | SHR (w, op1, op2) -> conv_SHR pre w op1 op2
        | SHRD (op1, op2, ri) -> conv_SHRD pre op1 op2 ri
        | STC -> conv_STC
        | STD -> conv_STD
        | STOS w -> conv_STOS pre w
        | SUB (w, op1, op2) -> conv_SUB pre w op1 op2
        | TEST (w, op1, op2) -> conv_TEST pre w op1 op2
        | XADD (w, op1, op2) -> conv_XADD pre w op1 op2
        | XCHG (w, op1, op2) -> conv_XCHG pre w op1 op2
        | XOR (w, op1, op2) -> conv_XOR pre w op1 op2
        | _ -> coq_EMIT X86_RTL.Coq_error_rtl))
 end

(** val in_seg_bounds : segment_register -> int32 -> bool X86_RTL.coq_RTL **)

let in_seg_bounds s o1 =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic
      (X86_RTL.get_loc size32 (X86_MACHINE.Coq_seg_reg_limit_loc s)))
    (fun seg_limit ->
    return (Obj.magic X86_RTL.coq_RTL_monad)
      (Word.lequ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) o1 seg_limit))

(** val in_seg_bounds_rng :
    segment_register -> int32 -> int32 -> bool X86_RTL.coq_RTL **)

let in_seg_bounds_rng s o1 offset =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic
      (X86_RTL.get_loc size32 (X86_MACHINE.Coq_seg_reg_limit_loc s)))
    (fun seg_limit ->
    let o2 =
      Word.add (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) o1 offset
    in
    return (Obj.magic X86_RTL.coq_RTL_monad)
      ((&&)
        (Word.lequ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) o1 o2)
        (Word.lequ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) o2
          seg_limit)))

type parseState_t = instParserState

(** val parse_instr_aux :
    Big.big_int -> int32 -> Big.big_int -> parseState_t ->
    ((prefix * instr) * Big.big_int) X86_RTL.coq_RTL **)

let rec parse_instr_aux n loc0 len ps =
  Big.nat_case
    (fun _ ->
    X86_RTL.coq_Fail)
    (fun m ->
    bind (Obj.magic X86_RTL.coq_RTL_monad)
      (Obj.magic (X86_RTL.get_byte loc0)) (fun b ->
      let (ps', l) = X86_PARSER.parse_byte ps b in
      (match l with
       | [] ->
         parse_instr_aux m
           (Word.add (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) loc0
             (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
               Big.one)) (Coq_Pos.add len Big.one) ps'
       | v :: l0 -> return (Obj.magic X86_RTL.coq_RTL_monad) (v, len))))
    n

(** val initial_parser_state : parseState_t option **)

let initial_parser_state =
  X86_PARSER.opt_initial_decoder_state (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val parse_instr' :
    parseState_t option -> int32 -> ((prefix * instr) * Big.big_int)
    X86_RTL.coq_RTL **)

let parse_instr' ps pc =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic
      (X86_RTL.get_loc size32 (X86_MACHINE.Coq_seg_reg_start_loc CS)))
    (fun seg_start ->
    let real_pc = Word.add size32 seg_start pc in
    (match ps with
     | Some ps0 ->
       parse_instr_aux (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
         (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
         real_pc Big.one ps0
     | None -> X86_RTL.coq_Fail))

(** val parse_instr :
    int32 -> ((prefix * instr) * Big.big_int) X86_RTL.coq_RTL **)

let parse_instr =
  parse_instr' initial_parser_state

(** val fetch_instruction :
    int32 -> ((prefix * instr) * Big.big_int) X86_RTL.coq_RTL **)

let fetch_instruction pc =
  bind (Obj.magic X86_RTL.coq_RTL_monad) (parse_instr pc) (fun v ->
    let (pi0, len) = v in
    bind (Obj.magic X86_RTL.coq_RTL_monad)
      (Obj.magic
        (in_seg_bounds_rng CS pc
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
            (Z.sub len Big.one)))) (fun in_bounds_rng ->
      if in_bounds_rng
      then return (Obj.magic X86_RTL.coq_RTL_monad) (pi0, len)
      else X86_RTL.coq_Trap))

(** val rTL_step_list : X86_RTL.rtl_instr list -> unit X86_RTL.coq_RTL **)

let rec rTL_step_list = function
| [] -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| i :: l' ->
  bind (Obj.magic X86_RTL.coq_RTL_monad) (X86_RTL.interp_rtl i) (fun x ->
    rTL_step_list l')

(** val check_rep_instr : instr -> unit X86_RTL.coq_RTL **)

let check_rep_instr = function
| CMPS w -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| MOVS w -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| STOS w -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| _ -> X86_RTL.coq_Fail

(** val run_rep : prefix -> instr -> int32 -> unit X86_RTL.coq_RTL **)

let run_rep pre ins default_new_pc =
  bind (Obj.magic X86_RTL.coq_RTL_monad) (check_rep_instr ins) (fun x ->
    bind (Obj.magic X86_RTL.coq_RTL_monad)
      (Obj.magic (X86_RTL.get_loc size32 (X86_MACHINE.Coq_reg_loc ECX)))
      (fun ecx ->
      if Word.eq size32 ecx (Word.zero size32)
      then X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc default_new_pc
      else bind (Obj.magic X86_RTL.coq_RTL_monad)
             (X86_RTL.set_loc size32 (X86_MACHINE.Coq_reg_loc ECX)
               (Word.sub size32 ecx (Word.one size32))) (fun x0 ->
             bind (Obj.magic X86_RTL.coq_RTL_monad)
               (rTL_step_list (X86_Compile.instr_to_rtl pre ins)) (fun x1 ->
               bind (Obj.magic X86_RTL.coq_RTL_monad)
                 (Obj.magic
                   (X86_RTL.get_loc size32 (X86_MACHINE.Coq_reg_loc ECX)))
                 (fun ecx' ->
                 bind (Obj.magic X86_RTL.coq_RTL_monad)
                   (if Word.eq size32 ecx' (Word.zero size32)
                    then X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc
                           default_new_pc
                    else return (Obj.magic X86_RTL.coq_RTL_monad) ())
                   (fun x2 ->
                   match ins with
                   | CMPS w ->
                     bind (Obj.magic X86_RTL.coq_RTL_monad)
                       (Obj.magic
                         (X86_RTL.get_loc size1 (X86_MACHINE.Coq_flag_loc
                           X86_MACHINE.ZF))) (fun zf ->
                       if Word.eq size1 zf (Word.zero size1)
                       then X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc
                              default_new_pc
                       else return (Obj.magic X86_RTL.coq_RTL_monad) ())
                   | _ -> return (Obj.magic X86_RTL.coq_RTL_monad) ()))))))

(** val step : unit X86_RTL.coq_RTL **)

let step =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic (X86_RTL.get_loc size32 X86_MACHINE.Coq_pc_loc)) (fun pc ->
    bind (Obj.magic X86_RTL.coq_RTL_monad) (Obj.magic (in_seg_bounds CS pc))
      (fun pc_in_bounds -> print_string "Test go on 3\n";
      if pc_in_bounds
      then bind (Obj.magic X86_RTL.coq_RTL_monad)
             (Obj.magic (fetch_instruction pc)) (fun v ->
             let (pi0, length1) = v in
             let (pre, instr0) = pi0 in
             let default_new_pc =
               Word.add size32 pc (Word.repr size32 length1)
             in
             (match pre.lock_rep with
              | Some l ->
                (match l with
                 | Rep -> run_rep pre instr0 default_new_pc
                 | _ -> X86_RTL.coq_Fail)
              | None ->
                bind (Obj.magic X86_RTL.coq_RTL_monad)
                  (X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc
                    default_new_pc) (fun x ->
                  rTL_step_list (X86_Compile.instr_to_rtl pre instr0))))
      else X86_RTL.coq_Trap))


